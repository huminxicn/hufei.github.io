<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Multivariate Linear Regression]]></title>
    <url>%2F2018%2F06%2F04%2FMultivariate%20Linear%20Regression%2F</url>
    <content type="text"></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Multivariate Linear Regression</tag>
        <tag>多元线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv4 和 IPv6]]></title>
    <url>%2F2018%2F06%2F03%2FIPv4%20%E5%92%8C%20IPv6%2F</url>
    <content type="text"><![CDATA[相信接触过网络编程的人都会听到这样一种说法：IPv4 的地址马上就不够用了，大家快去使用 IPv6 吧，因为它的地址有 2¹²⁸ 个，不会面临 IP 地址短缺的情况。真的是这样的吗? IP 协议简介现行的网络层 IP 协议存在两个版本，IPv4(Internet Protocol version 4)和 IPv6。IPv4 是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4 是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为 IPv6，直到 2011 年，IANA IPv4 地址完全用尽时，IPv6 仍处在部署的初期。 IPv6 的设计目的是取代 IPv4，然而长期以来 IPv4 在互联网流量中仍占据主要地位，IPv6 的使用增长缓慢。在 2017 年 7 月，通过 IPv6 使用 Google 服务的用户百分率首次超过 20%。 IPv4下图表示了 IPv4 数据报组成格式。 IPv4 数据报 IPv4 数据数据报中的关键字段如下: Version 版本号。这 4 bit 规定了数据报的 IP 协议版本，IPv4=0100。通过查看版本号，路由器能够确定如何解释 IP 数据报的剩余部分(不同的 IP 版本使用不同的数据报格式)。 Header length 首部长度。包括了 Options 的长度，但不包括 Data 长度。这个字段占 4 个 bit，其中每一个 bit 表示 4 个字节（units of 32 bits），这个字段最大值是 0xFFFF (15)，所以 Header 最长占 60 个字节，去掉 Header 中固定的 20 个字节，剩下有 40 个字节留给 Options。 Type of service TOS。该字段用来区分 IP 数据报的类型。例如，将实时流量（如用于 IP 电话应用）与非实时流量（如 FTP)区分开。 Datagram length(bytes) 数据报长度。这是 IP 数据报的总长度（Header+Data），以字节计。因为该字段长为 16 bit，所以 IP 数据报的理论最大长度为 65535 字节。然而，数据报很少有超过 1500 字节的。 16-bit Identifier、Flags、13-bit Fragmentation offset 标识、标志、片偏移。这三个字段与 IP 分组分片有关。有趣的是，新版本的 IPv6 不允许在路由器上对分组分片。 Time-to-live TTL。该字段用来确保数据报不会永远（如路由选择存在环路时）在网络中循环。每当数据报由一台路由器处理时，该字段的值减 1。若 TTL 字段减为 0，则该数据报必须丢弃。 Upper-layer protocol 上层协议。该字段仅在 IP 数据报到达其最终目的地才会有用。该字段值指示了 IP 数据报的数据部分应交给哪个特定的运输层协议。例如，值为 6 表明数据部分要交给 TCP，而值为 17 表明数据要交给 UDP，详细参见 Protocol Numbers。值得注意的是——协议号在 IP 数据报中所起的作用，类似于端口号字段在运输层报文段中所起的作用。协议号是将网络层与运输层绑定到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。 Header checksum 首部校验和。首部检验和用于帮助路由器检测收到的 IP 数据报中的比特差错。首部校验和计算可以参考 《比特差错检测和纠正技术》。路由器要对每个收到的 IP 数据报计算其首部检验和，如果数据报首部中携带的检验和与计算得到的检验和不一致，则检测出比特差错。路由器一般会丢弃检测出错误的数据报。注意到在每台路由器上必须重新计算检验和并再次放到原处，因为 TTL 字段以及 Options(if any) 字段会改变。 32-bit Source/Destination IP address 源和目的 IP 地址。源主机可以通过 DNS 解析来查找目的地址。 Options(if any) 选项。选项字段允许 IP 首部被扩展。然而，选项的存在的确是件复杂的事，因为数据报头长度可变，故不能预先确定数据字段从何处开始。而且还因为有些数据报要求处理选项，而有些数据报则不要求，故导致一台路由器处理一个 IP 数据报所需的时间变化很大。这些考虑对于高性能路由器和主机上的 IP 处理来说特别重要。由于这样或那样的原因，在 IPv6 首部中已去掉了该字段。 Data 有效载荷。这是最后的也是最重要的字段，这是数据报存在的首要理由！在大多数情况下 IP 数据报中的数据字段包含要交付给目的地的运输层报文段(TCP 或 UDP)。然而，该数据字段也可承载其他类型的数据，如 ICMP 报文。 注意到一个 IP 数据报有总长为 20 字节的首部（假设无选项）。 IPv6下图表示了 IPv6 数据报组成格式。 IPv6 数据报 IPv6 数据数据报中的关键字段如下: Version 版本号。IPv6=0110。 Traffic class 流量类型。该 8 bit 字段与我们在 IPv4 中看到的 TOS 字段的含义相似。 Flow label 流标签。它被用来提醒路由器来重复使用之前的接力路径。这样 IP 包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。Flow label 的进一步使用还在开发中。 Payload length 有效载荷长度。该 16 bit 值作为一个无符号整数，给出了 IPv6 数据报中 Data 部分的长度。 Next header 下一个首部。该字段标识数据报中的数据字段需要交付给哪个协议（如 TCP 或 UDP)。该字段使用与 IPv4 首部中 Upper-layer protocol 字段相同的值。 Hop limit 跳限制。转发数据报的每台路由器将对该字段的内容减 1。如果跳限制计数到达 0 时，则该数据报将被丢弃。 Source/Destination address 源和目的地址。 Data 有效载荷。 注意到一个 IP 数据报有定长为 40 字节的首部。 对比下面是 IPv4 与 IPv6 数据报首部字段对比图。 IPv4 与 IPv6 首部字段对比图 本文引自 《计算机网络:自定向下方法》 IPv4 Protocol Numbers IPv4 与 IPv6 头部的对比 IPv4 header 分析]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>IPv4</tag>
        <tag>IPv6</tag>
        <tag>Datagram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特差错检测和纠正技术]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[数据在链路层传输时，比特差错是一个无法忽视的问题。那么，当比特差错发生了之后我们如何检测和纠正比特差错呢？本文主要给大家介绍检测比特差错的基本思想和三种具体的实现技术，它们分别是：奇偶校验(用来描述差错检测和纠正背后的基本思想)、校验和(应用于运输层)、循环冗余检测(应用于链路层)。 如何发现比特差错图 5-3 说明了我们研究的场景。在发送结点，为了保护比特免受差错，使用差错检测和纠正比特(Error-Detection and-Correction, EDC)来增强数据 D。通常，要保护的数据不仅包括从网络层传递下来的数据报(Datagram)，而且包括链路帧(Frame)首部中的链路级的寻址信息、序号和其他字段。链路级帧中的 D 和 EDC 都被发送到接收结点。在接收结点，接收到比特序列 D’和 EDC’。值得注意的是，因传输中的比特翻转所致，D’ 和 EDC’ 可能与初始的 D 和 EDC 不同。 图 5-3 错误检测与纠正场景 接收方的挑战是在它只收到 D’ 和 EDC’ 的情况下，确定 D’ 是否和初始的 D 相同。在 图 5-3 中的接收方判定的准确措词（我们是否检测到一个差错，而非是否出现了差错！）是重要的。差错检测和纠正技术使接收方有时但并非总是检测出已经出现的比特差错。即使采用差错检测比特，也还是可能有未检出的比特差错(undetected bit error)。这就是说，接收方可能无法知道接收的信息中包含着比特差错。因此，接收方可能向网络层交付一个损伤的数据报，或者不知道该帧首部的某个其他字段的内容已经损伤。 因此，我们要选择一个差错检测方案，使得这种事件发生的概率很小。一般而言，差错检测和纠错技术越复杂，导致的开销就越大，这就意味着需要更多的计算及更多的差错检测和纠正比特。 奇偶校验(Parity Checks)检测也许差错检测最简单的方式就是用单个奇偶校验位(parity bit)。假设在 图 5-4 中要发送的信息 D 有 d 个比特。在偶校验方案中，发送方只需要包含一个附加的比特，选择它的值，使得这 d+1 个比特中有偶数个 1。对于奇校验方案，选择校验比特值使得有奇数个 1。 图 5-4 描述了一个偶校验的方案，单个校验比特被存放在一个单独的字段中。 图 5-4 一比特位的偶校验 采用单个奇偶校验位方式，接收方的操作也很简单。接收方只需要数一数接收的 d+1 比特中 1 的数目即可。如果在采用偶校验方案中发现了奇数个值为 1 的比特，接收方知道至少出现了一个比特差错。更精确的说法是，出现了奇数个比特差错。 未检测出的比特差错如果出现了偶数个比特差错，那会发生什么现象呢？你应该认识到这将导致一个未检出的差错。如果比特差错的概率小，而且比特之间的差错可以被看作是独立发生的，在一个分组中多个比特同时出错的概率将是极小的。在这种情况下，单个奇偶校验位可能是足够了。但是，现实场景中差错经常以『突发』方式聚集在一起，而不是独立的发生。在突发差错的情况下，使用单比特奇偶校验保护的一帧中未检测出差错的概率是 50%。显然，需要一个更加健壮的差错检测方案。 纠错在研究实践中使用的差错检测方案之前，我们考虑对单比特奇偶校验的一种简单一般化方案，这将使我们深入地理解纠错技术。图 5-5 显示了单比特奇偶校验方案的二维一般化方案。这里 D 中的 d 个比特被划分为 i 行 j 列。对每行和每列计算奇偶值。产生的 i+j+1 奇偶比特构成了链路层帧的差错检测比特。 图 5-5 二维偶校验 现在假设在初始 d 比特信息中出现了单个比特差错。使用这种二维奇偶校验(two-dimensional parity)方案，包含比特值改变的行和列的校验值都会出现差错。因此接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用行和列的索引来定位发生差错的比特并纠正它! 接收方检测和纠正差错的能力被称为前向纠错(Forward Error Correction, FEC)。这些技术通常用于如音频 CD 这样的音频存储和回放设备中。FEC 技术很有价值，因为它们可以减少发送方重发的次数。更为重要的是，它们允许在接收方立即纠正差错。FEC 避免了不得不等待的往返时延，而这些时延是发送方收到 NAK 分组并向接收方重传分组时所需要的，这对于实时网络应用或者具有长传播时延的链路可能是一种非常重要的优点。 校验和方法(Checksum Methods)在检验和技术中， 图 5-4 中的 d 比特数据被作为一个 k 比特整数的序列处理。一个简单检验和方法就是将这 k 比特整数加起来，并且用得到的和作为差错检测比特。因特网检验和(Internet checksum) 就基于这种方法，将数据的字节作为 16 比特的整数对待并求和。这个和的反码就是携带在报文段首部的因特网检验和。接收方通过对接收的数据（包括检验和）的和取反码，并且检测其结果是否为全 1 来检测检验和。如果这些比特中有任何比特是 0，就可以指示出现差错。RFC1071 详细地讨论因特网检验和算法和它的实现。在 TCP 和 UDP 协议中， 对所有字段（包括首部和数据字段）都计算因特网检验和。 检验和方法需要相对小的分组开销。例如，TCP 和 UDP 中的检验和只用了 16 比特。然而，与后面要讨论的常用于链路层的 CRC 相比，它们提供相对弱的差错保护。这时，一个很自然的问题是：为什么运输层使用检验和而链路层使用 CRC 呢？前面讲过运输层通常是在主机中作为用户操作系统的一部分，通常是用软件来实现的。因为运输层差错检测用软件实现，采用简单而快速(如检验和这样)的差错检测方案是重要的。在另一方面，链路层的差错检测在适配器中用专用的硬件实现，它能够快速执行更复杂的 CRC 操作。 循环冗余检测(Cyclic Redundancy Check)现今的计算机网络中广泛应用的差错检测技术基于循环冗余检测(Cyclic Redundancy Check, CRC)编码。CRC 编码也称为多项式编码(polynomial code), 因为该编码能够将要发送的比特串看作系数是 0 和 1 的一个多项式，对比特串的操作被解释为多项式算术。CRC 编码操作如下。考虑 d 比特的数据 D，发送结点要将它发送给接收结点。发送方和接收方首先必须协商一个 r+1 比特模式，称为生成多项式(generator)，我们将其表示为 G。我们将要求 G 的最高有效位的比特是 1。 CRC 编码的关键思想如 图 5-6 所示。对于一个给定的数据段 D，发送方要选择 r 个附加比特 R，并将它们附加到 D 上，使得得到的 d+r 比特模式（被解释为一个二进制数）用模 2 算术恰好能被 G 整除（即余数为 0）。 图 5-6 crc 用 CRC 进行差错检测的过程因此很简单：接收方用 C 去除接收到的 d+r 比特。如果余数为非零，接收方知道出现了差错；否则认为数据正确而被接收。 所有 CRC 计算采用模 2 算术来做(在加法中不进位，在减法中不借位)。这意味着加法和减法是相同的，而且这两种操作等价于操作数的按位异或(XOR)。 图 5-7 一个例子 本文引自 《计算机网络:自定向下方法》 校验和算法分析 RFC1071 最通俗的 CRC 校验原理剖析 循环冗余校验]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>bit</tag>
        <tag>差错检测</tag>
        <tag>差错纠正</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学与生活]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B8%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[一提起统计学，大家脑海中浮现的第一印象是什么？就我而言，我第一时间想到的就是那个著名的 抛硬币 实验。最近看了一本书，叫 《赤裸裸的统计学》，在里面发现了几个有趣的小故事，想与大家分享一下。 什么是概率概率描述的是事件发生的可能性。 先来做两道判断题: 天气预报说，明天有 99% 的概率会下雨，所以明天一定下雨。对吗？ 中国的 LOL 战队在 S8 赛季有 1% 的概率会夺冠，所以中国队在 S8 赛季不可能夺冠。对吗？ 小结: 再大概率的事件也有可能不发生 再小概率的事件也有可能发生 蒙提霍尔问题Q 在上个世纪的美国，有一个电视节目叫 “Let’s Make a Deal”，由当时极受欢迎的蒙提霍尔主持。在每天节目快要结束时，胜出的选手和蒙提霍尔都会站在 3 扇大门的前面。蒙提霍尔或告诉观众和选手，在其中一扇大门的门后会有一项大奖，如一辆小轿车，而另外两扇门的后面则各站着一头山羊。玩法很简单：选手选择一扇门，然后就会得到这扇门后面的奖品。 当选手和蒙提霍尔站在这 3 扇门的前面时，这位选手中大奖的概率为 1/3。但是，这档节目却有其微妙之处。当参赛者选定了一扇门，但未去开启它的时候，知道门后情形的蒙提霍尔会开启剩下两扇门的其中一扇，露出其中一只山羊。主持人随后会问参赛者要不要更换为另一扇关着的门？ 这就是蒙提霍尔问题，如果换成是你，你又会怎么选呢？ A 答案是：当参赛者转向另一扇门而不是继续维持原先的选择时，赢得汽车的机会将会加倍! 三门问题 三门问题是多门问题里最难的情况。如果把三门变成千门，参赛者第一次就选中的概率就是 1/1000，参赛者就会清楚自己是在猜，而不是如同三门的时候 1/3 的概率认为自己是对的。这样，当主持人打开剩下 999 扇门中的 998 扇时，该如何选择，认真思考就会比三门的时候清晰很多。 施利茨啤酒广告 1981 年，美国约瑟夫·施利茨酿酒公司斥 170 万美元巨资为该公司旗下的旗舰品牌——施利茨啤酒开展了一场大胆而冒险的市场营销活动。当美国橄榄球超级杯大赛(即『超级碗』)的中场休息时间一到，施利茨公司就会当着全球亿万电视观众的面，现场直播一场别开生面的啤酒品鉴会，而挑选的对手不是别人，正是施利茨的死对头——米切罗啤酒。更让人大跌眼镜的是，参加品鉴会的不是别人，正是 100 名米切罗啤酒的忠实用户。这样的广告从始至终出现在季后赛的每一场比赛当中。类似的电视直播啤酒品鉴会总共有 5 场，每场都会邀请 100 名某品牌啤酒的『拥趸』，包括百威、米勒、米切罗等，让这些啤酒爱好者在自己最钟爱的啤酒和施利茨啤酒之间进行『盲品』。 广告噱头很明确：即使是那些自认为喜欢另一种品牌的啤酒爱好者，在盲品时也会发现自己更偏爱施利茨啤酒。啤酒公司甚至还请了一位橄榄球职业联赛的前裁判来监督整个活动过程。考虑到在数量众多的电视观众面前举办这样一场充满风险的啤酒品鉴会，你肯定会觉得施利茨啤酒的口感一定特别好，否则哪会有勇气搞这样的宣传，是吗？ 让我们假设，要让施利茨公司满意，100 位盲品者中至少要有 40 位选择施利茨啤酒。这是一个非常可观的数字，因为所有参加盲品直播的人都曾信誓旦旦地声明自己是米切罗的忠实用户。而要达到这样的效果，其实一点儿都不难。施利茨只需要保证以下两点，那么他的计谋很大概率上就能成功： 施利茨生产出的啤酒与其它品牌的啤酒在盲品时没有明显区别 每场盲品的用户数量较多 这样一来，盲品结果就如抛硬币实验的结果一样，运用概率学的基本知识，就能得出至少有 40 人选择施利茨的概率为 98%，至少有 45 人选择施利茨的概率为 86%。从理论上来看，这场电视营销活动其实并没有很大的风险。 那么这 98% 和 86% 的概率是怎么计算出来的呢？不要着急，我们接着往下看。 相关事件和独立事件我们在生活中时常会遇到随机事件。抛硬币、掷骰子、刮奖彩票等都是随机事件。你要学会区分哪些随机事件是属于独立事件，哪些随机事件是属于相关事件。 相关事件，上一个事件会影响到下一个事件 例，从布袋里不放回地拿玻璃球。每拿走一颗玻璃球，袋子里就少一颗玻璃球，概率也随之改变。 独立事件，不受过去事件的影响 例，抛硬币。硬币不知道它曾经是正面向上还是反面向上。所以每一次抛掷硬币的结果都是独立事件。 赌徒谬误我们先来看一下抛硬币的例子。抛掷一枚硬币，出现正面和反面的概率各 0.5，抛掷第 1 次，结果为正面的概率为 0.5。那么抛掷第 2 次和抛掷第 3 次，结果为正面的概率是多少呢？还是 0.5。 有些人可能想：『已经三次正面了，这一次应该轮到反面了吧』。其实不然，下一次抛掷为正面的概率依然是 0.5。 独立事件的概率两个或多个独立事件同时发生的概率是每个事件概率的乘积。 掷 1 次可能出现的结果有 2 个，正、反。因为 p=0.5，所以每个结果出现的概率是 0.5，那么正面出现 1 次、0 次的概率为 0.5、0.5。 掷 2 次可能出现的结果有 4 个，正正、正反、反正、反反。每个结果出现的概率是 0.5×0.5=0.25，那正面出现 2 次、1 次、0 次的概率分别是 0.25、0.5、0.25。 掷 3 次可能出现的结果有 8 个，正正正、正正反、正反正、正反反、反正正、反正反、反反正、反反反。每个结果出现的概率是 0.5×0.5×0.5=0.125，那正面出现 3 次、2 次、1 次、0 次的概率分别是 0.125、0.375、0.375、0.125。 但如果我们抛了 100 次硬币，这个时候又该如何计算每个结果出现的概率呢，难道要一一列举出来吗。结果的概率计算有规律吗?有的。 假设 p 是我们预期事件发生的概率(正面向上) k 是我们预期事件发生的次数(0≤k≤n) 总共进行了 n 次实验 所以，每个结果出现的概率就是 $$ p^k(1-p)^{n-k} $$ 排列与组合 排列，对选出来元素的顺序有要求 例，从 3 到 9 共计 7 个号码球，从中选三个号码球用来组成一个三位数，请问可以组成多少个三位数？百位数有 7 种可能，十位数有 (7-1) 种可能，个位数有 (7-1-1) 种可能，共计有 210=7*6*5 种排列。即 $$ A_7^3 = \frac{7!}{(7-3)!} $$ 组合，对选出来元素的顺序无要求 例，从 3 到 9 共计 7 个号码球，从中选三个号码球用来炸金花，请问有多少种组合？假设你扎金花的时候拿到了三张牌 345，那么无论你排成 345 354 435 453 534 543，大家都会认为它是同一个顺子。所以这里计算的话需要多一个去重的步骤。共计有 35=7*6*5/3*2*1 种组合。即 $$ C_7^3 = \frac{7!}{(7-3)!3!} $$ 二项分布什么是二项分布 每次试验是独立事件 每次试验只有两个可能的结果 每次试验中成功的概率是不变的 二项分布的概率计算公式 $$P(n取k)=\frac{n!}{(n-k)!k!}p^k(1-p)^{n-k}$$ 举个例子 求抛掷 3 次硬币时，只有两个正面向上的硬币的概率为多大？ 将 n=3，p=0.5，k=2，带入得到每个结果的发生的概率为 $$p=0.5^2(1-0.5)^{3-2}=0.125$$ 那么该结果出现的次数是 $$ C_3^2=\frac{3!}{(3-2)!2!}=3$$ 所以，P(3取2)=3×0.125=0.375 再回到我们的施利茨啤酒广告，$$P(至少要有40位选择施利茨啤酒)=P(40)+P(41)+…+P(100)\approx 0.982$$ $$P(至少要有45位选择施利茨啤酒)=P(45)+P(41)+…+P(100)\approx 0.864$$ P(x&gt;=40) P(x&gt;=45) 生活中还有哪些与统计学相关的有趣故事呢？欢迎大家在下方留言。 附 计算 P(x) 的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package statistics;import java.math.BigDecimal;/** * 二项分布 * &lt;p&gt; * 这里计算的是 p=0.5 的情况。 */public class BinomialDistribution &#123; /** * 在 n 次实验中，预期的结果次数 = x 次的概率 * * @param n * @param x * @return */ public static BigDecimal equals(int n, int x) &#123; //n! BigDecimal nFactorial = new BigDecimal(1); //(n-x)! BigDecimal nSubxFactorial = new BigDecimal(1); //临时值 BigDecimal temp = BigDecimal.ZERO; //结果值 BigDecimal result = BigDecimal.ZERO; for (int i = n; i &gt; x; i--) &#123; nFactorial = nFactorial.multiply(new BigDecimal(i)); &#125; for (int i = (n - x); i &gt; 0; i--) &#123; nSubxFactorial = nSubxFactorial.multiply(new BigDecimal(i)); &#125; temp = nFactorial.divide(nSubxFactorial); //这里计算的是 p 的概率为 1/2 的二项分布 for (int i = n; i &gt; 0; i--) &#123; temp = temp.divide(new BigDecimal(2)); &#125; result = temp; return result; &#125; /** * 在 n 次实验中，预期的结果次数 &lt; x 次的概率 * * @param n * @param x * @return */ public static BigDecimal lessThan(int n, int x) &#123; BigDecimal result = BigDecimal.ZERO; for (int i = (x - 1); i &gt; 0; i--) &#123; result = result.add(equals(n, i)); &#125; return result; &#125; /** * 在 n 次实验中，预期的结果次数 &gt;= x 次的概率 * * @param n * @param x * @return */ public static BigDecimal moreThan(int n, int x) &#123; BigDecimal result = BigDecimal.ZERO; for (int i = x; i &lt; n; i++) &#123; result = result.add(equals(n, i)); &#125; return result; &#125; public static void main(String[] args) &#123; int n = 100;//总的实验次数 int x = 40;//预期的结果次数 System.out.println("P(x=" + x + ") = " + equals(n, x)); System.out.println("P(x&lt;" + x + ") = " + lessThan(n, x)); System.out.println("P(x&gt;=" + x + ") = " + moreThan(n, x)); &#125;&#125; 本文引自 《赤裸裸的统计学》 蒙提霍尔问题 赌徒谬误 概率：独立事件 二项分布 数学和算法之—排列组合 统计基础篇之十：怎么理解二项分布 从零开始 LaTeX 快速入门 MathJax 入门指南]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>统计学</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Java 怎么导出 CSV 格式的文件]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%94%A8%20Java%20%E6%80%8E%E4%B9%88%E5%AF%BC%E5%87%BA%20CSV%20%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[大家在做 web 开发时常碰到的一个需求就是：将网页上某个列表页的数据导出。有的要求导出成 excel 格式的文件，有的要求导出成 csv 格式的文件。今天就来给大家介绍怎么利用 java 导出 csv 格式的文件。 什么是 CSV 格式的文件逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符不一定是逗号），其文件以纯文本形式存储表格数据。纯文本意味着该文件是一个字符序列，即二进制编码的数据都可以被解读成人类可读的形式。CSV 文件由任意数目的记录组成，记录之间以 某种换行符 分隔；每条记录由字段组成，字段之间的分隔符是特定的字符或字符串，最常见的是逗号或制表符。通常，所有记录都拥有完全相同的字段。 下面就是一个符合 csv 格式的示例文件 12345nama,age,gender张三,18,男李四,20,男小红,12,女小明,12,男 导出需要注意的点 可以通过重写数据模型的 toString 方法来提高生成 csv 文件的速度 返回文件的具体编码格式根据需求来定，这里用的是 UTF-8 编码 根据业务要求和服务器性能设定一个单次导出上限值 具体实现这里是后端直接提供 HTTP 导出接口。 定义一个数据模型根据要导出的字段来定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.nongfenqi.transport.export;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.math.BigDecimal;/** * 导出物流列表的数据模型 */@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class LogisticsExport implements Serializable &#123; //物流单编号 private String logisticsInfoId; //发货单编号 private String deliveryOrderId; //厂家名称 private String supplierName; //仓库名称 private String warehouseName; //品牌名称 private String goodsBrandName; //商品名称 private String goodsName; //包装数 单位:袋 private BigDecimal goodsPackageNumber; //重量 单位:吨 private BigDecimal goodsNumber; //收货人姓名 private String customerName; //收货人手机号 private String customerPhone; //收货地址 private String receiptAddress; //紧急联系人1 private String firstEmergencyContacter; //紧急联系人1手机号 private String firstEmergencyContacterPhone; //紧急联系人2 private String secondEmergencyContacter; //紧急联系人2手机号 private String secondEmergencyContacterPhone; //这里重写 toString 方法，是为了方便导出 CSV 文件。 @Override public String toString() &#123; return logisticsInfoId + "," + deliveryOrderId + "," + supplierName + "," + warehouseName + "," + goodsBrandName + "," + goodsName + "," + goodsPackageNumber + "," + goodsNumber + "," + customerName + "," + receiptAddress + "," + firstEmergencyContacter + "," + firstEmergencyContacterPhone + "," + secondEmergencyContacter + "," + secondEmergencyContacterPhone; &#125;&#125; 写一个工具类工具类中包含了两个方法：一个是将数据模型转换成临时的 csv 文件；另一个是将临时 csv 文件写入到 HttpServletResponse 中返回给浏览器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.nongfenqi.transport.common;import com.nongfenqi.transport.export.LogisticsExport;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;import java.text.DateFormat;import java.util.List;/** * 导出工具类 */@Service@Slf4jpublic class ExportUtil &#123; // csv 文件的标题行 private static String TITLE_LINE = "物流单编号" + "," + "发货单编号" + "," + "厂家名称" + "," + "发货基地" + "," + "品牌名称" + "," + "商品名称" + "," + "包装数 单位:袋" + "," + "重量 单位:吨" + "," + "收货人姓名" + "," + "收货地址" + "," + "紧急联系人1" + "," + "紧急联系人1手机号" + "," + "紧急联系人2" + "," + "紧急联系人2手机号" + ","; /** * 创建一个 CSV 格式的临时文件 * * @param logisticsExports * @return * @throws IOException */ public static File createLogisticsCVSFile(List&lt;LogisticsExport&gt; logisticsExports) throws IOException &#123; File tempFile = File.createTempFile(DateFormat.getDateTimeInstance().toString(), ".csv"); OutputStream out = new FileOutputStream(tempFile); BufferedWriter bw = new BufferedWriter(new FileWriter(tempFile, true)); bw.write(TITLE_LINE); bw.newLine(); for (LogisticsExport logistics : logisticsExports) &#123; bw.write(logistics.toString()); bw.newLine(); &#125; bw.close(); return tempFile; &#125; /** * 导出 CSV 文件 * * @param response * @param file * @param fileName * @throws IOException */ public static void exportCSVFile(HttpServletResponse response, File file, String fileName) throws IOException &#123; response.setContentType("application/csv;charset=UTF-8"); response.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode(fileName, "UTF-8")); InputStream in = null; try &#123; in = new FileInputStream(file); int len = 0; byte[] buffer = new byte[1024]; response.setCharacterEncoding("UTF-8"); OutputStream out = response.getOutputStream(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(new byte[]&#123;(byte) 0xEF, (byte) 0xBB, (byte) 0xBF&#125;); out.write(buffer, 0, len); &#125; &#125; catch (FileNotFoundException e) &#123; log.warn(e.getMessage()); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125;&#125; 写一个 HTTP 接口利用 Spring 框架，写一个 RestController 接口给前端或者浏览器端调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.nongfenqi.transport.controller;import com.nongfenqi.transport.PageQueryReq;import com.nongfenqi.transport.QuerySortReq;import com.nongfenqi.transport.common.ExportUtil;import com.nongfenqi.transport.export.LogisticsExport;import com.nongfenqi.transport.logistics.LogisticsQuery;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.Collections;import java.util.List;/** * 物流公司业务接口 */@RestController@RequestMapping("/logistics")public class TempLogisticsController &#123; @RequestMapping(value = "export", method = RequestMethod.GET) public void exportLogisticsList( @ModelAttribute PageQueryReq pageQuery, @ModelAttribute QuerySortReq querySortReq, @ModelAttribute LogisticsQuery logisticsQuery, HttpServletResponse response ) throws IOException &#123; // 根据条件筛选出具体需要导出的数据列表 LogisticsExport logisticsExport = LogisticsExport.builder() .logisticsInfoId("1") .deliveryOrderId("2") .build(); List&lt;LogisticsExport&gt; logisticsExports = Collections.singletonList(logisticsExport); // 创建一个 CSV 格式的临时文件 File logisticsCVSFile = ExportUtil.createLogisticsCVSFile(logisticsExports); // 将 CSV 文件写入到 HttpServletResponse 当中，返回给浏览器 ExportUtil.exportCSVFile(response, logisticsCVSFile, "logistics.csv"); &#125;&#125; 本文引自 逗号分隔值 Java 流(Stream)、文件(File)和 IO 回车和换行]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>CSV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Maven]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%88%9D%E8%AF%86%20Maven%2F</url>
    <content type="text"><![CDATA[相信从事 Java 开发的小伙伴们对 Maven 这个词都不陌生。目前来说，只要存在外部依赖的 Java 项目基本上都是 Maven 项目，而每个 Maven 项目都有一个明显的特征——pom.xml 文件。 今天，我们就一起来学习一下什么是 Maven 项目。 新建一个 Maven 项目安装 JDKMaven 是一个 Java 工具，因此必须先 安装 Java 开发环境 之后才能继续。 安装 Maven首先，下载 Maven 并按照 安装说明 进行操作。之后，在终端输入以下命令: 1mvn -v 它会打印出你刚才安装的 Maven 版本，如下图所示: Maven 版本 创建一个项目新建一个空目录 maven，然后执行下列命令创建一个新的 Maven 项目 1mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=Maven-archetype-quickstart -DinteractiveMode=false creating a project 如果是刚刚安装了 Maven，则第一次运行可能需要一段时间。这是因为 Maven 正在将插件的 jar 包以及其它的文件下载到本地存储库中。 total time 再次查看该目录，多了一个 my-app 目录。进入 my-app 目录，并查看其目录结构，发现它果然也包含了 pom.xml 文件。 my-app 目录结构接下来用你惯用的 IDE 打开 my-app 项目，这里使用的是 IDEA。 利用 IDEA 打开 my-app 项目 目录结构如下 src/main/java 项目源码 src/test/java 测试代码 pom.xml 项目对象模型(Project Object Model) POM 文件pom.xml 文件是 Maven 项目配置的核心。它是一个单独的配置文件，其中包含以您想要的方式构建项目所需的大部分信息。my-app 项目的 pom.xml 如下: 123456789101112131415161718192021&lt;project xmlns="http://Maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://Maven.apache.org/POM/4.0.0 http://Maven.apache.org/Maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://Maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 打包执行下列命令 1mvn package 打包成功后，其结果输出到 target 目录中。 package success 在 IDEA 中查看 target 目录 校验可以使用下面的命令来测试新打的 jar 包: 1java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App 在命令行执行 Java 程序 到这里，我们已经知道该如何新建一个 Maven 项目了。那么，为什么现在大多数的 Java 项目都是 Maven 项目呢？我们下期再聊。 本文引自 Maven in 5 Minutes java -cp 用法介绍]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可靠数据传输服务续]]></title>
    <url>%2F2018%2F03%2F23%2F%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[经过 前文 的介绍，我们现在已经有了一个可以在『存在比特差错的丢包信道』上进行可靠数据传输(reliable data transfer)的协议——rdt3.0。但同时我们也发现了 rdt3.0 其实并不完善，因为它是一个停等(stop-and-wait)协议，所以还存在性能方面的问题待优化。今天我们就一起来看看具体是怎么优化的吧！ 由停等到流水线 为了评价该停等行为对性能的影响，可考虑一种具有两台主机的理想化场合，一台主机位于美国西海岸，另一台位于美国东海岸，如图 3-17 所示。在这两个端系统之间的光速往返传播时延 RTT 大约为 30 毫秒。假定彼此通过一条发送速率 R 为 1Gbps (每秒 10⁹ 比特）的信道相连。包括首部字段和数据的分组长 L 为 1000 字节(8000 比特），发送一个分组进入 1Gbps 链路实际所需时间是: $$T𝗍𝗋𝖺𝗇𝗌=\frac{L}{R}=\frac{8000 bit}{10⁹ bit/s}=8µs$$ 图 3-17 停等协议与流水线协议 图 3-18a 显示了对于该停等协议，如果发送方在 t=0 时刻开始发送分组，则在 t=L/R=8µs 后，最后 1 比特数据进入了发送端信道。该分组经过 15ms 后到达接收端，该分组的最后 1 比特在时刻 T=RTT/2 + L/R= 15.008ms 时到达接收方。为了简化起见，假设 ACK 分组很小（以便我们可以忽略其发送时间），接收方一旦收到一个数据分组的最后 1 比特后立即发送 ACK，ACK 在时刻 t = RTT + L/R =30.008ms 时在发送方出现。此时，发送方可以发送下一个报文。因此，在 30.008ms 内，发送方的发送只用了 0.008ms。如果我们定义发送方（或信道）的利用率 (utilization) 为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比，图 3-18a 中的分析表明了停等协议有着非常低的发送方利用率 U𝗌𝚎𝗇𝚍𝚎𝚛: $$U𝗌𝚎𝚗𝚍𝚎𝚛=\frac{L/R}{RTT+L/R}=\frac{0.008 ms}{30.008 ms}=0.00027$$ 图 3-18 停等和流水线发送 这就是说，发送方只有万分之 2.7 的时间是忙的。 从其他角度来看，发送方在 30.008m 内只能发送 1000 字节，有效的吞吐量仅为 267kbps，即使有 1Gbps 的链路可用！想象一个不幸的网络经理购买了一条千兆比特率的链路，但他仅能得到 267kbps 吞吐量的情况！这是一个形象的网络协议限制底层网络硬件所提供的能力的示例。而且，我们还忽略了在发送方和接收方的底层协议处理时间，以及可能出现在发送方与接收方之间的任何中间路由器上的处理与排队时延。考虑到这些因素，将进一步增加时延，使其性能更糟糕。 解决这种特殊的性能问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认，如在图 3-17b 图示的那样。图 3-18b 显示了如果发送方可以在等待确认之前发送 3 个报文，其利用率也基本上提高 3 倍。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为流水线(pipelining)。流水线技术对可靠数据传输协议可能带来如下影响: 必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。 协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓存那些已发送但没有确认的分组。如下面讨论的那样，接收方或许也需要缓存那些已正确接收的分组。 所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：回退 N 步(Go-Back-N，GBN)和选择重传(Selective Repeat，SR)。 Go-Back-N滑动窗口协议 在回退 N 步(GBN)协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。 图 3-19 显示了发送方看到的 GBN 协议的序号范围。如果我们将基序号(base)定义为最早的未确认分组的序号，将下一个序号(nextseqnum)定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割成 4 段。在 [0, base-1] 段内的序号对应于已经发送而且被确认的分组。[base, nextseqnum - 1] 段内对应已经发送但未被确认的分组。[nextseqnum, base + N - 1] 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于 base + N 的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为 base 的分组）已得到确认为止。 图 3-19 在 GBN 中发送方看到的序号 如图 3-19 所示的那样，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为窗口长度(window size)，GBN 协议也常被称为滑动窗口协议 (sliding-window protocol)。 你也许想知道，我们为什么要限制这些被发送的、未被确认的分组的数目为 N 呢？为什么不允许这些分组为无限制的数目呢？流量控制是对发送方施加限制的原因之一。当然还有其它的原因在里面，我们这里不展开讨论。 在实践中，一个分组的序号是放在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是 k，则该序号范围是 [0, 2ᵏ - 1] 。在一个有限的序号范围内，所有涉及序号的运算必须使用模 2ᵏ 运算(可将序号空间看作是一个长度为 2ᵏ 的环，其中序号 2ᵏ - 1 紧挨着序号 0)。前面讲过，rdt3.0 有一个比特的序号，其序号范围是 [0, 1] (而 TCP 的序号字段有 32 比特)。 发送方 FSM图 3-20 GBN 发送方的扩展 FSM 描述 GBN 发送方必须响应三种类型的事件: 上层的调用。当上层调用 rdt_send() 时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过会儿再试。在实际实现上，发送方更可能缓存（并不立刻发送）这些数据，或者使用同步机制(如一个信号量或标志)允许上层在仅当窗口不满时才调用 rdt_send()。 收到一个 ACK。在 GBN 协议中，对序号为 n 的分组的确认采取累积确认(cumulative acknowledgment)的方式，表明接收方已正确接收到序号为 n 的之前且包括 n 在内的所有分组。稍后讨论 GBN 接收方时，我们将再次研究这个主题。 超时事件。协议的名字『回退 N 步』来源于出现丢失和时延过长的分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。图 3-20 中的发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个 ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已经发送但未被确认的分组，该定时器被终止。 接收方 FSM图 3-21 GBN 接收方的扩展 FSM 描述 在 GBN 中，接收方的动作也很简单。如果一个序号为 n 的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为 n-1 的分组），则接收方为分组 n 发送一个 ACK，并将该分组中的数据交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK。注意到因为一次交付给上层一个分组，如果分组 k 已接收并交付，则所有比 k 小的分组也已经交付。因此，使用累积确认是 GBN 的一个自然选择。 在 GBN 协议中，接收方丢弃所有失序分组。尽管丢弃一个正确接收(但失序)的分组有点愚蠢和浪费，但这样做是有理由的。前面讲过，接收方必须按序将数据交付给上层。假定现在期望接收分组 n，而分组 n+1 却到了。因为数据必须按序交付，接收方可能缓存分组 n+1，然后，在它收到并交付分组 n 后，再将该分组交付到上层。然而，如果分组 n 丢失，则该分组及分组 n+1 最终将在发送方根据 GBN 重传规则而被重传。因此，接收方只需丢弃分组 n+1 即可。 这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及 nextseqnum 在该窗口中的位置，但是接收方只需要维护下一个按序接收的分组的序号即可。该值保存在 expectedseqnum 变量中，如图 3-21 中接收方 FSM 所示。当然，丢弃一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此可能需要更多的重传。 运行中的 GBN 图 3-22 给出了窗口长度为 4 个分组的 GBN 协议的运行情况。因为该窗口长度的限制，发送方发送分组 0-3，然后在继续发送之前，必须等待直到一个或多个分组被确认。当接收到每一个连续的 ACK(例如 ACK 0 和 ACK 1)时，该窗口便向前滑动，发送方就可以发送新的分组(分别是分组 4 和分组 5)。在接收方，分组 2 丢失，因此分组 3、4 和 5 被发现是失序分组并被丢弃。 图 3-22 运行中的 GBN Selective RepeatGBN 大批量重传的问题 在图 3-17 中，GBN 协议潜在地允许发送方用多个分组『填充流水线』，因此缓解了停等协议中所提到的信道利用率问题。然而，GBN 本身也有一些情况存在着性能问题。尤其是当窗口长度和带宽时延的乘积很大时，在流水线(分组更多)中更为严重。单个分组的差错就能够引起 GBN 重传大批分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。想象一下，在我们口述消息的例子中，如果每次有一个单词含糊不清，其前后 1000 个单词(假设窗口长度为 1000 个单词)不得不被重传的情况。此次口述将会由于这些反复述说的单词而变慢。 顾名思义，选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方出错(即丢失或受损)的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度 N 来限制流水线中未完成、未被确认的分组数。然而，与 GBN 不同的是，发送方已经收到了对窗口中某些分组的 ACK。图 3-23 显示了 SR 发送方和接收方看到的序号空间。 图 3-23 SR 发送方与接收方的序号空间 SR senderSR 发送方的事件与动作 从上层收到数据。当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将数据缓存，要么将其返回给上层以便以后传输。 超时。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。 收到 ACK。如果收到 ACK，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于 send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。 SR receiverSR 接收方的事件与动作 序号在 [rcv_base, rcv_base + N - 1] 内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（图 3-23 中的 rcv_base)，则将该分组以及以前缓存的序号连续的(起始于 rcv_base 的)分组交付给上层。然后，接收窗口按向前移动分组的编号依次向上交付这些分组。举例子来说，考虑一下图 3-26。当收到一个序号为 rcv_base = 2 的分组时，该分组及分组 3、4 、5 可一起交付给上层。 序号在 [rev_base - N, rev_base - 1] 内的分组被正确收到。在此情况下，必须产生一个 ACK，即使该分组是接收方以前已确认过的分组。 其它情况。忽略该分组。 图 3-26 SR 操作 SR 窗口不一致的问题 注意到 SR receiver 中的第二步很重要，接收方重新确认(而不是忽略)已收到过的那些序号小于当前窗口基序号的分组。你应该理解这种重新确认确实是需要的。例如，给定在图 3-23 中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK 没有从接收方传播回发送方，则发送方最终将重传分组 send_base，即使接收方已经收到了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动！这个例子说明了 SR 协议的一个重要方面。对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果。对 SR 协议而言，这就意味着发送方和接收方的窗口并不总是一致。 当我们面对有限序号范围的情况时，发送方和接收方窗口间缺乏同步会产生严重的后果。考虑下面例子中可能发生的情况，例子中有包括 4 个分组序号 0、1、2、3 的有限序号范围且窗口长度为 3。假定发送了分组 0 至 2，并在接收方被正确接收且确认了。此时，接收方窗口落在第 4、5、6 个分组上，其序号分别为 3、0、1。现在考虑两种情况: 在第一种情况下，如图 3-27a 所示，对前 3 个分组的 ACK 丢失，因此发送方重传这些分组。因此，接收方下一步要接收序号为 0 的分组，即第一个发送分组的副本。 在第二种情况下，如图 3-27b 所示，对前 3 个分组的 ACK 都被正确交付。因此发送方向前移动窗口并发送第 4、5、6 个分组，其序号分别为 3、0、1。序号为 3 的分组丢失，但序号为 0 的分组到达(一个包含新数据的分组)。 图 3-27 SR 接收方窗口太大的困境：是一个新分组还是一次重传 现在考虑一下图 3-27 中接收方的观点，在发送方和接收方之间有一副假想的帘子，因为接收方不能『看见』发送方采取的动作。接收方所能观察到的是它从信道中收到的以及它向信道中发出报文序列。就其所关注的而言，图 3-27 中的两种情况是等同的。没有办法区分是第 1 个分组的重传还是第 5 个分组的初次传输。显然，窗口长度比序号空间小 1 时协议无法工作。 但窗口必须多小呢？窗口长度比须小于或等于序号空间大小的一半。 总结可靠数据传输机制及其用途 机制 用途和说明 校验和 用于检测在一个传输分组中的比特错误 定时器 用于超时/重传一个分组，可能因为该分组(或其 ACK)在信道中丢失了。由于当一个分组延时但未丢失(过早超时)，或当一个分组已被接收方收到但从接收方到发送方的 ACK 丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本 序号 用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本 肯定确认 接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议 否定确认 接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号 窗口、流水线 发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。 信道重排序分组的问题 我们通过考虑在底层信道模型中的一个遗留假设来结束对可靠数据传输协议的讨论。前面讲过，我们曾假定分组在发送方与接收方之间的信道中没有被重新排序。这在发送方与接收方由单段物理线路相连的情况下，通常是一个合理的假设。 然而，当连接两端的『信道』是一个网络时，分组重新排序是可能会发生的。分组重新排序的一个表现就是，一个具有序号或确认号 x 的分组的旧副本可能会出现，即使发送方或接收方的窗口中都没有包含 x。对于分组重新排序，信道可被看成基本上是在缓存分组，并在将来任意时刻自然地释放出这些分组。由于序号可以被重新使用，那么必须小心，以免出现这样的冗余分组。 实际应用中采用的方法是，序号 x 能否被重新使用，需要发送方『确信』任何先前发送的序号为 x 的分组都不再在网络中为止。通过假定一个分组在网络中的『存活』时间不会超过某个固定最大时间量来做到这一点。在高速的 TCP 扩展中，最长的的分组寿命被假定为大约 3 分钟。 本文引自 《计算机网络:自定向下方法》 Markdown 中插入数学公式的方法 LATEX 数学公式基本语法 比特率]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可靠数据传输服务]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[我们知道，传输层有两个协议，分别是 UDP 和 TCP。其中 UDP 提供的是无连接的、不可靠的数据传输服务。而 TCP 则提供面向连接、带拥塞控制的可靠数据传输服务。今天，我们就来聊一聊该怎么实现可靠数据传输服务(reliable data transmission service)。 我们的目标先来看一张图。 图 3-8 可靠数据传输服务的模型与实现 名词解释: Application Layer 应用层 Transport Layer 传输层 Network Layer 网络层 Sending process 发送进程 Receiver process 接收进程 Reliable channel 可靠信道 Unreliable channel 不可靠信道 Data 数据 Packet 分组 rdt reliable data transfer 可靠数据传输 udt unreliable data transfer 不可靠数据传输 图 3-8 描述的是可靠数据传输框架的模型与实现。图中，为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由 0 变为 1，或者由 1 变为 0）或丢失，而且所有数据都是按照其发送顺序进行交付。这恰好就是 TCP 向调用它的因特网应用所提供的服务模型。 图 3-8b 说明了用于数据传输协议的接口。通过调用 rdt_send() 函数，可以调用数据传输协议的发送方。它将要发送的数据交付给位于接收方的较高层(这里 rdt 表示可靠数据传输协议，_send 指示 rdt 的发送端正在被调用)。在接收端，当分组从信道的接收端到达时，将调用 rdt_rcv()。当 rdt 协议想要向较高层交付数据时，将通过调用 deliver_data() 来完成。 怎么实现 我们现在一步步地研究一系列协议，它们一个比一个更为复杂，最后得到一个无错、可靠的数据传输协议。 rdt 1.0经完全可靠信道的可靠数据传输协议 有限状态机(finite-state-machine) 首先，我们考虑最简单的情况，即底层信道是完全可靠的。我们称该协议为 rdt1.0，该协议本身是简单的。图 3-9 显示了 rdt1.0 发送方和接收方的有限状态机(Finite-State-Machine, FSM)的定义。 图 3-9 rdt1.0 用于完全可靠信道的协议 图 3-9a 中的 FSM 定义了发送方的操作，图 3-9b 中的 FSM 定义了接收方的操作。注意到下列问题是重要的 发送方和接收方有各自的 FSM 。图 3-9 中发送方和接收方的 FSM 每个都只有一个状态。 FSM 描述图中的箭头指示了协议从一个状态变迁到另一个状态。（因为 图 3-9 中的每个 FSM 都只有一个状态，因此变迁必定是从一个状态返回到自身。） 引起变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有事件就发生了动作，我们将在横线下方或上方使用符号 𐌡，以明确地表示缺少动作或事件。 FSM 的初始状态用虚线表示。尽管图 3-9 中的 FSM 只有一个状态但马上我们就将看到多状态的 FSM，因此标识每个 FSM 的初始状态是非常重要的。 发送端 rdt 的发送端只通过 rdt_send(data) 事件接受来自较高层的数据，产生一个包含该数据的分组（经由 make_pkt(data) 动作），并将分组发送到信道中。 实际上，rdt_send(data) 事件是由较高层应用的过程调用产生的 （例如，rdt_send()）。 接收端 在接收端，rdt 通过 rdt_rcv(packet) 事件从底层信道接收一个分组，从分组中取出数据（经由 extract(packet, data) 动作），并将数据上传给较高层（通过 deliver_data(data) 动作）。实际上，rdt_rcv(packet) 事件是由较低层协议的过程调用产生的（例如，rdt_rcv())。 小结 在这个简单的协议中，一个 data 和一个 packet 在内容上没有任何差别。而且，所有分组是从发送方流向接收方。有了完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，因为不必担心出现差错！注意到我们也已经假定了接收方接收数据的速率能够与发送方发送数据的速率一样快。因此，接收方没有必要请求发送方慢一点！ rdt 2.0经具有比特差错信道的可靠数据传输协议 停等协议(stop-and-wait) 底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。我们眼下还将继续假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收。 在开始研究能通过这种信道进行可靠通信的协议之前，首先考虑一下人们会怎样处理这类情形。考虑一下你自己是怎样通过电话口述一条长消息的(如电话号码)。在通常情况下，报文接收者在听到、理解并记下每句话后可能会说『OK』。如果报文接收者听到一句含糊不清的话时，他可能要求你重复刚才那句话。这种口述报文协议使用了肯定确认(positive acknowledgement)『OK』与否定确认(negative acknowledgment) 『请重复一遍』。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求(Automatic Repeat reQuest, ARQ)协议。 基本上，ARQ 协议中需要包括下列三种功能来处理存在比特差错的情况 差错检测。首先，需要一种机制以使接收方检测到何时出现了比特差错。实现这个机制的技术要求有额外的比特（非原始数据中的比特）从发送方发送到接收方。这些比特将存在于 rdt2.0 数据分组的分组检验和字段当中。 接收方反馈。因为发送方和接收方通常在不同端系统上执行，可能相隔数千英里，发送方要了解接收方情况（这里为分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。在口述报文情况下回答的『肯定确认』(ACK)和『否定确认』(NAK)就是这种反馈的例子。类似地，我们的 rdt2.0 协议将从接收方向发送方回送 ACK 与 NAK 分组。理论上，这些分组只需要一个比特长，如用 0 表示 NAK，用 1 表示 ACK。 重传。接收方收到有差错的分组时，发送方将重传该分组。 图 3-10 说明了表示 rdt2.0 的 FSM，该数据传输协议采用了差错检测、肯定确认与否定确认。 图 3-10 rdt2.0 用于具有比特差错信道的协议 注意到下列事实很重要：当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据。这就是说，rdt_send() 事件不可能出现，仅当接收到 ACK 并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0 这样的协议被称为停等(stop-and-wait)协议。 ACK/NAK 受损 rdt2.0 协议看起来似乎可以运行了，但遗憾的是，它存在一个致命的缺陷。我们没有考虑到 ACK 或 NAK 分组受损的可能性！（在继续研究之前，你应该考虑怎样解决该问题。）遗憾的是，我们细小的疏忽并非像它看起来那么无关紧要。至少，我们需要在 ACK/NAK 分组中添加检验和比特以检测这样的差错。更难的问题是协议应该怎样纠正这样的差错。这里的难点在于，如果一个 ACK/NAK 分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据。 我们考虑处理受损 ACK 和 NAK 的 3 种可能情况: 第一种，在口述报文情况下人们通常的做法。如果说话者不理解来自接收方回答的『OK』或『请重复一遍』，说话者将可能问 『你说什么？』（这样就在我们的协议中引入了一种新的发送方到接收方的分组类型），接收方则将复述其回答。但是如果说话者的『你说什么？』产生了差错，情况又会怎样呢？由于接收者不明白那句混淆的话是口述内容的一部分还是一个要求重复上次回答的请求，很可能也回一句『你说什么？』。于是，越回答越乱。显然，我们走上了一条困难重重之路。 第二种，增加足够长度的检验和比特，使收到受损 ACK/NAK 的发送方不仅可以检测出差错，还可恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。 第三种，当发送方收到含糊不清的 ACK/NAK 分组时，只需重传当前数据分组即可。然而，这种方法在发送方到接收方的信道中引人了冗余分组(duplicate packet)。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK/NAK 是否被发送方正确地收到，这就导致它无法确认这一次接收到的分组是新的还是一次重传！ 解决这个新问题的一个简单方法（几乎所有现有的数据传输协议中，包括 TCP，都采用了这种方法）是在数据分组中添加一新字段，让发送方对其数据分组进行编号，将数据分组的序号(sequence number)放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否来自重传。对于停等协议这种简单情况，1 比特序号就足够了，因为它可让接收方知道发送方是否正在重传前一个发送分组（接收到的分组序号与最近收到的分组序号相同），或是一个新分组（序号变化了）。因为目前我们假定信道不丢失分组。ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。发送方知道所接收到的 ACK 和 NAK 分组（无论是否是含糊不清的）是为响应其最近发送的数据分组而生成的。 图 3-11 和图 3-12 给出了对 rdt2.1 的 FSM 描述，这是 rdt2.0 的修订版。rdt2.1 的发送方和接收方 FSM 的状态数都是以前的两倍。这是因为协议状态此时必须反映出目前（由发送方）正发送的分组或（在接收方）希望接收的分组的序号是 0 还是 1。值得注意的是，发送或期望接收 0 号分组的状态中的动作与发送或期望接收 1 号分组的状态中的动作是相似的；唯一的不同是序号处理的方法不同。 图 3-11 rdt2.1 发送方 图 3-12 rdt2.1 接收方 去掉 NAK 协议 rdt2.1 使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认。如果收到受损的分组，则接收方将发送一个否定确认。如果不发送 NAK，而是对上次正确接收的分组发送一个 ACK，我们也能实现与 NAK 一样的效果。发送方接收到对同一个分组的两个 ACK (即接收冗余 ACK (duplicate ACK))后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。rdt2.2 是在有比特差错信道上实现的一个无 NAK 的可靠数据传输协议，如图 3-13 和图 3-14 所示。rdt2.1 和 rdt2.2 之间的细微变化在于，接收方此时必须包括由一个 ACK 报文所确认的分组序号（这可以通过在接收方 FSM 中，在 make_pkt() 中包括参数 ACK 0 或 ACK 1 来实现），发送方此时必须检查接收到的 ACK 报文中被确认的分组序号（这可通过在发送方 FSM 中， 在 isACK() 中包括参数 0 或 1 来实现）。 图 3-13 rdt2.2 发送方 图 3-14 rdt2.2 接收方 rdt 3.0经具有比特差错的丢包信道的可靠数据传输协议 丢包检测和恢复 现在假定除了比特受损外，底层信道还会丢包，这在今天的计算机网络（包括因特网）中很常见。协议现在必须解决另外两个关注的问题：怎样检测丢包以及发生丢包后该做些什么。在 rdt2.2 中已经研发的技术，如使用检验和、序号、ACK 分组和重传等，使我们能给出后一个问题的答案。为解决第一个的问题，还需增加一种新的协议机制。 有很多可能的方法用于解决丢包问题，在这里，我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的 ACK 发生了丢失。在这两种情况下，发送方都收不到来自接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已经丢失，则它只需重传该数据分组即可。 但是发送方需要等待多久才能确定已丢失了某些东西呢？很明显发送方至少需要等待这样长的时间：即发送方与接收方之间的一个往返时延（可能会包括在中间路由器的缓冲时延）加上接收方处理一个分组所需的时间。在很多网络中，最坏情况下的最大时延是很难估算的，确定的因素非常少。此外，理想的协议应该能尽快地从丢包中恢复出来。等待一个最坏情况的时延可能意味着要等待一段较长的时间，直到启动差错恢复为止。因此实践中采取的方法是发送方『明智』地选择一个时间值，以判定可能发生了丢包（尽管不能确保）。如果在这个时间内没有收到 ACK，则重传该分组(注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其 ACK 都没有丢失)。这就在发送方到接收方的信道中引入了冗余数据分组(duplicate data packet)的可能性。幸运的是，rdt2.2 协议已经有足够的功能（即序号）来处理冗余分组的情况。 定时重传 从发送方的观点来看，重传是一种万能灵药(重启也是!)。发送方不知道是一个数据分组丢失，还是一个 ACK 丢失，或者只是该分组或 ACK 过度延时。在所有这些情况下，动作是同样的：重传。为了实现基于时间的重传机制，需要一个倒计时器(countdown timer)，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到: 每次发送一个分组(包括新分组和重传分组)时，便启动一个定时器 响应定时器中断(采取适当的动作) 终止定时器 图 3-15 给出了 rdt3.0 的发送方 FSM，这是一个在可能出错和丢包的信道上可靠传输数据的协议。 图 3-15 rdt3.0 发送方 rdt3.0 接收方因为它和 rdt2.2 一样，没有 ACK 和 NCK 的区别，而且传输的数据分组也标了序号(0 和 1)，所以它不受超时重传的影响。因此 rtd3.0 和 rtd2.2 的接受方是一样的 FSM 图。 图 3-16 rdt3.0 接收方 现在我们归纳一下数据传输协议的要点。在检验和、序号、定时器、肯定和否定确认分组这些技术中，每种机制都在协议的运行中起到了必不可少的作用。至此，我们得到了一个可靠的数据传输协议！ rdt3.0 的性能问题rdt3.0 是一个功能正确的协议，但并非人人都对它的性能满意，特别是在今天的高速网络中更是如此。rdt3.0 性能问题的核心在于它是一个停等协议！ 预知后事如何，且听 下回分解。 本文引自 《计算机网络:自定向下方法》]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[钉钉自定义机器人的一种用法]]></title>
    <url>%2F2018%2F03%2F11%2F%E9%92%89%E9%92%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E4%B8%80%E7%A7%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[文章的主要内容是介绍怎么利用钉钉的自定义机器人来自动通知技术部的今日分享。目的是想给大家提供一种『利用钉钉的「自定义机器人」实现「定时」通知「固定格式消息」的实现思路』。 需求来源背景 公司使用钉钉作为聊天软件 钉钉存在对外开放的接口，例如『自定义机器人』 技术部一直有分享的氛围 起因 有分享者自然也要有听众，这样分享者才有动力。那么分享者采用什么方式通知到听众今天要分享的内容呢？目前我们都是提前把分享内容告知给郭大侠，然后由郭大侠统一在分享开始之前，『手动』在技术部的钉钉群里通知即将要分享的相关内容。但这样做存在两个问题: 当你提前告知郭大侠分享内容之后，必须再一次通知郭大侠才能修改之前定的分享日期，不能实现自主修改 郭大侠有时候会忘记在群里发通知 由于通过『郭大侠手动通知分享内容』的现行方式存在以上两个问题，于是就有了想写一个程序来实现自动通知分享内容的想法。Let’s do it. 实现思路 先写一个 python 脚本。将公司内部专门用来记录分享内容的 wiki 页面 爬下来，然后进行解析，得到分享内容。然后利用钉钉提供的 自定义机器人 将分享内容通知到技术部聊天群 再写一个定时任务。用来每天定时跑上面写好的 python 脚本 先写一个 python 脚本 工欲善其事，必先利其器。 下面介绍几个能节省几周工作时间的 python 类库。 BeautifulSoup Beautiful Soup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能够通过你喜欢的转换器实现惯用的文档导航、查找、修改文档的方式。Beautiful Soup 会帮你节省数小时甚至数天的工作时间。 Requests Requests is the only Non-GMO HTTP library for Python, safe for human consumption. 代码注意，代码采用 python3 实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/env python3import re #正则包 import requests #封装了 http 请求的包from bs4 import BeautifulSoup #html 解析包from datetime import datetime #时间包#1. 将 wiki 上记录分享的网页下载下来，并进行解析#注意点 1: 这里需要换成你自己想要解析的相应网页的 url(更换的网页地址之后记得重新定义网页的解析规则，即第 2、3、4 步的代码)doc_url='你要解析的网页 url'html_doc = requests.get(doc_url)soup = BeautifulSoup(html_doc.content, 'html.parser')#2. 利用正则找出所有的分享日期，并判断今日有无分享date_list=soup.find_all(string=re.compile("分享日期"))today = datetime.now().strftime("%Y-%m-%d")#这里需要初始化一个不存在的分享日期，例如 1995-02-14#todo 这里有一个 bug，就是如果同一天有多个分享，只会查出排在前面的那条记录。2018-03-11 21:16next_share_date='1995-02-14'for ele in date_list: ele=ele[5:] if ele==today: next_share_date=ele break#3. 利用 BeautifulSoup 找出所有的分享内容share_record=soup.find_all(string=re.compile("分享日期\s.*|分享时长\s.*|分享地点\s.*|分享简介\s.*|分享范围\s.*|分享人\s.*|《.*》"))#4. 因为分享记录的格式固定，所以从分享日期开始往后的 7 个元素就包括了一次分享的所有记录next_share_content=[]for index in range(len(share_record)): if next_share_date in share_record[index]: for i in range(7): next_share_content.append(share_record[index]) index+=1 else: continue#5. if 今日无分享，do nothing；else 通过钉钉的自定义机器人推送消息if next_share_content == []: print('next_share_content is null')else: print('next_share_content ',next_share_content) date='' time='' place='' title='' summary='' scope='' author='' href='' for index in range(len(next_share_content)): if '分享日期' in next_share_content[index]: date=next_share_content[index] if '分享时长' in next_share_content[index]: time=next_share_content[index] if '分享地点' in next_share_content[index]: place=next_share_content[index] if '《' in next_share_content[index]: title=next_share_content[index] #将 '分享主题' 四个字替换成 '' 空串,这样就能去除重复的 '分享主题'四个字。 p = re.compile('分享主题') title=p.sub('',title) #取出分享主题的链接 href_list=soup.find_all('a') for i in range(len(href_list)): if title in href_list[i]: href=href_list[i].get('href') break if '分享简介' in next_share_content[index]: summary=next_share_content[index] if '分享范围' in next_share_content[index]: scope=next_share_content[index] if '分享人' in next_share_content[index]: author=next_share_content[index] #如果分享主题没有链接，则正常发主题；否则，把链接也加上。 if href=='': str_list=['&#123;"msgtype":"markdown","markdown":&#123;"title":"今日分享","text":"### **分享主题** **',title,'** \n','###### **',summary[2:],'** \n','##### **',date[2:],'** \n','##### **',time[2:],'** \n','##### **',place[2:],'** \n','##### **',scope[2:],'** \n','##### ',author,' "','&#125;',',"at":&#123;"atMobiles":[],"isAtAll":true&#125;','&#125;'] else: str_list=['&#123;"msgtype":"markdown","markdown":&#123;"title":"今日分享","text":"### **分享主题** [',title,'](',href,')', '\n','###### **',summary[2:],'** \n','##### **',date[2:],'** \n','##### **',time[2:],'** \n','##### **',place[2:],'** \n','##### **',scope[2:],'** \n','##### ',author,' "','&#125;',',"at":&#123;"atMobiles":[],"isAtAll":true&#125;','&#125;'] message=''.join(str_list) print('message', message) #注意点 2:dingding_url 需要替换成你自己钉钉机器人的 webhook 地址 dingding_url='webhook 地址' headers=&#123;"Content-Type": "application/json"&#125; r = requests.post(dingding_url, data=message.encode('utf-8'), headers=headers) 复用上面这段代码需要注意两点(即注释中标明的两点): doc_url 需要替换成自己要解析的网页地址 dingding_url 需要替换成自己的钉钉机器人的 webhook 地址 再写一个定时任务linux 机器有一个 crontab 命令，这个是 linux 系统提供的实现自定义系统计划的命令。 编辑系统计划crontab -e 查看系统计划crontab -l 自定义一个系统计划crontab 格式说明 crontab 命令示例40 8 * * * /home/hufei/parse-all.py &gt;&gt; /home/hufei/out-all.file 2&gt;&amp;1 40 8 * * * 每天的 8 点 40 分 &gt; 表示覆盖 &gt;&gt; 表示追加 1 表示 stdout 标准输出，系统默认值是 1 2 表示 stderr 标准错误 &amp; 表示等同于的意思 2&gt;&amp;1 表示 2 的输出重定向等同于 1 实现效果分享内容的格式 钉钉通知消息的格式 本文引自 钉钉自定义机器人 Requests BeautifulSoup python 入门教程 每天一个 linux 命令：crontab 命令 linux 往文件末追加行]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>钉钉</tag>
        <tag>dingtalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS]]></title>
    <url>%2F2018%2F03%2F03%2FDNS%2F</url>
    <content type="text"><![CDATA[我们知道，身份证号可以唯一标识一个人。但我们在相互介绍时通常不会使用身份证号，而是报上姓名。因特网上的主机也和人类一样，有一个可以唯一标识的 IP(由 32 位二进制数表示)地址，同时，它们也有一个主机名(hostname)，如 www.google.com www.wikipedia.org gaia.cs.umass.edu 等。因为人们喜欢的是便于于记忆的『主机名标识』方式，所以我们需要一种能将主机名转换到 IP 地址的 目录服务。这就是域名系统(Domain Name System，DNS)。 什么是 DNS概念 一个由分层的 DNS 服务器(DNS server)实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 DNS 服务器通常是运行 BIND(Berkeley Internet Name Domain)软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用的端口号为 53。 使用场景DNS 通常是由其它应用层协议所使用的，包括 HTTP、SMTP 和 FTP，将用户提供的主机名解析为 IP 地址。举个栗子，考虑当某个用户主机上的一个浏览器(即一个 HTTP 客户端)请求 URL www.huminxi.com/index.html 页面时会发生什么动作。为了使用户的主机能够将一个 HTTP 请求报文发送到 Web 服务器 www.huminxi.com 该用户主机必须获得 www.huminxi.com 的 IP 地址。其做法如下 同一台用户主机上运行着 DNS 应用的客户端 浏览器从上述 URL 中抽取出主机名 www.huminxi.com 并将这台主机名传给 DNS 应用的客户端 DNS 客户端向 DNS 服务器发送一个包含主机名的请求 DNS 客户端最终会收到一份回答报文，其中包含有对应于该主机名的 IP 地址 一旦浏览器接收到来自 DNS 的该 IP 地址，它能够向位于该 IP 地址 80 端口的 HTTP 服务器进程发起一个 TCP 连接 从这个例子中，我们可以看到 DNS 给使用它的因特网带来了额外的时延，而且有时候还不低。除了进行主机名到 IP 地址的转换之外，DNS 还提供了一些重要的服务 主机别名(host aliasing) 有着复杂主机名的主机能拥有一个或多个别名。例如，一台名为 relay1.west-coast.enterprise.com 的主机，可能还有两个别名为 enterprise.com 和 www.enterprise.com。 在这种情况下 relay1.west-coast.enterprise.com 也称为规范主机名(canonical hostname)。主机别名比主机规范名更加容易记忆。应用程序可以调用 DNS 来获的主机别名对应的规范主机名以及主机的 IP 地址。 邮件服务器别名(mail server aliasing) 显而易见，人们也希望电子邮件地址好记忆。例如，如果 Hufei 在 Gmail 上有一个账户，Hufei 的邮件地址就像 hufei@gmail.com 这样简单。然而，Gmail 邮件服务器的规范主机名可能十分复杂，不像 gmail.com 那样简单好记(注：电子邮箱地址格式为 user@server，所以地址 hufei@gmail.com 中 @ 字符后面的 gmail.com 表示的就是邮件服务器的别名)。电子邮件应用程序可以调用 DNS，对提供的邮件服务器别名进行解析，以获得该主机的规范主机名及其 IP 地址。事实上，MX 记录允许一个公司的邮件服务器和 Web 服务器使用相同的主机别名。例如，一个公司的 Web 服务器和邮件服务器都能叫做 enterprise.com。 负载分配(load distribution) DNS 也用与在冗余的服务器(如冗余的 Web 服务器)之间进行负载分配。繁忙的站点(如 cnn.com)被冗余分布在多台服务器上，每台服务器运行在不同的端系统上，每个都有着不同的 IP 地址。由于这些冗余的 Web 服务器，一个 IP 地址集合因此与一个规范主机名相关联。DNS 数据库中存储着这些 IP 地址集合。当客户对映射到某地址集合的主机名发出一个 DNS 请求时，该 DNS 服务器会用 IP 地址的整个集合进行相应，但在每个回答中循环这些地址的次序。因为客户通常是向排在最前面的 IP 地址服务器发送 HTTP 请求报文，所以 DNS 就在所有这些冗余的 Web 服务器之间循环分配了负载。DNS 同样可用于邮件服务器的负载分配。 DNS 解析代码验证123456789101112131415161718192021222324252627282930313233343536373839#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; char *ptr, **pptr; struct hostent *hptr; char str[32]; ptr = argv[1]; if((hptr = gethostbyname(ptr)) == NULL) &#123; printf(" gethostbyname error for host:%s\n", ptr); return 0; &#125; printf("official hostname:%s\n",hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf(" alias:%s\n",*pptr); switch(hptr-&gt;h_addrtype) &#123; case AF_INET: case AF_INET6: pptr=hptr-&gt;h_addr_list; for(; *pptr!=NULL; pptr++) printf(" address:%s\n", inet_ntop(hptr-&gt;h_addrtype, *pptr, str, sizeof(str))); printf(" first address: %s\n", inet_ntop(hptr-&gt;h_addrtype, hptr-&gt;h_addr, str, sizeof(str))); break; default: printf("unknown address type\n"); break; &#125; return 0;&#125; DNS 的原理DNS 工作过程概述假设运行在用户主机上的某些应用程序需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户端，并指明需要转换的主机名。用户主机上的 DNS 接受到后，向网络中发送一个 DNS 查询报文。所有的 DNS 请求和回答报文使用 UDP 数据报经端口 53 发送。经过若干毫秒的时延后，用户主机上的 DNS 接受到一个提供映射结果的 DNS 回答报文。这个映射结果被传递到调用 DNS 的应用程序。 因此，从调用 DNS 服务的应用程序角度看，DNS 是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。 DNS 的实现方式集中式DNS 的一种简单实现是在因特网上只使用一个 DNS 服务器，该服务器包含所有的映射。在这种集中式设计中，客户直接将所有查询发往单一的 DNS 服务器，同时该 DNS 服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力，但它不适用与当今的因特网，因为因特网有着数量巨大(并且持续增长)的主机。这种集中式设计的问题包括 单点故障(a single point of failure) 如果该 DNS 服务器崩溃，整个因特网随之瘫痪！ 通信容量(traffic volume) 单个 DNS 服务器不得不处理所有的 DNS 查询(用于上亿台主机产生的 HTTP 请求报文和电子邮件报文服务)。 远距离的集中式数据库(distant centralized database) 单个 DNS 服务器不可能『临近』所有查询客户。如果我们将单台 DNS 服务器放在纽约市，那么所有来自澳大利亚的查询必须传播到地球的另一边，中间也许还要经过低速和拥塞的链路，这将导致严重的时延。 维护(maintenance) 单个 DNS 服务器将不得不为所有的因特网主机保留记录。这不仅将使这个中央数据库非常庞大，而且它还为每个新添加的主机而频繁更新。 总的来说，在单一 DNS 服务器上运行集中式数据库完全没有可扩展能力。因此，DNS 采用了分布式的设计方案。事实上，DNS 是一个在因特网上实现分布式数据库的优秀示例。 分布式层次结构为了处理扩展性问题，DNS 使用了大量的 DNS 服务器，它们以层次方式组织，并且分布在全世界范围内。大致来说，有 3 种类型的 DNS 服务器：根服务器、顶级域(Top-Level Domain，TLD) DNS 服务器和权威 DNS 服务器。这些服务器以下图所示的层次结构组织起来。 DNS 服务器的层次结构 为了理解这 3 种类型的 DNS 服务器交互的方式，我们来举个栗子。假定一个 DNS 客户要查询主机名为 www.amazon.com 的 IP 地址。客户首先与根服务器之一联系，它将返回顶级域名 com 的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一联系，它将为 amazon.com 返回权威服务器的 IP 地址。最后，客户与 amazon.com 权威服务器之一联系，它为主机名 www.amazon.com 返回其 IP 地址。 各种类型的 DNS 服务器介绍 根 DNS 服务器 在因特网上有 13 个根 DNS 服务器(标号为 a-m，主机名格式为 字母.root-servers.net)。13 个根域名服务器 IP 列表 顶级域 DNS 服务器 这些服务器负责顶级域名如 com org net edu 和 gov，以及所有国家的顶级域名如 uk fr jp 和 cn。所有顶级域列表 权威 DNS 服务器 在因特网上具有公共可访问主机(如 Web 服务器和邮件服务器)的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构能够选择实现它自己的权威 DNS 服务器以保持这些记录；或者该组织能够支付费用，让这些记录存储在某个服务提供商(如阿里)的一个权威 DNS 服务器中。多数大学和大公司实现和维护他们自己的权威 DNS 服务器。 验证根 DNS 服务器的 IP 地址 本地 DNS 服务器根、TLD 和权威 DNS 服务器都处在上述 DNS 服务器的层次结构中。还有另一类重要的 DNS，称为本地 DNS 服务器(local DNS server)。一个本地 DNS 服务器严格来说并不属于 DNS 服务器的层次结构，但它对 DNS 层次结构是重要的。每个 ISP(如一个大学、一个系、一个公司或一个居民区的 ISP)都有一台本地 DNS 服务器(也叫默认 DNS 服务器)。 mac 上使用 cat /etc/resolv.conf 命令查看默认的 DNS 服务器地址 一般来说，主机的本地 DNS 服务器通常『临近』本主机。对于某机构 IPS 而言，本地 DNS 服务器可能就与主机在同一个局域网中；对于某居民区 ISP 来说，本地 DNS 服务器通常与主机相隔不超过几台路由器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求发送到 DNS 服务器层次结构中。怎么理解这段话，我们来看一个简单的栗子。 假设主机 cis.poly.edu 想知道 gaia.cs.umass.edu 的 IP 地址。同时假设主机 cis.poly.edu 的本地 DNS 服务器为 dns.poly.edu，并且 gaia.cs.umass.edu 的权威 DNS 服务器为 dns.umass.edu。 图 2-21 各种 DNS 服务器的交互 如图 2-21 所示，主机 cis.poly.edu 首先向它的本地 DNS 服务器 dns.poly.edu 发送一个 DNS 查询报文。该查询报文中含有被转换的主机名 gaia.cs.umass.edu。本地 DNS 服务器将该报文转发到根 DNS 服务器。该根 DNS 服务器注意到其 edu 前缀并向本地 DNS 服务器返回负责 edu 的 TLD 的 IP 地址列表。该本地 DNS 服务器则再次向这些 TLD 服务器之一发送查询报文。该 TLD 服务器注意到 umass.edu 前缀，并用权威 DNS 服务器的 IP 地址进行响应。最后，本地 DNS 服务器直接向 dns.emass.edu 重发查询报文， dns.umass.eud 用 gaia.cs.umass.edu 的 IP 地址进行响应(注意：在本例中，为了获得一台主机名的映射，共发送了 8 份 DNS 报文：4 份查询报文和 4 份回答报文)。 上面的例子中假设了 TLD 服务器知道用于主机的权威 DNS 服务器的 IP 地址。一般而言，这种假设并不正确。相反，TLD 服务器只是知道中间的某个 DNS 服务器，该中间的 DNS 服务器依次才能知道用于该主机的权威 DNS 服务器。所以正常情况下，我们将发生不止 8 份的 DNS 报文！ 图 2-21 所示的例子利用了递归查询(recursive query)和迭代查询(iterative query)。从 cis.poly.edu 到 dns.poly.edu 发出的查询时递归查询，而后继的 3 个查询是迭代查询。从理论上讲，任何 DNS 查询既可以是迭代的也可能是递归的。例如，下图 2-22 显示了一条 DNS 查询链，其中的所有查询都是递归的。实际中，一般都是遵循图 2-21 中的模式。从请求主机到本地 DNS 服务器的查询时递归的，其余的查询时迭代的。 图 2-22 DNS 中的递归查询 DNS 缓存在图 2-21 的例子中，我们注意到：为了获得一台主机名的映射，我们共发送了 8 份报文，效率实在太低!实际上，为了改善时延性能并减少因特网上到处传输的 DNS 报文数量， DNS 技术广泛使用了缓存技术。 DNS 缓存的原理非常简单。在一个请求链中，当某 DNS 服务器接收到一个 DNS 回答(例如，包含主机名到 IP 地址的映射)时，它能将该回答中的信息缓存在自己的存储器中。这样下次再有相同的 DNS 请求时，可以直接将缓存的内容作为 DNS 回答发送过去，即使它不是该主机名的权威服务器。由于主机和主机名与 IP 地址间的映射并不是永久的，DNS 服务器在一段时间后(通常设置为两天)将丢去缓存的信息。这也是本地 DNS 服务器为什么如此重要的原因。 DNS 记录实现 DNS 分布式数据库的所有 DNS 服务器存储了资源记录(Resource Record，RR)，RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。资源记录是一个包含了下列字段的 4 元组:[Name, Value, Type, TTL]TTL 是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name 和 Value 的值取决于 Type: Type = A，则 Name 是个主机名，Value 是该主机名对应的 IP 地址。因此，一条类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射。例如(relay1.bar.foo.com, 145.37.93.126, A)就是一条类型 A 记录。 Type = NS，则 Name 是个域(如 foo.com)，而 Value 是个知道如何获得该域中主机 IP 的权威 DNS 服务器的主机名。这个记录用于沿着查询链来路由 DNS 查询。例如(foo.com, dns.foo.com, NS)就是一条类型为 NS 的记录。 Type = CNAME，则 Value 是别名为 Name 的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名。例如(foo.com, relay1.bar.foo.com, CNAME)就是一条 CNAME 类型的记录。 Type = MX，则 Value 是个别名为 Name 的邮件服务器的规范主机名。例如(foo.com, mail.bar.foo.com, MX)就是一条 MX 记录。 DNS 记录 现在，大家应该对 DNS 这三个字不陌生了吧。 本文引自 《计算机网络:自定向下方法》 根域名服务器 gethostbyname() 函数说明]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我眼中的互联网]]></title>
    <url>%2F2018%2F02%2F17%2F%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[我们每天都在使用的互联网，你是否好奇，它是如何实现的？全世界接入互联网的终端设备有几十亿台，为什么你的电脑能从中准确的找到小伙伴的电脑，然后相互进行通信？如果让你从零开始设计能使全球的终端设备互联互通的计算机网络，你会怎么实现？ 什么是互联网我们先来看一张图 互联网的组成 名词解释: Mobile Network 移动网络 National or Global ISP 国家或全球 ISP ISP Internet Service Provider 互联网服务供应商 Home Network 家庭网络 Local or Regional ISP 本地或区域 ISP Enterprise Network 公司网络 Host 主机 end system 端系统 Server 服务器 Mobile 移动设备 Router 路由器 Link-Layer switch 链路层交换机 Modem 调制解调器 Base station 基站 Smart phone 智能手机 Cell phone tower 蜂窝电话塔 互联网是指由若干个电子计算机网络相互连接而成的更大的网络，即网络的网络。 互联网的结构概述 互联网分为多层，每一层都有自己的功能。上层与下层之间的关系就像建筑物一样，上层需要来自下层的支持。 为了统一某一层的功能，大家在具体实现这一层的时候就需要遵守共同的规则，或者叫『协议』(protocol)。 越下面的层，越靠近硬件；越上面的层，越靠近用户。 网络分层 Physical Layer搭建一个网络，第一件事要干什么？ 当然是先把电脑们连接起来，可以用光缆、电缆、双绞线、无线电波等方式。 连接电脑 光缆 电缆 双绞线 无线电波 这就叫做『实体层』，它是把电脑连接起来的物理手段，主要作用是负责传送 0 和 1 的电信号。 Link Layer有了『实体层』，现在我们已经能互相传递 0 和 1 了。假设： 你传 0101010101010010101010101010010101010101001101010100110100100101001 给我，我回 1001000010101010101000010100011111110001010101010010101010101001010 给你。 但是，这一连串的 0 和 1 该怎么解读呢，是不是看的一脸懵逼？ 这是因为我们还缺一个将 0 和 1 分组的方式。 Frame早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做『以太网』(Ethernet)的协议，占据了主导地位。以太网规定，一组电信号构成的一个数据包，叫做『帧』(Frame)。每一帧分成两个部分：Head 和 Data。 Frame IEEE 802.3以太网帧结构 名词解释: Octet 八位元组 （像 11110000 就是一个 octet） Preamble 序文 (由 7 个 10101010 和 1 个 10101011 组成) SFD Start Frame Delimiter 帧首定界符 (1 个 octet 10101011) Destination MAC 目的 MAC 地址 MAC Media Access Control Address 以太网地址 Source MAC 源 MAC 地址 802.1Q Header 可选字段 EtherType 以太类型 Payload 有效载荷 (42-1500 个 octet) CRC Cyclic Redundancy Check 循环冗余校验 FCS Frame Check Sequence 帧检查序列 Inter Frame Gap 帧间间隔 MAC1990 年代的以太网网卡或叫 NIC（Network Interface Card，以太网适配器）。这张卡可以支持基于同轴电缆的 10BASE2 (BNC 连接器，左)和基于双绞线的 10BASE-T（RJ-45，右）。 以太网网卡 每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。前 6 位由 IEEE 决定如何分配，后 6 位由实际生产该网络设备的厂商自行指定。 MAC 地址 mac 上可以用 ifconfig 命令查看 MAC 地址 MAC 地址现在已经定义好了。 那么下一个问题来了：一块网卡怎么会知道另一块网卡的 MAC 地址？其实，在每台安装有 TCP/IP 协议的电脑或路由器里都有一个 ARP 缓存表，表里的 IP 地址与 MAC 地址是一一对应的。如下表所示： 主机名称 IP 地址 MAC 地址 A 192.168.38.10 00-AA-00-62-D2-02 B 192.168.38.11 00-BB-00-62-C2-02 C 192.168.38.12 00-CC-00-62-C2-02 … … … 以主机 A（192.168.38.10）向主机 B（192.168.38.11）发送数据为例。 当发送数据时，主机 A 会在自己的 ARP 缓存表中寻找是否有目标 IP 地址。 如果有，直接把目标 MAC 地址写入帧里面发送就行。 如果没有，主机 A 就会在网络上发送一个广播（ARP request）。 目标 MAC 地址是『FF.FF.FF.FF.FF.FF』，这表示向同一网段内的所有主机发出这样的询问：『192.168.38.11 的 MAC 地址是什么？』 网络上其他主机并不响应 ARP 询问，只有目标主机 B 接收到这个帧时，才向主机 A 做出这样的回应（ARP response）：『192.168.38.11 的 MAC 地址是 00-BB-00-62-C2-02』。 这样，主机 A 就知道主机 B 的 MAC 地址，它就可以向主机 B 发送信息。同时它还更新自己的 ARP 缓存表，下次再向主机 B 发送信息时，直接从 ARP 缓存表里查找就可。ARP 缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少 ARP 缓存表的长度，加快查询速度。 这就是『ARP协议』原理的简单描述。 mac 上可以用 arp -a 命令查看 ARP 缓存表 这就是『链接层』的功能，它在『实体层』的上方，确定了 0 和 1 的分组方式，它的数据包被称为 Frame。 Network Layer有了以太网协议，我们依靠 MAC 地址来发送数据。理论上，全世界的电脑互联互通已经可以实现了。还有什么不足吗？ 有的，这样做有一个重大的缺陷：如果两台计算机不在同一个子网络，广播是传不过去的！ 那为什么不设计一个超级大的子网络呢？因为以太网采用广播方式查询未知计算机的 MAC 地址，所有成员人手一帧。就算可以设计一个超级子网，那么互联网上每一台计算机都收到所有帧，这将会是一个灾难。 因此，必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络。如果是同一个子网络，就采用广播方式发送，否则就采用『路由』方式发送。（这里的『路由』指的是如何向不同的子网络分发数据包）遗憾的是，MAC 地址本身无法做到这一点——它只与厂商有关，与所处网络无关。 这就导致了『网络层』的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做『网络地址』，简称『网址』。 IP规定网络地址的协议，叫做 IP 协议。它所定义的地址，就被称为 IP 地址。目前，广泛采用的是 IP 协议第四版，简称 IPv4。这个版本规定，网络地址由 32 个二进制位组成。 IP 地址 习惯上，我们用分成四段的十进制数表示 IP 地址，从 0.0.0.0 一直到 255.255.255.255(一些特殊的 IP 地址)。互联网上的每一台计算机，都会分配到一个 IP 地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP 地址 172.16.254.1，这是一个 32 位的地址，假定它的网络部分是前 24 位（172.16.254），那么主机部分就是后 8 位（上图的 IP 地址的主机就是最后的那个 1）。 Subnet Mask那么问题来了：怎样才能从 IP 地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数『子网掩码』（subnet mask）。 所谓『子网掩码』，就是表示子网络的一个参数。它在形式上和 IP 地址类似。但它有个显著的特点（记下来，要考） 『它的网络部分全部为 1，主机部分全部为 0!』 比如，IP 地址 172.16.254.1，如果已知网络部分是前 24 位，主机部分是后 8 位，那么『子网掩码』就是 11111111.11111111.11111111.00000000，写成十进制就是 255.255.255.0。知道了『子网掩码』，我们就能判断，任意两个 IP 地址是否处在同一个子网络。方法是将两个 IP 地址与『子网掩码』分别按位进行 AND 运算（两个数都为 1，则运算结果为 1，否则为 0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 Q 已知 IP 地址 172.16.192.1 和 172.16.254.233 的子网掩码都是 255.255.192.0，请问它们是否在同一个子网络？ A 将两者分别与子网掩码进行 AND 运算，结果都是 172.16.192.0，因此它们在同一个子网络中。 DatagramIP 数据包也分为 Head 和 Data 两个部分。Head 部分主要包括协议版本、数据包长度、IP 地址等信息，Data 部分则是 IP 数据包的具体内容。 IP 数据包中一定包含了 IP 地址。但是前面说过，以太网数据包的 Head 里面只包含 MAC 地址，并没有 IP 地址的栏位。那么是否需要修改以太网数据包的 Head 定义，再添加一个栏位来存放 IP 地址信息呢？ 回答是不需要，我们可以把 IP 数据包直接放进以太网数据包的 Data 部分，因此完全不用修改以太网数据包的定义。这就是互联网分层结构的好处：『上层的变动完全不涉及下层的结构』。它放进以太网数据包后，以太网数据包就变成了下面这样。 Datagram IP 数据包的 Head 部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65535 字节。因此，理论上，一个 IP 数据包(Datagram) 的 Data 部分，最长为 65515 字节。前面说过，以太网数据包(Frame)的 Payload 部分，最长只有 1500 字节。因此，如果一个 IP 数据包超过了 1500 字节，它就需要分割成几个以太网数据包，分开发送了。 『网络层』在『链接层』的上层。它的作用主要有两个，一个是为每一台计算机分配一个网络地址；另一个是确定哪些网络地址在同一个子网络。它的数据包被称为 Datagram。 Transport Layer有了 MAC 地址和 IP 地址的情况下，我们已经可以在互联网上任意两台主机上建立通信。为什么还要传输层呢？ 这是因为在同一台主机上将会有许多程序都需要用到网络。比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，计算机怎么知道，它是表示网页的内容，还是表示在线聊天的内容？也就是说，我们还需要一个参数, 来表示这个数据包到底供哪个程序（进程）使用。 Port这个参数就叫做『端口』(port)，由 16 位二进制表示（0-65535），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 0-1023 号端口被称为 知名端口（well-known port）。这些知名端口号由 IANA 分配。用户只能选用 1024-65535 之间的一个端口号。不管是浏览网页还是在线聊天，应用程序随机选用一个端口，然后与服务器的相应端口联系。 UDP现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做 UDP(User Datagram Protocol) 协议，它的格式几乎就是在数据前面加上端口号。 UDP 数据包，也是由 Head 和 Data 两部分组成。Head 部分定义了发出端口和接收端口，Data 部分就是具体的内容。 整个 UDP 数据包放入 IP 数据包的 Data 部分，而前面说过，IP 数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： Segment UDP 数据包最长可为多少字节？ UDP 数据包非常简单，Head 部分一共只有 8 个字节，总长度不超过 65515 字节，正好放进一个 IP 数据包的 Data 部分。 TCP 在 TCP/IP 模型中，UDP 为网络层以上和应用层以下提供了一个简单的接口。UDP 只提供数据的不可靠传递，它一旦把应用程序包装给网络层的数据发送出去，就不保留数据备份（所以 UDP 有时候也被认为是不可靠的数据报协议）。UDP 在 IP 数据报的头部仅仅加入了复用和数据校验（字段）。 为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的 UDP 协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。TCP 数据包和 UDP 数据包一样，都是内嵌在 IP 数据包的 Data 部分。TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割。 Segment传输层的数据包，被称为 Segment。 『传输层』的功能，就是建立『端口到端口』的通信。相比之下，『网络层』的功能是建立『主机到主机』的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把 主机 + 端口，叫做『套接字』（socket）。有了它，我们就可以开发网络应用程序了。 Application Layer应用程序成千上万，而『应用层』的作用，就是规定应用程序的数据格式。常见的应用层协议如下: HTTP(HyperText Transfer Protocol) 缺省 TCP 80 端口，用于浏览器浏览网页。但网页内容为明文，易被篡改、易被劫持、网页内容易泄露 HTTPS(HyperText Transfer Protocol Secure) HTTPS 中的 S 代表 Security，缺省工作于 TCP 443 端口，原理是在 HTTP 与 TCP 层之间多了一个安全加密的夹层，称之为 SSL(Secure Socket Layer)，用于加密基于 HTTP 的网页内容，不易篡改、不易劫持、网页内容保密，目前广泛用于网上银行、网上支付等业务。但有安全漏洞，容易受中间人攻击 SMTP(Simple Mail Transfer Protocol) 用于发送邮件的基于 TCP 的应用层协议 POP3(Post Office Protocol - Version 3) 用于接受邮件的基于 TCP 的应用层协议 DNS(Domain Name System) 用于将域名解析成 IP 地址的基于 UDP/TCP 的应用层协议 DHCP(Dynamic Host Configuration Protocol) 用于主机动态获取 IP 地址、缺省网关、DNS 服务器等参数的基于 UDP 的应用层协议 NFS(Network File System) 用于 Unix/Linux 文件共享，基于 UDP/TCP 的应用层协议 NTP(Network Time Protocol) 用于时钟同步的基于 UDP 的应用层协议 RTP(Real Time Protocol) 用于 IP 多媒体电话的语音、文字、视频等流体的传输，基于 UDP 的应用层协议 Message 『应用层』是最高的一层，直接面对用户。它的数据包被称为 Message。 总结我们最后来看一张图 应用程序之间的消息传输过程 网络应用程序之间需要交换的 Message 由源终端的 Application Layer 开始，层层包装，最后形成一个个 Frame。Frame 经由若干个 Link-layer switch 和 Router 的传输，送达到目的终端。再由目的终端的 Physical Layer 开始，层层解析，最终把 Message 交付给目标应用程序。至此，网络应用程序之间就完成了一次 Message 的传输。 为什么要这样设计 为什么互联网要采用分层设计 网络层的作用是什么 如果重头开始设计互联网，你还会分这么多层吗 本文引自 互联网协议入门一 IEEE 802.1Q MAC 地址 NIC UDP 知乎提问：现在仍然活跃的应用层协议有哪些？ 直播相关 一些特殊的 IP 地址 ARP 地址解析协议原理及应用 IPv6]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>Internet</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过年纪实]]></title>
    <url>%2F2018%2F02%2F16%2F%E8%BF%87%E5%B9%B4%E7%BA%AA%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[今年 2 月 11 号(腊月 26)就回家了，在家呆 13 天，初八左右去公司。 2018-02-11 20:00过年第一天 今天坐灵敏舅的车回家，早上 8 点钟就从南京出发，一直到下午 17:30 才到新屋陈村，基本上一天时间都在路上了。 田畈街米饺 三舅家 2018-02-12 20:00过年第二天 今天坐 9 点钟的班车回古县渡。下午陪老妈去买了一下年货，并订了一个生日蛋糕，说是提前帮我过生日。 家 陈氏葡萄酒 小霸王学习机 🐸儿子 米饺 生日蛋糕 2018-02-13 20:00过年第三天 上午去买了一下烟花爆竹，中午去凡仔外婆家吃午饭(凡仔妈妈做的菜)，晚上请凡仔来我加吃饭，顺带尝一下『陈氏葡萄酒』。 烟花 爆竹 账单 午饭 2018-02-14 20:00过年第四天 今天是腊月 29，和胡鹏一起去外婆家过小年。 古县渡-&gt;新屋陈 外公 新屋陈-&gt;古县渡 2018-02-15 20:00过年第五天 上午去山上点灯，下午贴对联，最后吃年夜饭。 堂哥和我 上山的路 刚贴好的对联 年夜饭 2018-02-16 20:28过年第六天 早上在村里拜年，然后去山上拜年，最后一家人再去给菩萨拜年。 菩萨庙 山上的水库 2018-02-17 20:41过年第七天 在家呆了一天，顺便重新整理了一遍 《我眼中的互联网》 2018-02-18 20:30过年第八天 早上去阿姨家拜年，上午和胡鹏、老妈逛了一下街，还顺带吃了占师傅拌粉和瓦罐汤。 两元一个 占师傅拌粉-1 占师傅拌粉-2 2018-02-19 20:30过年第九天 和凡仔，大毛，兔子，皮皮等人在鄱阳浪。 2018-02-20 20:30过年第十天 和凡仔，大毛，兔子，皮皮等人在鄱阳浪。 2018-02-21 20:30过年第十一天 吃伟强哥的喜酒。 囍竹 和我 140 斤的大外甥 立人 2018-02-22 18:05过年第十二天 吃伟强哥的喜酒，明天(初八)回南京上班。 2018-02-23 23:04过年第十三天 早上 9:00 从新屋陈出发，晚上 22:00 到尧林仙居。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>过年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载：学习一下德国人民的翻墙精神]]></title>
    <url>%2F2018%2F02%2F10%2F%E8%BD%AC%E8%BD%BD%EF%BC%9A%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E5%BE%B7%E5%9B%BD%E4%BA%BA%E6%B0%91%E7%9A%84%E7%BF%BB%E5%A2%99%E7%B2%BE%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[最近常听到有人抱怨翻墙太麻烦，俺心里就嘀咕：你要是知道当年德国人民翻墙的艰辛和危险，或许就不会再抱怨翻 GFW 这堵墙的麻烦了。说到德国人的翻墙，比较关心政治的同学应该会联想到大名鼎鼎的 柏林墙。从某种意义上看，东德共党在 60 年代建造的柏林墙和中国共党在 21 世纪架设的 GFW 真是具有异曲同工之妙——两堵『墙』都是用来阻止本国人民对自由的追求。各位同学们目前的处境，和当年东德老百姓的处境也很类似——都在挖空心思琢磨 翻墙之术。 翻越柏林墙的故事 “自由有许多困难，民主亦非完美，然而我们从未建造一堵墙把我们的人民关在里面，不准他们离开。”——肯尼迪《柏林墙下的演说》，1963年6月25日于西德市政厅柏林墙前。 德国的柏林墙是东德于1961年在自己的领土上建立的围墙，目的是不让东德人逃入西柏林，在柏林墙建立之前，大约有250万东德人逃入西柏林，1990年柏林墙被拆除，随后东德加入了联邦德国，两德实现了统一。 肯尼迪曾评价柏林墙是“世界上第一堵不是用于抵御外敌，而是用来对付自家百姓的墙”。但是对于德国人来说，柏林墙所代表的不是肯尼迪，冷战这样的大字眼，而是数以万计小人物的故事，这些小人物在这堵墙边，用自己的生命，造就了人类历史上的一个传说，这个传说的名字，叫做“自由”。 仅在此记录自己了解到的一些故事。常觉得，我国和西方的历史，记录很不一样。在我国的历史记录里，少有这样详尽，乃至繁琐的小人物的记录。所以读西方的历史，经常觉得过于平淡，过于拘泥细节而不见大方向。然而，却自有一种力量在。柏林墙的故事，在西方的历史里，感觉不但不惊天动地，或者剑拔弩张，反而竟然多有幽默。当然，是黑色幽默。 又一个『中国长城』 万没有想到，在柏林墙纪念馆会读到我们中国的名字。柏林墙工程的代号，就是“中国长城第二”。 1961年8月，一个沉闷的夏天。对于大量东德人经柏林逃往西方已经忍无可忍的东德人和苏联人搞了一个漂亮的偷袭。8月12日凌晨1点，2万多军队突然开到东西柏林边境，立刻开始了修筑柏林墙的工程。应该说，这个以我国长城命名的工程，准备还是很充分的，绝对不是豆腐渣工程。仅仅到13日凌晨，第一期工程全部完工，整个东西柏林被铁丝网全部分割，再加路障。柏林墙正式树立了起来。 不过上帝实在会开玩笑，就在柏林墙的修筑过程中，东德人就开始了翻越柏林墙，逃亡西德的“柏林墙传说”。东德人的争分夺秒，只争朝夕的精神，给柏林墙的历史研究留下了千古之迷，到底是先有柏林墙，再有翻越行动，还是未等墙树起来，就已经开始了翻越，竟然永远无法得到一个答案了。 历史记载，柏林墙初步完成，即东西柏林正式分割，在13日中午12点37分，最后一个路口宣布封锁为标志。但就在13日，最早明白过来的东德人已经开始用生命搏击柏林墙，当天，一位技工跨过正在树立的铁丝网跳进了西柏林，有人跳进运河游到了西柏林。然而，天意弄人，谁也没想到记录他们踏上西德领土的时间。 13日上午，西德人涌向柏林墙，向墙那边的同胞投掷自己的通行证，身份证件。到苏联军队能够阻止这一举动前，数以千计的证件已经被扔到了东德同胞的手里。大批东德人借机混在返回西柏林的西德人中间偷渡逾越了柏林墙。 13日下午，柏林墙树立以后，第一个逾越柏林墙的人出现了。一个青年在光天化日之下，用百米冲刺的速度飞奔向铁丝网。但是，三名警察追上了他，将他打倒在地，谁也没有想到，被打倒的他竟奇迹般又站了起来，夺过警察的枪，一边与警察对峙一边继续向西柏林飞奔。警察是尽职的，他们不顾这个年轻人的枪，冲上去和他又一次扭打成一团，并且一刀刺进青年人的膝盖。这次这个年轻人失去了奔跑的能力，面对三个警察，结局已经注定。 然而，上天决心要给大家看一幕喜剧而不是悲剧。就在此刻，西柏林群众雷鸣般的怒吼惊醒了三名警察，他们已经越过了柏林墙，现在是在西德的土地上，他们不再是警察，而成了违法者。他们扔下青年跑回柏林墙的另一侧。这个青年拖著残废的腿，一边拼命呼救一边爬到了西柏林。 事后证明，这是一个大大的误会。事实上柏林墙并不是沿东德西德的边境修筑的，而是偏东德一侧，这是为了保证，即使你越过了柏林墙，你仍然在东德土地上，警察和军队仍然有权力和能力开枪将你击毙。当时那三位警察并没有越界，他们大可以合法将那个青年绑回东德。然而，面对这柏林墙上的第一次交锋，他们误会了，害怕了，那个青年简直是奇迹般的竟然这样逃脱了已经笼罩住了自己的厄运。这是第一个通过柏林墙的逃亡者。也许这第一个人就定下了逃亡柏林墙故事的基调。 在柏林墙传说里，有眼泪、有悲壮、有无奈；但同样也有幽默、滑稽和令人含泪微笑的故事。 最可爱的人 写可爱是容易的，面对冷酷的现实，人类用自己的信心，幽默来反抗，说起来即使是最大的冷酷，也压不下那希望和温暖。然而要写悲惨，实有些下不了笔。 柏林墙的逃亡者中，那些“功败垂成”者无疑是悲惨的。1961年，18岁的彼得·菲西特就是这么一个人。他已经爬到了柏林墙的顶部，只需要再加最后一把劲，就可以达成目标，就在这个时候，枪声响了……彼得滑落回柏林墙东侧。 悲剧还没有完，身中数弹的彼得倒在柏林墙下，血流如注，我不知道东德的警察是一时不敢承担责任，跑去请示上级，还是真的就已经下了杀心（我宁愿相信是前者）。彼得就这样在墙下躺了50分钟，没有一个东德警察前来管他。 彼得的呼喊声一点一点的低下去了，低下去了。西柏林的人群爆发出愤怒的抗议声。“你们是杀人犯！”“你们是法西斯！”上千群众怒吼著。西德的警察冒险跑到柏林墙边（前面已经说过，这是极其危险的，柏林墙西侧依然是东德的土地，警察已经“越界”，完全可能被枪击）把急救包扔向彼得。但是太晚了，彼得已经失去了自救的能力。彼得终于停止了呼吸。他的血已经流尽了，在他蓝眼睛里最后映出的，依然是东柏林。50分钟以后，东德警察抬走了他的尸体。 如果说彼得最大的不幸在于他最终没有成功，我不知道下面这个最后“成功”的例子，是不是算幸运。在柏林墙刚完成的那一年，由于墙还不是很坚固，有人就想出了办法，开重型车辆直接撞墙！直接冲开柏林墙进入西德。1961年，这类事件多达14起。 逃亡者要面对的绝不仅仅是坚固的高墙，还有来自军队和警察的密集射击。有军事常识的朋友都知道，对于穿透力极强的子弹，民用的车壁，车门根本就是nothing，香港电影里躲到小轿车后面就可以逃开对方射击的镜头完全是搞笑。所以，用这个办法冲击柏林墙的人，实际上等于完全不设防的穿行在枪林弹雨中，去争取一次严重交通事故的机会！ 这里的故事太多，最悲惨的，一是在离墙最后一米处熄火的那辆装有数十人的大客车。二就是布鲁希克的故事。 布鲁希克和他的同伙同样是利用大客车冲击柏林墙，但是他们的行动从一开始就被发现了。军队和警察从多个方向向客车密集射击，客车起火燃烧，弹痕累累！还好，客车质量过硬，不但没有熄火，还在布鲁希克良好的驾驶下奋勇加速，一声巨响，柏林墙被撞开了一个大缺口，整个客车冲进了西柏林！ 欢呼的人群拥上来迎接，却被眼前的景象震惊了，驾驶座上的布鲁希克身中19 弹，他是用生命的最后意志坚持加速，冲向柏林墙的。当客车冲进西柏林的那一刻，布鲁希克停止了呼吸。 柏林人展开了一场争论，布鲁希克究竟有没有看到他梦想看到的西柏林？最后是一个现场镜头宽慰了大家，从镜头上看，客车驾驶座位于西柏林之后，布鲁希克还有一个抬头的动作。是的，那时候他还活著！他的眼睛最后映出的，是他梦想中的迦南西柏林！他是一个成功者。 柏林墙在两德统一后完全拆毁，后来联邦政府作了很大努力说服人民同意在原址重建了一段70米的“柏林墙”作为警示，图中十字架是企图越墙者的墓碑，为纪念他们追求自由的勇气把他们葬在这里让人凭吊。在28年中，至少有239人在试图翻越柏林墙或潜渡施普雷河时被枪杀。 这个镜头我也看了，说实话，在那样的动荡，混乱，和快速行驶中，每个人都被颠簸得相当厉害，硬要说那个几乎无法注意到的动作是布鲁希克自己作出来的而不是别的原因，我感觉实在是勉强。但是，谁又愿意继续辩论下去呢？谁又不希望这个年轻人生命的最后时刻能够是快乐呢？德国人如此不严谨的结论很少，却少得可爱，少得美丽。 柏林墙倒塌以后，新建成的文化宫，专门采用了很特殊的设计。建筑之间均用伞状结构连接，整个原来的柏林墙东侧“死亡开阔地”被全部笼罩在保护伞下。成为了伞下的广场。 我的德国同学说，这是因为，在这个广场上，无数逃亡者因为没有任何隐蔽物，只好强行穿越在火力控制下的广场而失去生命。现在，德国终于可以为自己的公民提供隐蔽物了，尽管，已经太迟，太迟…… 我无话可说。 咱们德国人都是工程师 上面那篇太沉重了，来一点轻快的。 德国人的机械设计，制造能力举世闻名，在柏林墙逃亡中，那也是充份体现了德国人民的技术水平。要按现在流行的歌来唱，那就是：“咱们这嘎都是德国人，咱们这嘎特产工程师，咱们这嘎香肠配啤酒，咱们这嘎都是活本茨”（本茨，即奔驰汽车创始人，德国工程师）。 1968年，一位东德青年利用河流潜水到达西德。大家心目中的潜水是什么样的？潜水服？潜水镜？总之他一个人能有多大本事，还一切都必须自己造，最多是一点粗糙的个人潜水工具罢？ 非也，这位青年自己造的是——潜 - 水 - 艇！ 他用的是摩托车马达，配上自己组装的钢板，还有导航，压缩气体等系统。硬是在家造出了一个个人用的小潜水艇。质量如何？我看可以通过ISO9002国际认证。这潜水艇在水下航行了超过5个小时，才从西德那边冒出来，其中没有发生任何事故。有同学说了，5个小时是不是太长了一点？那是没办法的事情，你试试拿个小摩托的马达去潜水看看。 这小潜水艇当然是一个奇迹，该青年的逃亡过程使他立刻在西德找到了工作，各大机械公司竞相聘用该青年为设计师。听说后来他还真在机械设计上大有成就。 不过小潜水艇也就算了，后面来了个更狠的，逃亡中一不小心，楞搞了个吉尼斯记录出来。 1979年某夜晚，从东德一个家庭的后院升起了一个巨大的热气球。气球下面的吊篮里装著两个家庭——两对夫妇和他们的四个孩子。这个气球完全由这两个家庭手工制成，花了数年的时间。在此期间，两个家庭自学成才，从材料学，工程学，气体动力学，气象学……一直到建立家庭实验室，最后成功的在家庭的后院里制作完成了这个高达28米的热气球！ 经调查，此热气球是欧洲历史上最大的热气球，被记入吉尼斯世界记录！ 这个热气球在通过柏林墙的时候，被警察发现了。警察目瞪口呆之余，还算记得开枪射击。这一射击，该气球良好的工艺水准就发挥了出来。逃亡者操纵热气球一下升高到了2800米以上的高空，不但枪打不到，连探照灯都照不到！警察只好紧急呼叫空军支援：“长江长江，我是黄河，你们赶快出动，寻找一个热气球，把它打下来。对！没错！是热气球！重复一遍，热 - 气 - 球！” 苏联空军的“苏”、“米”战机立刻出动，但是热气球在28分钟的飞行以后，已经完成了使命，安全落地。 问题是，当气球被发现以后，两家人决定立刻降落，以避免被战机击落。这一“紧急降落”，就谁也摸不准方向了——降落的地点无法确定。到底是已经到了西德，还是被迫降在东德，谁也不知道。 估计在他们数年的学习中没有心理学的功课，面对未知的前景，8个人都失去了验证的勇气。他们根本不敢走出这个气球，就这样躲在吊篮里长达24小时之久。他们已经没有勇气亲自揭晓自己的命运了。他们唯一能做的，就是祈祷。降落整整24小时以后，军人来了，揭开了气球。他们对这8个逃亡者说出了他们盼望了多少年的话。——“你们自由了，这里是西德领土。” 还有一个地下逃亡的工程也是让人叹为观止。它是一条穿越柏林墙的地下隧道。这条隧道全长145米。距地面距离是12米。就是说，这隧道先如挖井一样，向地底直着往下挖12米深，然后在开始往柏林墙方向挖。隧道的进口，设在一所房子后院的厕所里，而出口是一个老点心面包店的地窖。隧道内部高度不足一米，确切地说，只有70公分。否则，在这种秘密状态下，太多的土将无法化解在屋子里。大量的土用小推车运送到地道口，再拉上井，分散在屋子里。一共有36个青年和一位23岁的女青年参加了这项秘密工程。他们由此营救出了他们的未婚妻和朋友，以及他们全然不认识的家庭。 值得一提的是，这个隧道不是从东柏林往西柏林挖，而是由西柏林往东柏林挖。之所以仍然要秘密地处理挖出来的土，大概是因为在救出所有要救的人之前，仍然需要小心谨慎，不走漏风声：谁知道西柏林是否有东柏林的间谍？ 但问题是，如果从东柏林往西柏林挖，出口可以不必忧虑，反正只要到了西柏林，那里都是自由的土地，都可以光明正大地走出来。但是从西柏林往东柏林挖，出口就必须事先设计好，必须正好是一个隐蔽的出口。 这些西柏林的营救们，是怎样使出口正好挖通在一个房子后院的厕所里的呢？他们又不能公然和秘密警察监视下的东柏林一方联系、讨论；就是秘密联系讨论也不可能公然测量距离、方向和位置；就是公然测量了，又怎样方位、距离分毫不爽地可可从人家后院的厕所里挖出？ 这应当是工于计算、思维精密、办事严谨的德国人逃亡到西柏林的又一个杰作。 这项秘密工程不声不响地进行了六个月。57位东柏林人成功地从这个隧道中出逃。从开始挖土，到逃亡者最后爬出隧道，在12米深的井口下坐着缆绳，始见西柏林的自由天日，人们为这一工程全过程拍下了珍贵的照片。这些照片除了传递当时的作业情况，还向后人传递着另一种信息：救助者们在挖下第一铲土时就知道他们一定会成功，而且只能成功，否则，这些照片随时可以成为治罪的证据。 世上无难事，只要肯钻研 下面这个故事，证明了这个世界上永远有些事情，你是连想象都想象不出来的。 如果让你把一个人藏在小汽车里偷越柏林墙，你会把他藏在哪里？后箱？底盘？座位下面？恐怕没有一个人会想象得出来，把人藏在汽车的引擎部份。不要说那里因为发动机的缘故温度高，废气多，人放那里多半不烫死也憋死，就算没这些问题，您随便掀开哪辆车的引擎盖看看，怎么可能放得下人？ 然而事实证明，那里可以放下一个人，而且这个人可以在引擎旁边至少呆2个小时以上，还保持清醒。9个从引擎中逃亡柏林墙的东德人可以作证。他们的故事甚至连金庸先生描写的什么“缩骨功”也相形见绌。 据资料显示，他们都是把自己扭曲成，成，很难说他们把自己扭曲成什么形状了。总之他们就好象没有骨头，可以随便变形的橡皮泥一样，把自己一点一点的塞进了引擎与盖子之间的缝隙里。然后就这样逾越了柏林墙。到达西柏林以后，他们要用1-2小时的时间，再一点一点把自己“还原”。先出来一条腿，再伸出一个头，逐渐的，一个人的形状硬是从引擎里升了起来。如果放一个快镜头，简直就是《终结者II》的翻版。 在录像上，一大群西德的热心人在旁边帮忙。但是很快，“不许帮忙”就成了规矩。因为逃亡者的姿势实在太古怪，只能由本人来逐渐恢复。没有经验的人只能是越帮越忙。 在香港电影里，警察或者匪徒，经常从人行天桥上一跃而下，正好落在驶过的汽车顶上。这对于我们来说是电影，对于柏林人却是生活的一部份。 凡靠近柏林墙的高楼，都成了东德人“跳楼”的场所。不必担心，这里的跳楼可不是求死，而是求生。只要你爬到楼上，表现出逃亡的意图，西柏林的同胞们就抬著床单蜂拥前来接应。鼓足勇气，一跃而下，只要把握了方向，就可以在空中逾越柏林墙，落到床单上。 当然，不是每个人都有这么高的运动天份的。曾经有一家三口一起跳楼。6岁的孩子成功了，父亲和母亲却摔到了地面，一个伤了内脏，一个伤了脊椎。在短短的跳楼时代，有4个人因跳楼而死亡。 年纪最大的跳楼者是一位77岁的老太太。她在跳下来之前，把自己吓得瘫倒在了地板上。无论大家怎么鼓励，怎么哀求也无法跳下来。就在西柏林人准备失望的散去的时候，一个意外发生了。东柏林的警察发现了情况，冲进了大楼。警察破门的声音给了老太太无穷的动力，她冲向窗口，果断的一跃而下…… 再后来，由于柏林墙西侧仍属于东德，接应的西德人算侵犯了东德领土，跳楼者又改用汽车接应。顶部预先布置的汽车突然冲向柏林墙，跳楼者就把握这一刹那裹著被子飞跃而下，直扑汽车顶部。汽车又马上退回西柏林内部。 直到东德下了决心，把柏林墙东德一侧的高楼全部推平，空出一片几百米的“恐怖区”以后，居然还有人延续了这个跳楼逃亡法。某位德国工程师设计了一个强力弹射装置，从东柏林市内的高楼起跳，“弹”了数百米到达西柏林，然后利用自己制造的降落伞缓缓落地。 柏林墙的倒掉 历史的进程到了1989年下半年，东德已经是强弩之末。由于东德政府70年代以来所实行的指令性经济、农业全面集体化、强力发展重工业、严厉打击国内反对声音的经济、政治政策，导致经济发展几乎停滞，210亿美元的外债债台高筑、东德马克内债累累，环境污染严重，人民生活贫穷压抑，严重的不满情绪早以深深埋伏在社会民心之中。 1989年11月9日，新东德政府开始计划放松对东德人民的旅游限制，但由于当时东德的中央政治局委员君特·沙博夫斯基对上级命令的误解，错误地宣布柏林墙即将开放，导致数以万计的市民走上街头。 这一天，就象上紧了发条的钟表，突然失去指针，滴滴答答的钟声尤在，却不知何始何终——柏林墙的两面人山人海，鸦雀无声。 面对这堵耸立了28年，阻绝两德人民，制造了无数悲欢离合、生死哭歌、惨重牺牲的血墙，人们无法判断的是：当制造它的独裁政府部门和官员辞职的辞职，改选的改选时，柏林墙辞职了吗？它是否仍然戒备森严？它还能随意射杀越墙的逃亡者吗？自动射击装置是否完全解除？密堡暗碉里的岗哨是否仍然轮流值班？带缰绳可以自由追踪100米的警犬是否正严阵以待？ 没有任何官方的媒体报道这些与人们生息密切相关的消息。柏林墙依然无声地矗立着。它两面成千上万被阻隔的人们遥遥相对，心中纵有万马奔腾，脚却不敢越雷池一步。 这是继两次世界大战之后，德国又一个历时转折的关头。而历史在这一瞬间干脆停下了脚步，为的是让人们记住它的沧桑。 不知道渴望自由的人们同这面血墙对视了多久，终于有一个东德的青年人，壮着胆子，往那禁区的空地，试探着，迈出一只脚…… 没有反应。让脚落地，移动身体重心，再迈出另一只脚…… 仍然没有发现任何警戒方面的反应。 小伙子双脚落在东柏林境内的禁区，人，暴露在自动枪击射程之内。 柏林墙两岸，无数双眼睛被这年轻的躯体所抓住，人们不约而同屏神静息等待着……要么枪声乍起，又一具尸体倒卧在血泊中；要么人民淹没、踏碎这围墙。 小伙子不急不徐，却一步千斤，载着两德的万众一心，牵着两德张开的手臂，在众目暌暌之下，从那片社会主义东德境内的边境开阔地，一寸一寸、一米一米走向资本主义西柏林境内。 这应当是德国历史上，街头上最安静最紧张的时刻了。 当小伙子在身前身后人山人海的无声的注视下，终于接近柏林墙，奋力攀上墙顶，预期的枪声仍然没有响起，紧张的人们却沉默得几乎要爆炸。 然后，西柏林一边向这位以命相抵、探试自由的青年人伸出了丛林般的手臂；然后，小伙子双脚结结实实踏上了西柏林自由的土地。 一瞬间，柏林墙两岸人声鼎沸，心旌摇荡，激动的情感潮流如洪水决堤。人们相互拥抱接吻，相互重复诉告着那个刚刚发现的不可思议的事实：柏林墙解放了！它的警卫事实上已然解除！它已经全然不过就是一堵墙而已了！ 两德人们相互拥入对方，成千上万的人们彻夜不眠地享受着亲友重逢的喜悦。两德人民拥满柏林墙墙上墙下墙东墙西，人们举杯相庆，奏乐狂欢，欢乐的自发的庆典持续数日，节日的气氛经久不消。 无论如何，柏林墙的故事已经结束了（而且，是喜剧性的结束）。人间的故事，如柏林墙这般悲惨的并不少，能够最终这样收场的，已经很不错了。 德国人毕竟是幸运的，柏林墙见证了德国人的痛苦，全世界分享了他们的痛苦。他们被关注着。然而，还有那么多的人，他们的痛苦竟然是完全默然的。 柏林墙倒下了，东德人终于获得了他们梦寐以求的自由。然而，类似的悲剧却并没有在这里地球上结束。我们看到在远隔德国万里重洋的另外一个国家，依旧有一堵用来对付自己的百姓的墙巍峨耸立着。 唯一的区别是：大多数人看不到甚至不知道这堵墙。 本文引自 原文(需翻墙) 科学上网的终极姿势]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>德国</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机的记忆]]></title>
    <url>%2F2018%2F02%2F04%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[人如果没有记忆，那么许多事情将变得很糟糕。例如：当你走出银行大门时，你已经忘记了你的银行卡密码；当你走进考场时，你已经忘记了熬夜刷过的题；当你早晨起床时，你已经忘记了枕边人的姓名。同样的道理，如果计算机失去了记忆。可能昨天刚运行过的代码，今天又需要你手动输入一遍。那么，怎样才能使计算机变得有记忆呢，或者说，怎么才能让计算机拥有存储能力呢？ 反馈(feedback) 反馈（英语：Feedback，又称回授），在台湾称为『回馈』，是控制论的基本概念，指将系统的输出返回到输入端并以某种方式改变输入，它们之间存在因果关系的回路，进而影响系统功能的过程。在这种情况下，我们可以说系统『反馈到它自身』。在讨论反馈系统时，因果关系的概念应当特别仔细对待：『对于反馈系统，很难作出简单的推理归因，因为当系统A影响到系统B，系统B又影响到系统A，形成了循环。这使得基于因果关系的分析特别艰难，需要将系统作为一个整体来看待。』反馈可分为负反馈和正反馈。前者使输出起到与输入相反的作用，使系统输出与系统目标的误差减小，系统趋于稳定；后者使输出起到与输入相似的作用，使系统偏差不断增大，使系统振荡，可以放大控制作用。 触发器(flip-flop)电路图我们先来看一个电路图 图 7.14 两个或非门首尾相连形成两个反馈 这个电路上下对称，分别都是一个或门连着一个非门，特别之处在于，它们各自的输出又分别是对方的输入。换句话说，在这个电路里存在着两个反馈，如图 7.14 所示。在一个电路里搞出两个反馈来，你别说，发明它的人还真是挺有想法。 为了更好的分析图 7.14 电路的作用，我们不妨将开关和灯泡也加进这个电路 图 7.15 用来验证或非门反馈功能的完整电路 电路刚接好的时候，你要确保两个开关都是断开的。现在，准备好了吗？我们可要合上开关 R 了！ 我们知道，或门属于那种好好先生，不挑剔，只要有一个输入为 1，它就输出 1 。所以，如图 7.16 所示，闭合 R 就等于 R=1，于是不管 Q 以前是亮还是灭，它现在一定不会发光，即 Q=0。 图 7.16 当 R 闭合 S 断开时，Q 不亮而 Q&#39; 亮 这就完了吗？不会的。因为有反馈的存在，Q=0 紧接着被送到下面。同时，因为 S 也为 0，所以经过或门和非门后，灯泡 Q’ 因为被通上了电而兴奋得满面红光。也就是说，Q’=1。当然，Q’=1 又被反馈到上面。但是，因为 R 已经给或门提供了 1，所以 Q 的状态不会受到影响，整个电路就此处于稳定状态不再改变。 有意思吧？断开 S，合上 R，灯泡 Q 不亮，Q’ 亮着。要我说呢，这还不算什么，更神奇的是，这个时候，即使你断开 R，灯泡 Q 依然不亮，而灯泡 Q’ 依然亮着！再合上 R，再打开、再合上…不管你怎么折腾，Q 和 Q’ 还是那样。 原因很简单，还是那个 图 7.16，你看，因为 Q’=1 被反馈到上面，所以，即使 R 断开，或者再次合上，也不会改变或门的输出，整个电路的状态也不会发生改变。 现在，让我们把注意力转移到电路的下半部分。这一次，我们让 R 一直处于断开状态，将 S 合上。就在一瞬间，所有的事情都颠倒了，灯泡 Q 亮着，而 Q’ 却不亮了！如图 7.17 所示。 图 7.17 当 R 断开 S 闭合时，Q 亮而 Q&#39; 不亮 由于电路是对称的，上下两部分一模一样，所以这件事情也不难理解。一旦你合上开关 S 使得 Q=1 而 Q’=0，往后再怎么摆弄 S，是闭合还是断开，都不会再影响到电路的状态。换句话说，只有最开始那一下子是最重要的。 尽管我们是在讲科学，但它会让朋友们以为你具有特异功能。你可以叫你的朋友背着你合上一个开关，然后再把它拉开，这时候，你可以踱过去，观察一下哪个灯泡亮着，然后准确地说出他刚才动的是哪个开关。相信这一定会让你的朋友张大嘴巴，惊奇地看着你。 上面讲的这个电路，称为『触发器』。触发器在很多英文书中被称为『Flip Flop』，简称 『FF』，差不多类似于我们汉语里的象声词，大致的意思是『噼里啪啦』或者『噼噼啪啪』。当然，这不是过年放爆竹，而是一大堆继电器在工作的时候所发出的声音。 触发器的工作状态依赖于两个开关 S 和 R，闭合一个断开另一个，总是会得到两个相反的输出 Q 和 Q’；要是这两个开关都断开，那么，取决于 Q 和 Q’ 刚才处于什么状态，它们依然保持这种状态不变。这都是我们已经知道的。不过，你有没有想过，还有最后一种情况，要是 S 和 R 都闭合，会怎样呢？老实说，情况很不妙。如 图 7.18 所示，闭合两个开关，将直接导致上下两个或门的输出永久为 1，经过非门变换之后又都变成 0，于是两个灯泡都不亮。 图 7.18 当 R 和 S 都闭合时，Q 和 Q&#39; 都不亮 这是非常粗暴的做法，是暴力干涉。通常情况下，灯泡 Q 和 Q’ 是互补的，配合得挺好，互为依托，相互制约，一个亮起来，另一个就会熄灭，能自己达到合适的稳定状态。但是现在，虽然电路里依然存在反馈，但是不起作用，整个电路现在已经丧失了记忆力，差不多已经失去了理智，神经错乱了。 总结一下。这里讲的触发器，一共有 4 中工作状态，参见 表 7.1。 S R Q Q’ 0 0 不变 不变 0 1 0 1 1 0 1 0 1 1 0 0 表 7.1 触发器的输出与 S 和 R 的关系 符号 图 7.19 R-S 触发器的符号 这是最早的，也是最基本的一种触发器，我们一般称它为 R-S 触发器。在这里，S 和 R 不再代表开关，而 Q 的意思也和灯泡相去甚远。然而，无论是开关的通断还是灯泡的亮灭，代表的无非是电压或者电流的有无，两种不同的表示方法，它们背后的思想是一致的。Q 和 Q’ 总以相反的状态出现，Q=0 则 Q’=1；Q=1 则 Q’=0。 触发器有两个截然相反的输出，不过多数情况下我们只需要一个输出就已足够。因此，一直以来就把 Q 作为触发器的输出。结合 表 7.1 还可以看出，在触发器正常工作的前提下，Q 的输出和 S 的输入总是一致的，S=0 则 Q=0；S=1 则 Q=1。这意味着可以通过设置 S 的值，使得 Q 的输出和 S 保持一致，这就是『S』的由来（在英语里，S 是单词『Set』的第一个字母，这个单词的意思是『设置』）。不管 Q 以前是什么，比如 Q=0，我们可以通过让 S=1 来使 Q 变成 1。但是，当 R=1 的话，Q 又变回 0，这等于将 Q 打回原形，这称为『恢复』或者『复位』，『R』就是这么来的（R 取自英语单词『Reset』的第一个字母，该单词的意思是『复位』）。 可以保存一个比特的触发器 在埃克尔斯和乔丹的实验室里，触发器没有什么用途，它只是证明了电子管可以做成这么一样东西，就像经验丰富的厨师有一天突然想到可以用蒜苗和鸡蛋做出一样新菜肴。事实上，人类的很多发明就是这样产生的。好的东西总有用武之地，尤其是科学家和工程师们喜欢翻老底子，让那些现成的发明可以『为我所用』，触发器就是一个现成的例子。 为什么这样说呢？普通的电路，以及常规的逻辑门都有一个共性，那就是输出直接依赖于输入，当输入消失的时候，输出也跟着不存在了。触发器不同，当它触发的时候，输出会发生变化。但是，当输入撤销之后，输出依然能够维持。这就是说，触发器具有记忆能力。若干年后，当工程师们想在计算机中保存一个比特时，他们想到了触发器，这是一种职业嗅觉在起作用。不过，触发器有两个输出，保存一个比特不需要这么多。 如 图 8.1 所示，解决的办法是只留下一个输出 Q，而 Q’ 废弃不用（把它的引线剪掉）。这样，被保存的比特可以从 Q 端观察到，或者把它取走，引到别的地方使用。通过它，可以知道当前触发器保存的是什么，是 0 还是 1。 图 8.1 通常把 Q 作为 R-S 触发器的输出 我们的愿望是用触发器保存一个比特，一个比特只需要一根电线就可以传送，可是你瞧，它有两个输入端 S 和 R。而且，触发器要正常工作，离不开这两位仁兄的通力配合，少了谁都不成，要想使 Q=0，S 必须为 0，R 必须为 1；要想使 Q=1，必须使 S=1 而 R=0。 这可如何是好呢？难不成要保存一个比特，就必须得用两个输入吗？不要悲观，解决之道是拿一个非门，按照 图 8.2 所示的方法连接起来。 图 8.2 使用非门使 R 与 S 总是相反，解决用触发器保存 1 比特的问题 很显然，因为要想使触发器保存一个比特，就必须使 S 和 R 以相反的方式出现，所以非门的作用就是创造这样的条件。不是天才，怎么也想不出这个好办法。那么，这种做法到底有没有效果呢？不试试怎么知道！为了看看它能不能保存一个 0 或者一个 1，我们在它的左边接上开关，通过闭合或者断开开关，就能得到要保存的比特（0 或者 1）。同时，触发器的输出端接了一个灯泡，它的亮灭可以验证该比特是否已经被保存。如 图 8.3 所示，电路刚接好的时候，开关是断开的。断开的时候相当于要保存一个比特 0 。这个时候，如图所示，S=0，R=1，触发器动作，Q=0，所以不要指望灯泡会亮起来。 图 8.3 使用触发器保存比特&quot;0&quot;的过程 灯泡的冷漠表明目前触发器中保存的是 0。现在，用手摁一下开关，电路被接通，相当于输入为 1。如 图 8.4 所示，这个时候，S=1，R=0，触发器保存这个比特 1，于是灯泡亮了。 图 8.4 事实证明，仅仅增加一个非门，并不能使 R-S 触发器独立的保存并维持 1 个比特 这是个按键开关，当我们一撒手，它就会自动弹起来。嗯，这的确是一个性能优良的开关，不过我不是想说这个，眼下最要紧的，是当开关弹开后，被保存的比特能够独立存在而不受外部的影响。可现实呢，你会发现，一旦按键开关弹开，灯泡马上就会变脸——不亮了！ 傻眼了吧？这忘恩负义的东西，阳奉阴违，人刚走茶就凉了。原因很简单，开关弹开，相当于输入的比特是 0，于是触发器又忙不迭地把这个 0 存起来，灯泡自然就又不亮了。 这可是触发器呀，触发器是干什么的？连一个比特都存不住，那它和一根电线有什么区别？不要怪触发器，它只是一个电路，一些没有生命的零件，要怪只能怪我们没有把它设计好。为了把它设计好，我们给触发器安排两个门卫——如 图 8.5 所示，这是两个与门。这两个门卫都归同一个经理管辖，这就是控制端 CP。 图 8.5 经过改进的触发器，增加了 1 个控制端 我们这样来安排电路是有用意的，而且真的是很有效。如 图 8.6 所示，你看，通常情况下 CP=0，意思是现在不想保存数据。这时，因为与门的关系，不管 D 上是什么，S 和 R 都为 0，所以触发器保持原有的内容不变。 图 8.6 当控制端为 0 时，触发器不接收 D 端的比特 这就是说，CP=0 的另一层意思是希望触发器不被外面的数据干扰，继续保持原先保存的那个比特。在触发器前面放两个门卫（与门），不单单是保护原有的比特，它们还有更重要的任务。比如，如果 D=0，而且有经理陪同前来，即 CP=1，那么如 图 8.7 所示，S=0 而 R=1，于是 0 就会被保存到触发器里（Q=0）。 图 8.7 当控制端为 1 时，如果 D 端为 0，触发器的 Q 端为 0 再比如，同样是在有经理陪着的情况下（CP=1），要是 D=1，那么 S=1 而 R=0，于是 1 就被保存到触发器里（Q=1），如 图 8.8 所示。 图 8.8 当控制端为 1 时，如果 D 端为 1，触发器的 Q 端为 1 不管保存的是 0 还是 1，当它成功地进入触发器之后，日理万机的经理就打道回府了（CP=0），于是 S 和 R 都会一直为 0。换句话说，没有经理的陪同，负责保卫工作的人无法确定来者是不是危险分子，谁也别想再进入触发器，触发器将一直维持刚才保存的比特不变（参照 图 8.6）。最后，一个需要经理亲自护送才能保存比特的触发器称为 D 触发器，D 触发器的符号如 图 8.9 所示。 D 触发器 图 8.9 D 触发器符号 『D』取自英语单词『Data』的首字母，而『Data』的意思是『数据』、『数字』。所以，D 触发器的名字很恰当地表明了制造它的原始目的。 至此，我们终于可以保存一个比特了。 本文引自 《穿越计算机的迷雾》 反馈]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>记忆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机的心率]]></title>
    <url>%2F2018%2F01%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%BF%83%E7%8E%87%2F</url>
    <content type="text"><![CDATA[心率是指心脏跳动的频率，即心脏每分钟跳动的次数。人平静时平均每分钟 60 到 100 次，运动(恋爱)时心跳会加速，心肺功能越好的人心跳越慢。那么计算机有心率吗？如果有，计算机的心脏又是什么呢？ 开始阅读前，假设你已经了解基本电路符号和电磁铁的工作原理。如果你不清楚这些的话，可以先阅读 这篇文章 中电磁铁与继电器的相关内容。 电子蜂鸣器(buzzer) 电可以让物体运动，这个道理人人都懂。只要稍微扫视一下我们的房间就会发现：很多电器中都装了电动机，比如钟表、电扇、吹风机、计算机。电同样可以使扩音器中的磁芯振动，正因如此我们的音响设备、电视机才能够产生声音，播放语音和音乐。有一类设备或许能很清晰地阐释电能驱使物体运动的最简单也最具代表性的方式，然而由于这类设备正在被能够实现同样功能的电子器件逐步取代，它们正在迅速地消失。在我看来，最令人赞叹的例子应该算是电子蜂鸣器和电铃了。将继电器、电池、开关按如下形式连接。 如果你认为这个系统看起来有点古怪，说明你还没有发挥出想象力。或许以前我们没见过采用这种连接方式的继电器，因为我们通常所见过的继电器，其输入和输出是在两个回路当中的，而这里却构成了一个回路。当开关闭合后，电路就连通了。连通的电路使得电磁铁把金属簧片拉了下来。 当金属簧片的位置变化时，电路不再连通，电磁铁不再具有磁性，金属簧片又弹回原位。 如此一来，电路又一次连通了。从整个过程来看：开关一旦闭合，金属簧片就会上下跳动——电路也会随之连通或断开——声音也就会随之发出。如果金属簧片发出了一种刺耳的声音，这套系统就成为了一个蜂鸣器。如果金属簧片前端是一把小锤子，旁边只要放上一个锣，就构成了一个电铃。大家可以自行脑补一下。 实在脑补不出来同学的可以参考下图: 振荡器(oscillator)其实上面的电路还有另一种接法，下面的示意图中包含了一个标准电压符号和一个接地符号。 看到这幅图你或许立刻想起了非门(或者称反向器)，因此电路可以简化为如下图所示。 反向器，顾名思义，当它的输入是 0 的时候，它的输出就为 1；而当其输入为 1 时，输出就为 0。电路中的开关一旦闭合，反向器中的继电器就会在连通与断开这两种状态之间反复交替。你也可以将电路中的开关省去，这样就可以使反向器连续地工作，如下所示。 这幅图似乎在表达着一种矛盾的逻辑，反向器的输出与其输入是相反的，但是在这里，输出同时又是输入！ 然而，我们要牢牢记住，反向器在本质上就是一个继电器，而继电器将状态取反以得到另一个状态是需要一点点时间的。所以，即使输入和输出是相同的，输出也会很快地改变，成为输入的相反状态（当然，输出随即也会很快改变输入，如此反复）。 这个电路的输出到底是什么呢？其实就是要么提供电压，要么不提供电压，在两者之间切换。我们也可以用这种方式来表达——输出结果要么是 0, 要么是 1。我们把这种电路称为振荡器(oscillator) , 它和我们先前学到的所有东西存在本质上的区别。在此之前我们讲过的所有的电路，其状态的改变都依靠人为的干预(拨动开关)。但是振荡器却在不需要人干涉的情况下，可以完全自发地工作。 当然，单独的一个振荡器用处并不大。但是，在与其他电路连接后所组成的自动控制系统中，振荡器有着举足轻重的作用。为了使不同组件同步工作，所有计算机都配备着某种振荡器。 频率(frequency) 当采用 0 和 1 的交替序列来表示振荡器的输出时，我们一般使用下面这样的图来形象地描述输出。 我们可以通过这幅图来充分地了解电路的输出，水平坐标代表时间，垂直坐标用来表示输出是 0 还是 1。 这幅图表示随着时间的推移，振荡器的输出在 0 和 1 之间按照固有的规律交替变化。正因为这一点，振荡器又经常被称为时钟(clock)——通过振荡进行计数也是一种计时方式。 振荡器运行速度究竟有多快呢？换句话说，金属簧片多久会振动一次？或者每秒钟振动多少次呢？这很大程度上依赖于继电器的内部构造。你容易想到，一个又大又重的继电器只能缓慢地上下摆动；而一个又小又轻的继电器却可以高速地跳动。振荡器从某个初始状态开始，经过一段时间又回到先前初始状态的这一段间隔定义为振荡器的一个循环(cycle)，或者称为一个周期，如下图所示。 一个循环所占用的时间就是该振荡器的周期(period)。假设我们使用的振荡器的周期恰好是 0.05s，任取一个时间点，将其设置为起始状态点，我们把它标注为零点，就可以在水平轴上标出相应的时间。 周期的倒数就是振荡器的频率(frequency)。在这个例子中振荡器的周期是 0.05s，那么其频率就是 1➗0.05s，即振荡器每秒钟产生 20 次循环，而相应的输出每秒钟也变化 20次。 每秒钟的循环次数与每小时穿越的公里数、每立方米水的重量、每份食物的卡路里数等概念一样都是很容易理解的，但这种描述方法已不常用。为了纪念发送和接收无线电波的第一人——亨利希·鲁道夫·赫兹(1857-1894), 后人使用『赫兹』这个词来表示这一概念。这种用法起源于 20 世纪 20 年代的德国，几十年之后逐渐被其他国家所广泛采纳。这样，上述振荡器的频率就是 20 赫兹，记做 20Hz。 计算机的心率现在你应该清楚电脑主频这个参数的作用了吧。那么问题来了，现代计算机的振荡器还是由继电器构成的吗？是不是主频越高就意味着电脑的处理速度就越快呢？ 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 心率 反向器 电子振荡器 时钟频率]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>心率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈计算机中的四则运算]]></title>
    <url>%2F2018%2F01%2F21%2F%E8%B0%88%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[经过前面 从零开始造一台自己的加法器 的学习，现在我们已经能造出一台简易的二进制加法器，可以利用它来做四位二进制的加法。那么减法、乘法和除法呢，难道我们也要一一构造减法器、乘法器和除法器吗？ 加法和减法8 位二进制加法器四位二进制加法器 将两个四位二进制加法器串联起来，我们就能得到一个 8 位的二进制加法器。也就是说，我们想要相加的二进制数，其范围是从 0000 0000 到 1111 1111，即十进制的 0 到 255。两个 8 位二进制数的和最大可为 1 1111 1110，即 510。 减法与借位 当你确信继电器连接到一起真的可以实现二进制加法的时候，你可能会问:『那么如何实现减法呢？』提出这样的问题并不是说你在没事找事，而实际上这表明你是相当有观察力的。加法和减法在某些方面相互补充，但在机制方面这两个运算则是不同的。加法是始终从两个加数的最右列向最左列进行计算的。每一列的进位加到下一列中。在减法中没有进位，而是有借位——一种与加法存在本质区别的麻烦机制。 例如，我们来看一个典型的借位减法的题目： 253 -176 ---- ??? 结果等于多少呢？ 要想计算结果，首先从最右列着手。我们看到，6 是大于 3 的，因此从 5 借 1，再用 13 减去 6，得到结果为 7。由于我们已经在 5 上借了 1，因此，现在实际上那一位是 4，而 4 是小于 7 的，因此继续从 2 借 1，14 减 7 结果为 7。由于 2 借了 1，实际上这一位是 1，从 1 中减去 1，结果为 0。因此，最后结果应为 77 253 -176 ---- 77 如何才能通过一连串逻辑门来实现这个反逻辑呢？然而，我们并不打算这样做。相反，我们打算利用一个小技巧来让减法不涉及借位。 模 在日常生活当中，如果你仔细观察的话会发现:把某物体左转 90 度，和右转 270 度，在不考虑圈数的条件下，最终的效果是相同的；把分针顺时针拨 20 分钟，和逆时针拨 40 分钟，在不考虑时针的条件下，效果也是相同的；把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，效果也是相同的；………上述几组数字，有这样的关系： 90 + 270 = 360 20 + 40 = 60 25 + 75 = 100式中的 360、60 和 100，就是『模』。 自定义编码 让我们来想一想。通常用来表示正数和负数的方法，其好处就在于能表示所有的正数、负数。我们将 0 想象为这个无限延伸的序列的中点。这个序列中正数沿着一个方向延伸，而负数则按照另一个方向延伸: ...-10000, -9999...-3, -2, -1, 0, 1, 2, 3...9999, 10000... 但是，如果我们并不需要无限大或无限小的数，而且在开始的时候我们就可以预知所使用的数字的范围，那情况就有所不同了。 以支票账户为例，这里人们通常会遇到负数。假设我的账户余额小于 500 美元，并且银行给了我们 500 美元的无息预支额度，意思就是账户余额数值应该是一个在 499 美元到 -500 美元之间的数。假设我们不会一次取出 500 美元，我们也不会支出多于 500 美元的金额，这里我们用到的只是美元，不涉及美分。这些假设表明账户能处理的额度是介于 -500 到 499 之间，总共 1000 个数，而我们只用三位十进制数就可以表示所有需要的数字。我们并不需要用到从500 到 999 之间的正数，因为我们所需要的数的最大值为 499。因此从 500 到 999 的三位数可以用来表示负数。具体情况如下： 用 500 表示 -500 用 501 表示 -499 用 502 表示 -498 ...... 用 998 表示 -2 用 999 表示 -1 用 000 表示 0 用 001 表示 1 用 002 表示 2 ...... 用 497 表示 497 用 498 表示 498 用 499 表示 499 也就是说，以 5, 6, 7, 8 或 9 开头的三位数实际上表示的都是负数，而不是把数字写成这样： —500, -499, -498...-4, -3, -2, —1, 0, 1, 2, 3, 4...497, 498, 499 用这种表示法，我们可以将它们写成： 500, 501 ,502...996, 997, 998, 999，000, 001, 002, 003, 004...497, 498, 499 注意，这就形成了一个循环排序。最小的负数(500)看起来像是最大正数(499)的延续。而数字 999 (实际上是 -1)是比 0 小 1 的第一个负数。如果我们在 999 上加 1,通常会得到 1000。由于我们处理的是三位数，这个结果实际上就是 000。这种标记方法称为 10 的补数(ten’s complement)为了将三位负数转化为 10 的补数，我们用 999 减去它再加 1。也就是说，对 10 求补数就是对 9 的补数再加 1。例如想要得到 -255 对 10 的补数，用 999 减去 255 得到 744, 然后再加 1, 得到 745。你可能听说过：『减一个数就等于加一个负数。』你可能会回答：『实际上还是减去了这个数。』然而，利用 10 的补数，我们将不会再用到减法。所有的步骤都用加法来进行。 那么回到我们的 8 位二进制数，如果我们这样编码: 二进制数 十进制数 1000 0000 -128 1000 0001 -127 1000 0010 -126 1000 0011 -125 … … 1111 1101 -3 1111 1110 -2 1111 1111 -1 0000 0000 0 0000 0001 1 0000 0010 2 … … 0111 1101 125 0111 1110 126 0111 1111 127 注: 在这里模为 1 0000 0000，即 256。 这个编码为我们提供了一种不用负号就能表示正负数的方法。同样也让我们自由地将正数和负数用加法法则相加。例如，将 127 和 -1 等价的两个二进制数相加。利用上面的表格，可以简单写为: 127 0111 1111 - 1 &lt;=&gt; + 1111 1111 ---- --------- 126 1 0111 1110 ，忽略最左边的进位 1，最后结果为 126。 或 127 0111 1111 -128 &lt;=&gt; + 1000 0000 ---- --------- -1 1111 1111，结果为 -1。 要注意的是，这里涉及了上溢和下溢情况，即结果大于 127 或小于 -128。例如，将 125 与它自身相加 125 0111 1101 +125 &lt;=&gt; + 0111 1101 ---- --------- 250 1111 1010 ，结果为 -6，出现上溢。 将 -125 与它本身相加也会出现相同的情况。 -125 1000 0011 -125 &lt;=&gt; + 1000 0011 ---- --------- -250 1 0000 0110 ，结果为 6，出现下溢。 现在，二进制数可以有两种不同的使用方法。二进制数可以是有符号的，也可以是无符号的。无符号的 8 位二进制数所表示的范围是 0 ~ 255。有符号的 8 位二进制数表示的范围是 -128 ~ 127。无论是有符号的还是无符号的，数字本身是无法表示的。例如，如果有一个人问:『有一个 8 位二进制数，值为 10110110。它相当于十进制的多少？』你必须先问:『它是有符号数还是无符号数？它可能为 -74 或 182。』这就是二进制的麻烦之处，它们只是一些 0 和 1，本身并没有任何含义。 乘法和除法乘法乘法 &lt;=&gt; 连续的加法 除法除法 &lt;=&gt; 连续的减法 &lt;=&gt; 连续的加法 扩展Q1这时假如有人问你：Java 中值为 -2 的 int 型变量在内存中的后 8 位是多少？ 我们仔细审一下这个题目，发现其中其实隐含了两个问题: java 中『基本数据类型』在内存中分别用几位表示 负数在计算机中如何编码 下面我们就来一一解答。 A1java 中『基本数据类型』在内存中分别用几位表示 类型名称 类型定义 取值范围 boolean 布尔值，作二元判断 true，false char 16 位 Unicode 字符 Unicode 字符列表 byte 8 位有符号整数 最小值 -128，最大值 127 short 16 位有符号整数 最小值 -32768，最大值 32767 int 32 位有符号整数 最小值 -2147483648（-2³¹），最大值 2147483647（2³¹-1） long 64 位有符号整数 -2⁶³ ~ 2⁶³-1 float 32 位浮点数 IEEE_754 double 64 位浮点数 IEEE_754 Java 中所有数值类型都有正负号，所以不要去寻找无符号的数值类型。 负数在计算机中如何编码8 位有符号数可表示数值范围：-2⁷ ~ 2⁷-1，即 10000000 ~ 0111111132 位有符号数可表示数的范围： -2³¹ ~ 2³¹-1，即 10000000 00000000 00000000 00000000 ~ 01111111 11111111 11111111 11111111。 所以 -2 在内存中表示应为: 11111111 11111111 11111111 11111110。 代码验证12345678910/** * 负数在内存中的二进制表示 * */public class NegativeNumberInMemory &#123; public static void main(String[] args) &#123; int i = -2; System.out.println(Integer.toBinaryString(i)); &#125;&#125; 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 原码、反码和补码 数据类型 Unicode 字符列表 IEEE_754 Think in Java]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>四则运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat + servlet + jsp 开发登录页面实例]]></title>
    <url>%2F2018%2F01%2F13%2Ftomcat-servlet-jsp-%E5%BC%80%E5%8F%91%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[大家在浏览网站时，都遇到过需要输入用户名和密码的情况，然后网站会对你的输入信息进行校验。如果用户名密码正确，接下来你就可以正常访问受限资源了。反之，网站就会给你相应的错误提示。今天我们就用 tomcat + servlet 和一点点的 jsp 来编写简单的登录页面。 概念 Tomcat 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet 容器，按照 Sun MicroSystems 提供的技术规范，实现了对 Servlet 和 JavaServer Page（JSP）的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web server；这两个 HTTP web server 不是捆绑在一起的。Apache Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。 Servlet 是一个在 Web 服务器中运行的小型 Java 程序。Servlet 的接收和响应来自Web客户端的请求，通常通过 HTTP(超文本传输协议)。 JSP（全称 Java Server Pages）是由 Sun MicroSystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的 Web 网页的技术标准。JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于 HTTP 的应用程序。JSP 使 Java 代码和特定的预定义动作可以嵌入到静态页面中。JSP 句法增加了被称为 JSP 动作的 XML 标签，它们用来调用内建功能。另外，可以创建 JSP 标签库，然后像使用标准 HTML 或 XML 标签一样使用它们。标签库提供了一种和平台无关的扩展服务器性能的方法。JSP 被 JSP 编译器编译成 Java Servlets。一个 JSP 编译器可以把 JSP 编译成 Java 代码写的 servlet 然后再由 Java 编译器来编译成机器码，也可以直接编译成二进制码。 实现登录流程图 代码项目结构 LoginInfo1234567891011121314151617181920212223242526package entity;/** * 登录信息 */public class LoginInfo &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; LoginServlet1234567891011121314151617181920212223242526272829303132333435363738394041package servlet;import entity.LoginInfo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 登录servlet */public class LoginServlet extends HttpServlet &#123; private static final String USERNAME = "admin"; private static final String PASSWORD = "admin"; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //让doGet执行与doPost相同操作 System.out.println("doGet方法被执行.."); doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("doPost方法被执行.."); LoginInfo loginInfo = new LoginInfo(); String username = req.getParameter("username"); String password = req.getParameter("password"); loginInfo.setUsername(username); loginInfo.setPassword(password); //判断用户名和密码是否正确 if (USERNAME.equals(loginInfo.getUsername()) &amp;&amp; PASSWORD.equals(loginInfo.getPassword())) &#123; resp.sendRedirect(req.getContextPath() + "/login_success.jsp"); &#125; else &#123; resp.sendRedirect(req.getContextPath() + "/login_fail.jsp"); &#125; &#125;&#125; web.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; login.jsp12345678910111213&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/servlet/LoginServlet"&gt; 用户名: &lt;input type="text" name="username"&gt;&lt;br&gt; 密码: &lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login_fail.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录失败&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录失败，请检查用户名和密码!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; login_success.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;恭喜你，登录成功!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 登录界面 运行结果 本文引自 JAVA遇见HTML——Servlet篇 java 学习总结 Apache Tomcat Java Servlet JSP]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年会街舞纪实]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%B9%B4%E4%BC%9A%E8%A1%97%E8%88%9E%E7%BA%AA%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[不知道是上周几，公司年会节目抽签，郭大侠一下子就给我们技术部抽中了舞蹈。于上周五晚上本人就被内定成了年会街(ga)舞成员，也不知郭大侠是否知情，我在校期间也曾报过一个学期的健身街(ga)舞课。从这周一(1 月 8 号)开始，我开始了紧张而刺激的街(ga)舞学习。 2018-01-08 23:10练舞第一天。 大家利用 12:00 至 13:00 这一个小时的午休时间开始了第一次年会街(ga)舞练习。因为是第一次练习，许多小伙伴还有点羞涩，没有解放出天性。不过随着大家一起练习次数的增加，应该会越来越棒的，加油! 2018-01-09 22:41练舞第二天。 除了继续利用中午的一个小时，晚上大家在李教练的指导下又继续加练了一个小时。感觉进度应该没问题，现在只剩下年会时跳的到底是街舞还是街(ga)舞的问题了。 2018-01-10 23:23练舞第三天。 同昨天一样的训练时间，不过大家的热情明显高涨了不少。keep going! 2018-01-11 23:25练舞第四天。 由于中午练习对下午的工作的影响有点大，所以就只在晚上练习了。好消息是大家在今天已经完成了前半段的学习，明天开始后半段的学习。 2018-01-13 00:23练舞第五天。 今晚练了后半段的第一、二节。这样只剩下最后一节动作了。 2018-01-13 16:44练舞第六天。 由于明天是周日，所以今天也休息一天，但教练说下周就要辛苦一点了。 2018-01-15 20:39练舞第七天。 今天由于刷数据的原因，上去练习的时间缩短了，导致学习效果不佳。教练教的动作都没有完全掌握，明天要把这部分补上。 2018-01-16 21:54练舞第八天。 今天终于把所有内容都学完了，跟着教练也能勉强做完一整套动作。明天开始就是不断的练习了。 2018-01-17 20:56练舞第九天。 今天男生都去参加了”农分期大牛成长营”第一期的会议(17:40 ~ 18:40)，所以练习取消。这样一来本周就只剩下明天一天的练习时间了，而下周一就要出排练视频。所以明天加油吧！ 2018-01-18 20:17练舞第十天。 今天开始跟音乐了，发现几个问题。 动作还不太熟练 整体节奏不一致 人员不齐，无法排练队形 下周开始一个一个的解决上述问题。fighting! 2018-01-22 22:01练舞第十一天。 今天发现一个新的问题：村花同时是年会主持人，从今天开始她要参加主持人的排练。这样两个练习时间就有冲突。我的建议是：给村花预留一个位置，其它的人先把队形排练好，剩下村花再找时间单独给她排练一下，完美。 2018-01-23 21:47练舞第十二天。 村花今天也参加了队形的排练，所以队形大体上已经编排完成。但由于没有视频反馈，导致不太清楚整体上是否统一和协调。明天需要拍个视频给自己看看。 2018-01-24 19:11练舞第十三天。 今天小渊(撸代码)和村花(准备述职)都没有参加排练。大家勉强能跟上音乐了，就是还有部分动作跟不上节奏。明天人应该可以到齐吧。 2018-01-25 22:04练舞第十四天。 今天杨洋和佳欣没有参加排练，于是大家跟着音乐把动作又熟悉了几遍。不过，剩余的排练时间不多了。 2018-01-26 20:51练舞第十五天。 今天大家又跟着教练和音乐熟悉了几遍动作，感觉不错。加油。 2018-01-29 36:20练舞第十六天。 总部所有的会议室被占，今天的练习取消。 2018-01-30 12:20练舞第十七天。 明天就要上台了，今天上午大家又一起排练了几遍。晚上 18:30 到 21:00 大家在总部把所有节目都彩排一遍。 2018-01-30 22:28练舞第十八天。 明天，丑媳妇终于要见公婆了。回想这 1 月 8 号就开始的练习之旅，感触颇多。 我们从开始的拘谨、茫然、闷骚，到现在的开放、自信、外骚，谁知道我们经历了什么!不怕大家笑话，其实我从小就觉得跳街舞的人特帅，一直想着什么时候自己也能在大家面前表演一段完整的街舞。为此，大学期间我也曾报过一个学期的街舞课，但结果只拿了一个 B。说来也巧，这时郭星刚好指定我为”年会街舞成员”。当时心想，那就最后再试一遍吧，不管自己能不能通过这次的筛选，这可能是我最后的圆梦机会了。这 18 天来，大家每天都坚持抽出一个半小时练舞，没有你们的坚持和陪伴，像我，今生应该就与舞台绝缘了吧。谢谢你们给我的这个机会！明天我们什么都不要管，只需要跳好自己的舞蹈，相信结果一定不会让大家失望的。明天加油！ ps: 再次感谢一直都很认真负责的李小晴教练。 明天第二排的小伙伴记得和教练站紧一点，不然最后两排的小伙伴可能会被遮挡住。 2018-01-31 22:33练舞第十九天。 『International 秧歌 show』——有你们真好！ The End?]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>年会</tag>
        <tag>街舞</tag>
        <tag>ga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 上如何搭建个人博客]]></title>
    <url>%2F2017%2F12%2F31%2Fmac%20%E4%B8%8A%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[最初对个人博客有印象，就是阮一峰的个人博客。当时是在搜索 互联网协议入门 这篇文章的时候，发现原来还可以这么玩。随后在和黑牛的一次谈话中，他问我:2017 年就快要过去了，今年的总结写了吗？这才反应过来，2017 年已经到末尾了。于是就有了想写点东西，留作以后回忆的索引，搭建个人博客也就顺理成章了。 大道三千，我走直线利用 Hexo + Github Pages 来搭建个人博客 或自行 google Hexo什么是 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 HexoHexo的安装在其 官方文档 中有很详细的说明。 校验cd &lt;hexo 的安装目录&gt;hexo ghexo s 现在我们打开 http://localhost:4000/ 已经可以看到一篇内置的blog了。 进阶自己切换 hexo 主题，本人使用的是 Next 主题。 Github Pages注册 Github 账号进入 Github 网站，按照提示进行注册并登陆。 创建 Github Pages 仓库登录完成之后，在你的主页点击图标 New repository 创建一个新的版本库，因为我们是使用 Github Pages 去搭建我们的静态博客，所以 repository 的名称格式 你的用户名 + .github.io。例如：我的用户名是：huminxicn，那么 repository 的名字应该是： huminxicn.github.io 。因为之后你将要访问的你的博客地址就是： https://huminxicn.github.io 。 至此，Github 账号创建完成，Github Pages 所需要的 repository 也创建好了。 进阶自己购买域名，然后再让 Github Pages 解析到此域名就行。Learn more 关联 Hexo 与 Github Pages配置 SSH检查是否已经存在 ssh key cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用 git。否则，可以看到如下的目录结构 生成新的 SSH Keyssh-keygen -t rsa -C &quot;&lt;你常用的邮箱地址&gt;&quot; 输入命令回车之后会提示你输入一些东西，不用管，一直回车到底就好了。然后你的 ~/.ssh 目录下就会生成两个文件 id_rsa 和 id_rsa.pub 。 配置 Github打开你的 Github -&gt; Settings -&gt; SSH and GPG Keys 。然后点击 New SSH Key 创建一个新的SSH Key。 Title 可以用你的计算机名，可以用以区分。将 id_rsa.pub 文件中的所有内容复制到 Key 里面。 然后使用下面的命令测试是否可以连接上 Github 。ssh -T git@github.com 将 Hexo 博客部署到 Github Pages先使用下面的命令对 Git 进行初始配置，用来跟踪提交信息 git config --global user.name &quot;&lt;你的名字&gt;&quot;git config --global user.email &quot;&lt;你常用的邮箱地址&gt;&quot; 然后编辑 hexo 根目录下的 _config.yml 文件，设置其中的 deploy 参数，详细请查看 Hexo 官方文档中 部署 部分。 git 地址建议使用 SSH 地址。在上面的参数设置好了之后，使用下面的命令安装 hexo-deployer-git 插件，只有安装了插件之后才可以部署到 Github Pages。 npm install hexo-deployer-git --save 校验安装完插件之后使用下面的命令进行部署： hexo g #生成静态文件hexo d #部署到github 或hexo d -g #部署前生成静态文件 好了，快去访问你的 个人博客 吧！ 本文引自 hexo hexo-cn 域名系统(英文:Domain Name System, 缩写:DNS) 使用Hexo搭建个人博客 如何搭建一个独立博客——简明Github Pages与Hexo教程]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年终总结]]></title>
    <url>%2F2017%2F12%2F24%2F2017%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[时间过得跟狗一样的快! &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; –鲁迅 年度事件转正述职原先预定的是 1 月 13 号的转正述职，后因为开”月需求讨论会”而推迟到了 14 号。我记得来到农分期的第一天就是 23 点钟下班的，黑牛、建国、孟铀、忠泽、嘟嘟 5 位后端小伙伴用实际行动告诉了我什么才叫做自愿加班。当时农人帮系统在重构，整个系统重构了大概 7、8 个月的时间。一直到 2016-10-10 才上线。开始的 3 个月基本上都是自己在看张龙老师的 java 教学视频，收益颇丰。后面的 3 个月才开始慢慢的接触需求开发，在建国的指导下也完成了几个功能的上线。当然，后面用了 N 多版本来修复 bug，N &gt;=10 。在实习期间，老韩的以身作则、黑牛的精益求精、孟铀的诲人不倦、建国的勇往直前、忠泽的积极乐观、嘟嘟的善解人意让我感触良多。因为和你们一比较，发现我一无是处。而且整个技术部的氛围是自由和温暖，这是最打动我的地方。后面也勉强达到了公司的及格线，幸运的留在了公司。 与孟铀合租房子1 月 18 号的时候与孟铀合租了位于南京市栖霞区尧林仙居碧水苑的一套两居室。月租 1900，水电不免，燃气自包。孟铀为了照顾我，他出 1000+每月网费，我 900。当时签的是一年的合同，现在也快要到期续租了。 年中考核具体的考核内容已经记不清了，现在只记得老韩对我说过的一句话:你可以多尝试，做更多的事情。 一周年2017-7-4 号，来农分期一周年了。公司送给我一张写满了同事祝福语的生日祝福卡、一个实用的枕头、一张价值 100 元的苏果购物卡。感谢我期。 青岛之行2017-11-18 至 2017-11-20 号去青岛玩了三天。顺带参加了一下青岛马拉松的 12.3 公里的体验跑。许多人一起跑步，旁边有志愿者帮你准备补给，还帮你喊加油的感觉真不错。明年也要参加至少一次的马拉松。 个人博客2017-11-22 利用 Hexo 框架和 Git Pages 搭建了个人博客。 明年目标 参加一次马拉松(最好是半程或以上) 看完《深入理解计算机系统》和《算法》这两本书 去一趟深圳]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观《你的名字》有感]]></title>
    <url>%2F2017%2F12%2F17%2F%E8%A7%82%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[今天下午第一次看 2016-12-2 号就已经上映的新海诚导演的影片《你的名字》，因为看完电影之后觉得故事还有不清晰的点，所以又去看了一下与电影相关的点评。这才理清楚了其中的故事脉络。 《你的名字》中的几个点，你 get 到了吗三叶其实比立花泷大三岁首先，我们知道随着剧情的推展，男女主角逐渐发现自己在睡梦中发生的事情，实际上并不作是梦，而是现实中确实与对方交换了灵魂。导演新海诚在这边添加了许多轻松幽默的元素，以此来说明两人不断摸索对方到底是谁的过程。最好笑的莫过于灵魂交换到三叶身体里的泷，每天早上醒来双手都放在胸部上面。在两人发现灵魂会互换后也彼此约法三章：要求不管做了什么都要记录下来让对方知道、喜欢体验东京生活的三叶不能乱花泷的钱、三叶要求泷坐姿要坐好、以及不能乱摸她的身体。 在两人渐渐的了解对方后，三叶发现在泷的心中暗恋着一起工作的奥寺前辈，决定帮他一把。知道女人心中喜好的三叶很快的就帮泷促成两人首次的约会，甚至担心约会当天如果灵魂没有交换过来，不擅长跟女人交谈的泷会不知所措，还帮泷制作了约会必胜笔记，笔记的最后写道「约会结束的时候正好可以看到彗星吧」。然而泷看到这句话时抬头看了下傍晚的天空，发现天空中并没有彗星，所以不明白三叶最后说的「约会结束的时候正好可以看到彗星吧」这句话是什么意思。这里正是导演新海诚埋下的第一个伏笔，透露出两人身处的时空其实是不相同的！ 为什么过去的历史可以被改变 三叶、四叶你们听过「结」（日文音译产灵）吗？是一个土地神，古语叫做「结」，这个名称有深远的含义。连接绳线是「结」，连接人与人是「结」，时间的流动也是「结」，全都是神的力量，我们做的结绳也是神的作品。这正是时间流动的体现，聚在一起、成型、扭曲、缠绕，有时又还原、断裂，再次连接，这就是「结」，这就是时间。 这段话正是贯穿整部电影的重点，电影核心剧情就建构在三叶奶奶这里口中所提到的「结」，就字面上表示的意思，时间的流动如同动画中三叶编的结绳拥有类似的性质，是可以还原、断裂甚至再次接上的，这也解释了为什么泷回到彗星坠落前日，可以改变原本要发生的事情，提醒敕使与耶香即将有灾难降临到系守镇。而这样的举动，让原先因为彗星坠落导致时间轴断裂（死亡）的三叶，能再次接续了她的生命。 为什么两人在黄昏之时可以相见站在科学的角度来理解，两人灵魂交换的理论依据其实是「莫比乌斯」环。莫比乌斯循环其实就是将一条长条纸带，其中一头旋转一百八十度后相黏，如果你事先在纸带的正反两面涂上不同颜色，相黏后你会发现不管你拿着笔沿着纸带上哪一个地方开始走，你可以不断的循环反覆经过两个不同的颜色区段。 而这边正反两面的颜色可以想像成：一种颜色是泷的身体，另一种颜色是三叶的身体，在正反两面行走的则是两人的灵魂。每当经过纸带黏接的交接处，原先位于纸带正面的灵魂会跑到背面，背面的会跑到正面，两人灵魂反覆交换的现象正是如同被扭曲连结的「莫比乌斯」循环。 故事前半段老师在黑板前上课时提到的「黄昏之时」，即傍晚非日非夜的这个时段，世界的轮廓会变得模糊，是可能看到非人之物的时段。世界的轮廓可以比喻成纸带相黏的交界处，也是两者唯一有机会短暂交会的时刻。 为什么泷和三叶会忘记对方的名字 前面就是黄泉世界，想要从黄泉世界回到这个世界，必须用你最重要的东西来交换。 很多人觉得泷始终想不起三叶的名字是因为他们的遭遇就像作梦一样，而经由潜意识产生的梦醒来后忘记是理所当然的。不过本片中不仅能看穿泷的灵魂在三叶体内、而且每句话还通通都是重点的”最强角色”三叶奶奶曾说过：要从黄泉世界回归原本的世界需要拿最珍贵的东西交换，而对三叶与泷来说最重要的东西就是两人之间一同经历的那段珍贵回忆，最后虽然泷成功把三叶从另一个世界带回来，但两人也因此都忘了记忆中最重要的彼此与对方的名字。 只有三叶才互换过灵魂吗其实不是的，影片中奶奶和回到三年前三叶身体的泷提到了自己还是少女时也曾做过不可思议的梦，但是有关这个梦的记忆现在却已经消失了，还提到无论是她自己还是三叶的母亲都曾有过类似的经历。且电影的最后也给了四叶成高中生后，抬头望向窗外的一个镜头，暗示了四叶开始了灵魂互换。 本文引自 《你的名字》中隐藏的五个秘密！ 你的名字中的一些暗线故事 有关命中注定和世界的自动修正 附加 点击下载《你的名字》小说 后续同人小说链接]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>你的名字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种基于前后端分离的单点登录实现方案]]></title>
    <url>%2F2017%2F12%2F10%2F%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。相同的，单一注销（single sign-off）就是指，只需要单一的注销动作，就可以结束对于多个系统的访问权限。 单点登录机制一、单系统登录1、http 无状态协议web 应用采用 browser/server 架构，http 作为通信协议。http 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程如下图所示，三次请求/响应对之间没有任何联系。 但这也同时意味着，任何用户都能通过浏览器访问服务器上的资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求(响应合法请求，忽略非法请求)；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 2、会话机制当浏览器第一次请求服务器时，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器根据请求中的会话 id 就知道是不是同一个用户了(注:浏览器第一次请求时服务器还没有创建会话)，这个过程用下图说明，后续请求与第一次请求产生了关联。 服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？你可能会想到两种方式: 拼接在 url 中 cookie 将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式比较低级。那就换浏览器自己来维护这个会话 id 吧，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以 key/value 形式存储，浏览器发送 http 请求时自动附带 cookie 信息。tomcat 会话机制当然也实现了 cookie ，访问 tomcat 服务器时，浏览器中可以看到一个名为 JSESSIONID 的 cookie，这就是 tomcat 会话机制维护的会话id，使用了 cookie 的请求响应过程如下图。 3、登录状态有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下。HttpSession session = request.getSession;session.setAttribute(“isLogin”, true); 用户再次访问时，tomcat 在会话对象中查看登录状态。HttpSession session = request.getSession;session.getAttribute(“isLogin”); 实现了登录状态的浏览器请求服务器模型如下图所示。 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、多系统的复杂性web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样。 web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie。 既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如 “*.baidu.com”，然后将它们的 cookie 域设置为 “baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。然而，可行并不代表好，共享 cookie 的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间；第三，cookie 本身不安全。因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 三、单点登录什么是单点登录？单点登录全称 Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录。 1、登录相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，先由子系统产生临时令牌，然后 sso 认证中心验证用户的用户名密码没问题，最后 sso 认证中心再通知各子系统令牌生效。之后浏览器端可以利用之前就返回的令牌进行受限资源的访问。 下面对上图简要描述 用户访问 nrb 的受限资源，nrb 发现用户未登录，nrb 生成一个 tokenA，并将 tokenA 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，并关联 sessionId 和 userId sso 认证中心通知 nrb 绑定 tokenA 和 userId 并进行保存 sso 认证中心跳转回用户访问的nrb系统 用户利用之前就已经返回的 tokenA 来访问 nrb 的受限资源 用户访问 hades 的受限资源，hades 发现用户未登录，hades 生成一个 tokenB，tokenB 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户已登录 sso 认证中心通知 hades 绑定 tokenB 和 userId 并进行保存 sso 认证中心跳转回用户访问的hades系统 用户利用之前就已经返回的 tokenB 来访问 hades 的受限资源 2、注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明。 sso 认证中心一直监听会话的状态，一旦会话销毁，监听器将通知所有管理系统执行注销操作。 用户向 hades 系统发起注销请求 hades 系统向 sso 认证中心发起注销请求，并将用户的 tokenA 和存储在 cookie 中的 sessionId 当做参数传递 sso 认证中心取出与 sessionId 关联的系统地址和 token sso 认证中心向所有关联系统发起注销请求，并指定需要注销的 token 各关联系统接收 sso 认证中心的注销请求，销毁指定 token sso 认证中心引导用户至登录页面 四、部署图单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以发送令牌、保存令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述。 sso 认证中心与 sso 客户端通信方式有多种，这里以简单好用的 httpClient 为例，web service、rpc、restful api 都可以。 五、实现简要介绍下基于 java 的实现过程，sso 采用客户端/服务端架构，我们先看 sso-client 与 sso-server 要实现的功能（下面：sso 认证中心= sso-server）。 sso-client 拦截子系统未登录用户的请求，生成 token，并将 token、本地 cookie 值和子系统自身地址作为跳转 sso 认证中心的参数进行传递 接收 sso 认证中心通知的 token、userId 并进行保存 通过 token 与用户建立会话 拦截用户注销请求，向 sso 认证中心发送注销请求 接收 sso 认证中心发出的注销请求，注销指定 token sso-server 验证用户的账户信息 创建 session 将 sessionId 与子系统地址及相应的 token，userId 进行关联 与 sso-client 通信发送 token、userId 校验 session 有效性 接受 sso-client 注销请求，注销所有子系统中的 token 引用 单点登录原理与简单实现 HTML色彩]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单线程版本“懒汉模式” &amp; “饿汉模式”懒汉模式 123456789101112131415161718public class Singleton &#123; // 定义一个空的 Singleton 对象引用 SINGLETON private static Singleton SINGLETON = null; // 利用构造器私有化来限制外部使用 new 关键字，进而避免构造出多个实例 private Singleton() &#123; &#125; // 提供外部获取单例对象的方法 public static Singleton getInstance() &#123; // 如果 SINGLETON 还未指向任何一个 Singleton 对象，new 一个 Singleton 对象出来。 if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 对象引用一开始为 null，具体使用的时候才 new 一个对象出来，这种写法属于懒汉模式。 饿汉模式 123456789101112public class Singleton &#123; // 在定义时就直接 new 出单例对象 private static Singleton SINGLETON = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SINGLETON; &#125;&#125; 顾名思义，单例对象一开始就被 new Singleton() 主动构建，不再需要判空操作，这种写法属于饿汉模式。 多线程版本如果上面”懒汉模式”的代码是运行在多线程环境中，就会出现许多问题。最明显的一个，将有可能 new 出多个 Singleton 对象实例。最简单的修复方式是在 getInstance() 方法上加 synchronize 关键字。 123456789101112131415public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; // 方法上加 synchronized 关键字 public synchronized static Singleton getInstance() &#123; if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 但是这样的话，在每次调用 getInstance() 方法的时候都会加锁。 使用 double-checked lock(双检锁) 可以避免在 new 出单例对象之后还对 getInstance() 方法进行加锁。 1234567891011121314151617181920212223public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; // 第一次检查 if (SINGLETON == null) &#123; // new Singleton() 代码块才进行加锁 synchronized (Singleton.class) &#123; // 第二次检查 if (SINGLETON == null) &#123; SINGLETON = new Singleton(); &#125; &#125; &#125; return SINGLETON; &#125;&#125; 本文引自 老生常谈双检锁（DCL） The “Double-Checked Locking is Broken” Declaration]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始造一台自己的加法器]]></title>
    <url>%2F2017%2F11%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%80%A0%E4%B8%80%E5%8F%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如:二进制数乘法器的重要组成部分。 10进制与2进制10的替代品对我们人类而言，10是一个非常重要的数字。10是我们大多数人拥有的手指或脚趾的数目，因为手非常便于计数，于是我们已经适应了这个以10为基数的数字系统(也称为十进制数字系统)。起初也很难再构想出其它的数字系统。 当我们看到数字10的时候，我们不自觉地就想到这个数字代表了下面的这么多个苹果： 10 =   但是，数字10之所以指的是这么多个苹果，其唯一的理由就在于这些苹果的数目与我们手指的数目相同。如果人类的手指不是10根，我们数数的方式就会有所不同，那么10就会是另外一个含义。 同样，数字10还可以代表这么多个苹果： 10 =   或者是这么多个苹果： 10 =   甚至可以是这么多个苹果： 10 =  设想一下: 如果人类像卡通人物一样每只手有4根手指那会怎样呢？ 我们可能就不会想到建立一个以10为基数的数字系统。我们会自然而然地、不可避免地想到建立一个以8为基数的数字系统。我们会称它为八进制数字系统。如果我们的数字系统是以8为基数而建立的，我们就不需要下面这个符号： 9 将这个给卡通人物看的话，他会得到这样的反应：”这是什么？它代表什么？“ 继续思考一下，你会发现我们连这样的一个符号也不会需要： 8 在十进制中，”十”没有特定的符号，因此在八进制中，同样也没有表示”八”的特定符号。十进制中我们的计数方式是：0、1、2、3、4、5、6、7、8、9，然后是10。八进制中我们的计数方式是：0、1、2、3、4、4、5、7，然后是什么呢？我们已经将符号用完了。在这里唯一有意义的只有10，而在这里的正确答案恰恰就是10。在八进制中，7之后的一个数字就是10。但这个“10”代表的并不是人类的手指的数量。在八进制中，“10”代表的是卡通人物手指的数量。 2进制如果我们是海豚呢，那么就必须用两个鳍来计数。这个数字系统称为以2为基数的数字系统(或二进制)。这样的话我们似乎只有两个数字了，分别为0和1。在二进制中，1的下一个数字是10。第一次见似乎有点难以理解，但也不用意外。因为无论使用哪种计数系统，当单个的数字用完时，第一个两位数就是10。 二进制数最大的问题是数字用完的很快! 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1110,1111,10000,10001,… 当然，二进制也有它的优点，比如做加法的时候: 11加法表 + 0 1 0 0 1 1 1 10 乘法比加法还容易，比起小时候背的”99乘法表”不知道简单了多少。 11乘法表 x 0 1 0 0 0 1 0 1 99乘法表 x 1 2 3 4 5 6 7 8 9 1 1 2 2 4 3 3 6 9 4 4 8 12 16 5 5 10 15 20 25 6 6 12 18 24 30 36 7 7 14 21 28 35 42 49 8 8 16 24 32 40 48 56 64 9 9 18 27 36 45 54 63 72 81 电磁铁与继电器电磁铁如果你手头有一根铁棒，那么在上面用细导线绕几百圈，然后接通电流，铁棒就变成了一块磁铁。现在它可以吸引其它的铁块或者钢块(电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象)。断开电流，铁棒将丧失磁性。 图1 中的电路组成元件按顺时针方向依次是 ABCDP 滑动变阻器 E 电磁铁 S 单刀单掷开关 电池 L 电灯泡 电流表 继电器继电器的作用就是通过吸引或弹开衔铁，进而控制另一个电路的通断。 继电器符号和电路图如下所示： 门非门结果与操作数相反。 真值表 NOT 0 1 1 0 符号 电路图 与门两个操作数都为1时结果为1。 真值表 AND 0 1 0 0 0 1 0 1 符号 电路图 或门有一个操作数为1结果就为1。 真值表 OR 0 1 0 0 1 1 1 1 符号 电路图 与非门跟与操作结果相反。 真值表 NAND 0 1 0 1 1 1 1 0 符号 或非门跟或操作相反。 真值表 NOR 0 1 0 1 0 1 0 0 符号 异或门一个操作数为1，另一个操作数为0时，结果才为1。 真值表 XOR 0 1 0 0 1 1 1 0 符号 电路图 二进制加法器 计算二进制数加法与计算十进制数加法非常相似。如果你想让 245 和 673 这两个十进制数相加，你会把这个问题分解为几个简单的步骤。每个步骤只需要将两个十进制数相加，二进制加法也同理。 半加器和全加器加法结果可以拆成两部分，一个是加和结果，另一个是进位结果。二进制加法也可以照下面这个方式进行拆分。 加和表 +加和 0 1 0 0 1 1 1 0 进位表 +进位 0 1 0 0 0 1 0 1 可以利用下面的两个逻辑门来实现上面的结果 异或门 XOR 0 1 0 0 1 1 1 0 与门 AND 0 1 0 0 0 1 0 1 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。因此我们可以将与门和异或门连接在一起来计算两个二进制数(即A和B)的和。 真值表 输入A 输入B 加和输出 进位输出 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 这个被叫做半加器(Half Adder)。之所以被叫半加器是有原因的。它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于1位的。半加器没有做到的是将前一次的加法可能产生的进位位纳入下一次运算。例如，假设我们要将如下两个二进制数相加。 1111 +1111 ----- 11110 我们只能将半加器用于最右面一列的相加：1加1等于0，进位1。对于右面算起的第二列，由于进位位的存在，实际上需要将三个二进制数相加，而随后的每一列的加法都是这样的。随后的每一列二进制数相加都需要将进位位算进来。为了对三个二进制数进行加法运算你，我们需要将两个半加器和一个或门做如下连接。 真值表 进位输入A 输入A 输入B 加和输出 进位输出 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 这个叫做全加器(Full Adder)。我们用如下的符号表示它: 到这里，我们已经迈出了关键的第一步。因为我们可以利用它做2进制的加法：1+1=10！ 多位二进制数相加当然，只能进行一位二进制数相加的加法器的用途实在是太窄了，我们更需要能支持多位二进制数做加法的加法器。答案就是将多个全加器连接起来，组成多位加法器。假设我们将4个全加器连接起来，那么它就能做4位二进制数的加法。如下图所示： 假设有两个4位二进制数A₃A₂A₁A₀和B₃B₂B₁B₀，只需要将它们按位相加，再逐级将低位的进位输出到高位进行计算即可。 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 《穿越计算机的迷雾》]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>加法器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
