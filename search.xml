<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[年会街(ga)舞纪实]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%B9%B4%E4%BC%9A%E8%A1%97-ga-%E8%88%9E%E7%BA%AA%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[不知道是上周几，公司年会节目抽签，郭大侠一下子就给我们技术部抽中了舞蹈。于上周五晚上本人就被内定成了年会街(ga)舞成员，也不知郭大侠是否知情，我在校期间也曾报过一个学期的健身街(ga)舞课。从这周一(1月8号)开始，我开始了紧张而刺激的街(ga)舞学习。 2018-01-08 23:10今天是第一天。 大家利用 12:00 至 13:00 这一个小时的午休时间开始了第一次年会街(ga)舞练习。因为是第一次练习，许多小伙伴还有点羞涩，没有解放出天性。不过随着大家一起练习次数的增加，应该会越来越棒的，加油! 2018-01-09 22:41今天是第二天。 除了继续利用中午的一个小时，晚上大家在李教练的指导下又继续加练了一个小时。感觉进度应该没问题，现在只剩下年会时跳的到底是街舞还是街(ga)舞的问题了。 2018-01-10 23:23今天是第三天。 同昨天一样的训练时间，不过大家的热情明显高涨了不少。keep going! 2018-01-11 23:25今天是第四天。 由于中午练习对下午的工作的影响有点大，所以就只在晚上练习了。好消息是大家在今天已经完成了前半段的学习，明天开始后半段的学习。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>年会</tag>
        <tag>街舞</tag>
        <tag>ga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 上如何搭建个人博客]]></title>
    <url>%2F2017%2F12%2F31%2Fmac%20%E4%B8%8A%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[最初对个人博客有印象，就是阮一峰的个人博客。当时是在搜索 互联网协议入门 这篇文章的时候，发现原来还可以这么玩。随后在和黑牛的一次谈话中，他问我:2017年就快要过去了，今年的总结写了吗？这才反应过来，2017年已经到末尾了。于是就有了想写点东西，留作以后回忆的索引，搭建个人博客也就顺理成章了。 大道三千，我走直线利用 Hexo + Github Pages 来搭建个人博客 或自行 google Hexo什么是 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 HexoHexo的安装在其 官方文档 中有很详细的说明。 校验cd &lt;hexo 的安装目录&gt;hexo ghexo s 现在我们打开 http://localhost:4000/ 已经可以看到一篇内置的blog了。 进阶自己切换 hexo 主题，本人使用的是 Next 主题。 Github Pages注册 Github 账号进入 Github 网站，按照提示进行注册并登陆。 创建 Github Pages 仓库登录完成之后，在你的主页点击图标 New repository 创建一个新的版本库，因为我们是使用 Github Pages 去搭建我们的静态博客，所以 repository 的名称格式 你的用户名 + .github.io。例如：我的用户名是：huminxicn，那么 repository 的名字应该是： huminxicn.github.io 。因为之后你将要访问的你的博客地址就是： https://huminxicn.github.io 。 至此，Github 账号创建完成，Github Pages 所需要的 repository 也创建好了。 进阶自己购买域名，然后再让 Github Pages 解析到此域名就行。Learn more 关联 Hexo 与 Github Pages配置 SSH检查是否已经存在 ssh key cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用 git。否则，可以看到如下的目录结构 生成新的 SSH Keyssh-keygen -t rsa -C &quot;&lt;你常用的邮箱地址&gt;&quot; 输入命令回车之后会提示你输入一些东西，不用管，一直回车到底就好了。然后你的 ~/.ssh 目录下就会生成两个文件 id_rsa 和 id_rsa.pub 。 配置 Github打开你的 Github -&gt; Settings -&gt; SSH and GPG Keys 。然后点击 New SSH Key 创建一个新的SSH Key。 Title 可以用你的计算机名，可以用以区分。将 id_rsa.pub 文件中的所有内容复制到 Key 里面。 然后使用下面的命令测试是否可以连接上 Github 。ssh -T git@github.com 将 Hexo 博客部署到 Github Pages先使用下面的命令对 Git 进行初始配置，用来跟踪提交信息 git config --global user.name &quot;&lt;你的名字&gt;&quot;git config --global user.email &quot;&lt;你常用的邮箱地址&gt;&quot; 然后编辑 hexo 根目录下的 _config.yml 文件，设置其中的 deploy 参数，详细请查看 Hexo 官方文档中 部署 部分。 git 地址建议使用 SSH 地址。在上面的参数设置好了之后，使用下面的命令安装 hexo-deployer-git 插件，只有安装了插件之后才可以部署到 Github Pages。 npm install hexo-deployer-git --save 校验安装完插件之后使用下面的命令进行部署： hexo g #生成静态文件hexo d #部署到github 或hexo d -g #部署前生成静态文件 好了，快去访问你的 个人博客 吧！ 本文引自 hexo hexo-cn 域名系统(英文:Domain Name System, 缩写:DNS) 使用Hexo搭建个人博客 如何搭建一个独立博客——简明Github Pages与Hexo教程]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2017%2F12%2F24%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[时间过得跟狗一样的快! &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; –鲁迅 年度事件转正述职原先预定的是1月13号的转正述职，后因为开”月需求讨论会”而推迟到了14号。我记得来到农分期的第一天就是23点钟下班的，黑牛、建国、孟铀、忠泽、嘟嘟5️位位后端小伙伴用实际行动告诉了我什么才叫做自愿加班。当时农人帮系统在重构，整个系统重构了大概7、8个月的时间。一直到2016-10-10才上线。开始的3个月基本上都是自己在看张龙老师的 java 教学视频，收益颇丰。后面的3个月才开始慢慢的接触需求开发，在建国的指导下也完成了几个功能的上线。当然，后面用了 N 多版本来修复 bug，N &gt;=10 。在实习期间，老韩的以身作则、黑牛的精益求精、孟铀的诲人不倦、建国的勇往直前、忠泽的积极乐观、嘟嘟的善解人意让我感触良多。因为和你们一比较，发现我一无是处。而且整个技术部的氛围是自由和温暖，这是最打动我的地方。后面也勉强达到了公司的及格线，幸运的留在了公司。 与孟铀合租房子1月18号的时候与孟铀合租了位于南京市栖霞区尧林仙居碧水苑的一套两居室。月租1900，水电不免，燃气自包。孟铀为了照顾我，他出1000+每月网费，我900。当时签的是一年的合同，现在也快要到期续租了。 年中考核具体的考核内容已经记不清了，现在只记得老韩对我说过的一句话:你可以多尝试，做更多的事情。 一周年2017-7-4 号，来农分期一周年了。公司送给我一张写满了同事祝福语的生日祝福卡、一个实用的枕头、一张价值100元的苏果购物卡。感谢我期。 青岛之行2017-11-18 至 2017-11-20 号去青岛玩了三天。顺带参加了一下青岛马拉松的12.3公里的体验跑。许多人一起跑步，旁边有志愿者帮你准备补给，还帮你喊加油的感觉真不错。明年也要参加至少一次的马拉松。 个人博客2017-11-22 利用 Hexo 框架和 Git Pages 搭建了个人博客。 明年目标 参加一次马拉松(最好是半程或以上) 看完《深入理解计算机系统》和《算法》这两本书 去一趟深圳]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观《你的名字》有感]]></title>
    <url>%2F2017%2F12%2F17%2F%E8%A7%82%E3%80%8A%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E3%80%8B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[今天下午第一次看 2016-12-2 号就已经上映的新海诚导演的影片《你的名字》，因为看完电影之后觉得故事还有不清晰的点，所以又去看了一下与电影相关的点评。这才理清楚了其中的故事脉络。 《你的名字》中的几个点，你 get 到了吗三叶其实比立花泷大三岁首先，我们知道随着剧情的推展，男女主角逐渐发现自己在睡梦中发生的事情，实际上并不作是梦，而是现实中确实与对方交换了灵魂。导演新海诚在这边添加了许多轻松幽默的元素，以此来说明两人不断摸索对方到底是谁的过程。最好笑的莫过于灵魂交换到三叶身体里的泷，每天早上醒来双手都放在胸部上面。在两人发现灵魂会互换后也彼此约法三章：要求不管做了什么都要记录下来让对方知道、喜欢体验东京生活的三叶不能乱花泷的钱、三叶要求泷坐姿要坐好、以及不能乱摸她的身体。 在两人渐渐的了解对方后，三叶发现在泷的心中暗恋着一起工作的奥寺前辈，决定帮他一把。知道女人心中喜好的三叶很快的就帮泷促成两人首次的约会，甚至担心约会当天如果灵魂没有交换过来，不擅长跟女人交谈的泷会不知所措，还帮泷制作了约会必胜笔记，笔记的最后写道「约会结束的时候正好可以看到彗星吧」。然而泷看到这句话时抬头看了下傍晚的天空，发现天空中并没有彗星，所以不明白三叶最后说的「约会结束的时候正好可以看到彗星吧」这句话是什么意思。这里正是导演新海诚埋下的第一个伏笔，透露出两人身处的时空其实是不相同的！ 为什么过去的历史可以被改变 三叶、四叶你们听过「结」（日文音译产灵）吗？是一个土地神，古语叫做「结」，这个名称有深远的含义。连接绳线是「结」，连接人与人是「结」，时间的流动也是「结」，全都是神的力量，我们做的结绳也是神的作品。这正是时间流动的体现，聚在一起、成型、扭曲、缠绕，有时又还原、断裂，再次连接，这就是「结」，这就是时间。 这段话正是贯穿整部电影的重点，电影核心剧情就建构在三叶奶奶这里口中所提到的「结」，就字面上表示的意思，时间的流动如同动画中三叶编的结绳拥有类似的性质，是可以还原、断裂甚至再次接上的，这也解释了为什么泷回到彗星坠落前日，可以改变原本要发生的事情，提醒敕使与耶香即将有灾难降临到系守镇。而这样的举动，让原先因为彗星坠落导致时间轴断裂（死亡）的三叶，能再次接续了她的生命。 为什么两人在黄昏之时可以相见站在科学的角度来理解，两人灵魂交换的理论依据其实是「莫比乌斯」环。莫比乌斯循环其实就是将一条长条纸带，其中一头旋转一百八十度后相黏，如果你事先在纸带的正反两面涂上不同颜色，相黏后你会发现不管你拿着笔沿着纸带上哪一个地方开始走，你可以不断的循环反覆经过两个不同的颜色区段。 而这边正反两面的颜色可以想像成：一种颜色是泷的身体，另一种颜色是三叶的身体，在正反两面行走的则是两人的灵魂。每当经过纸带黏接的交接处，原先位于纸带正面的灵魂会跑到背面，背面的会跑到正面，两人灵魂反覆交换的现象正是如同被扭曲连结的「莫比乌斯」循环。 故事前半段老师在黑板前上课时提到的「黄昏之时」，即傍晚非日非夜的这个时段，世界的轮廓会变得模糊，是可能看到非人之物的时段。世界的轮廓可以比喻成纸带相黏的交界处，也是两者唯一有机会短暂交会的时刻。 为什么泷和三叶会忘记对方的名字 前面就是黄泉世界，想要从黄泉世界回到这个世界，必须用你最重要的东西来交换。 很多人觉得泷始终想不起三叶的名字是因为他们的遭遇就像作梦一样，而经由潜意识产生的梦醒来后忘记是理所当然的。不过本片中不仅能看穿泷的灵魂在三叶体内、而且每句话还通通都是重点的”最强角色”三叶奶奶曾说过：要从黄泉世界回归原本的世界需要拿最珍贵的东西交换，而对三叶与泷来说最重要的东西就是两人之间一同经历的那段珍贵回忆，最后虽然泷成功把三叶从另一个世界带回来，但两人也因此都忘了记忆中最重要的彼此与对方的名字。 只有三叶才互换过灵魂吗其实不是的，影片中奶奶和回到三年前三叶身体的泷提到了自己还是少女时也曾做过不可思议的梦，但是有关这个梦的记忆现在却已经消失了，还提到无论是她自己还是三叶的母亲都曾有过类似的经历。且电影的最后也给了四叶成高中生后，抬头望向窗外的一个镜头，暗示了四叶开始了灵魂互换。 本文引自 《你的名字》中隐藏的五个秘密！ 你的名字中的一些暗线故事 有关命中注定和世界的自动修正 附加 点击下载《你的名字》小说 后续同人小说链接]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>你的名字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种基于前后端分离的单点登录实现方案]]></title>
    <url>%2F2017%2F12%2F10%2F%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。相同的，单一注销（single sign-off）就是指，只需要单一的注销动作，就可以结束对于多个系统的访问权限。 单点登录机制一、单系统登录1、http 无状态协议web 应用采用 browser/server 架构，http 作为通信协议。http 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程如下图所示，三次请求/响应对之间没有任何联系。 但这也同时意味着，任何用户都能通过浏览器访问服务器上的资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求(响应合法请求，忽略非法请求)；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 2、会话机制当浏览器第一次请求服务器时，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器根据请求中的会话 id 就知道是不是同一个用户了(注:浏览器第一次请求时服务器还没有创建会话)，这个过程用下图说明，后续请求与第一次请求产生了关联。 服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？你可能会想到两种方式: 拼接在 url 中 cookie 将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式比较低级。那就换浏览器自己来维护这个会话 id 吧，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以 key/value 形式存储，浏览器发送 http 请求时自动附带 cookie 信息。tomcat 会话机制当然也实现了 cookie ，访问 tomcat 服务器时，浏览器中可以看到一个名为 JSESSIONID 的 cookie，这就是 tomcat 会话机制维护的会话id，使用了 cookie 的请求响应过程如下图。 3、登录状态有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下。HttpSession session = request.getSession;session.setAttribute(“isLogin”, true); 用户再次访问时，tomcat 在会话对象中查看登录状态。HttpSession session = request.getSession;session.getAttribute(“isLogin”); 实现了登录状态的浏览器请求服务器模型如下图所示。 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、多系统的复杂性web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样。 web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie。 既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如 “*.baidu.com”，然后将它们的 cookie 域设置为 “baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。然而，可行并不代表好，共享 cookie 的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间；第三，cookie 本身不安全。因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 三、单点登录什么是单点登录？单点登录全称 Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录。 1、登录相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，先由子系统产生临时令牌，然后 sso 认证中心验证用户的用户名密码没问题，最后 sso 认证中心再通知各子系统令牌生效。之后浏览器端可以利用之前就返回的令牌进行受限资源的访问。 下面对上图简要描述 用户访问 nrb 的受限资源，nrb 发现用户未登录，nrb 生成一个 tokenA，并将 tokenA 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，并关联 sessionId 和 userId sso 认证中心通知 nrb 绑定 tokenA 和 userId 并进行保存 sso 认证中心跳转回用户访问的nrb系统 用户利用之前就已经返回的 tokenA 来访问 nrb 的受限资源 用户访问 hades 的受限资源，hades 发现用户未登录，hades 生成一个 tokenB，tokenB 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户已登录 sso 认证中心通知 hades 绑定 tokenB 和 userId 并进行保存 sso 认证中心跳转回用户访问的hades系统 用户利用之前就已经返回的 tokenB 来访问 hades 的受限资源 2、注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明。 sso 认证中心一直监听会话的状态，一旦会话销毁，监听器将通知所有管理系统执行注销操作。 用户向 hades 系统发起注销请求 hades 系统向 sso 认证中心发起注销请求，并将用户的 tokenA 和存储在 cookie 中的 sessionId 当做参数传递 sso 认证中心取出与 sessionId 关联的系统地址和 token sso 认证中心向所有关联系统发起注销请求，并指定需要注销的 token 各关联系统接收 sso 认证中心的注销请求，销毁指定 token sso 认证中心引导用户至登录页面 四、部署图单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以发送令牌、保存令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述。 sso 认证中心与 sso 客户端通信方式有多种，这里以简单好用的 httpClient 为例，web service、rpc、restful api 都可以。 五、实现简要介绍下基于 java 的实现过程，sso 采用客户端/服务端架构，我们先看 sso-client 与 sso-server 要实现的功能（下面：sso 认证中心= sso-server）。 sso-client 拦截子系统未登录用户的请求，生成 token，并将 token、本地 cookie 值和子系统自身地址作为跳转 sso 认证中心的参数进行传递 接收 sso 认证中心通知的 token、userId 并进行保存 通过 token 与用户建立会话 拦截用户注销请求，向 sso 认证中心发送注销请求 接收 sso 认证中心发出的注销请求，注销指定 token sso-server 验证用户的账户信息 创建 session 将 sessionId 与子系统地址及相应的 token，userId 进行关联 与 sso-client 通信发送 token、userId 校验 session 有效性 接受 sso-client 注销请求，注销所有子系统中的 token 引用 单点登录原理与简单实现 HTML色彩]]></content>
      <categories>
        <category>编程实践</category>
      </categories>
      <tags>
        <tag>单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单线程版本“懒汉模式” &amp; “饿汉模式”懒汉模式 123456789101112131415161718public class Singleton &#123; // 定义一个空的 Singleton 对象引用 SINGLETON private static Singleton SINGLETON = null; // 利用构造器私有化来限制外部使用 new 关键字，进而避免构造出多个实例 private Singleton() &#123; &#125; // 提供外部获取单例对象的方法 public static Singleton getInstance() &#123; // 如果 SINGLETON 还未指向任何一个 Singleton 对象，new 一个 Singleton 对象出来。 if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 对象引用一开始为 null，具体使用的时候才 new 一个对象出来，这种写法属于懒汉模式。 饿汉模式 123456789101112public class Singleton &#123; // 在定义时就直接 new 出单例对象 private static Singleton SINGLETON = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SINGLETON; &#125;&#125; 顾名思义，单例对象一开始就被 new Singleton() 主动构建，不再需要判空操作，这种写法属于饿汉模式。 多线程版本如果上面”懒汉模式”的代码是运行在多线程环境中，就会出现许多问题。最明显的一个，将有可能 new 出多个 Singleton 对象实例。最简单的修复方式是在 getInstance() 方法上加 synchronize 关键字。 123456789101112131415public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; // 方法上加 synchronized 关键字 public synchronized static Singleton getInstance() &#123; if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 但是这样的话，在每次调用 getInstance() 方法的时候都会加锁。 使用 double-checked lock(双检锁) 可以避免在 new 出单例对象之后还对 getInstance() 方法进行加锁。 1234567891011121314151617181920212223public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; // 第一次检查 if (SINGLETON == null) &#123; // new Singleton() 代码块才进行加锁 synchronized (Singleton.class) &#123; // 第二次检查 if (SINGLETON == null) &#123; SINGLETON = new Singleton(); &#125; &#125; &#125; return SINGLETON; &#125;&#125; 本文引自 老生常谈双检锁（DCL） The “Double-Checked Locking is Broken” Declaration]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始造一台自己的加法器]]></title>
    <url>%2F2017%2F11%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%80%A0%E4%B8%80%E5%8F%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如:二进制数乘法器的重要组成部分。 10进制与2进制10的替代品对我们人类而言，10是一个非常重要的数字。10是我们大多数人拥有的手指或脚趾的数目，因为手非常便于计数，于是我们已经适应了这个以10为基数的数字系统(也称为十进制数字系统)。起初也很难再构想出其它的数字系统。 当我们看到数字10的时候，我们不自觉地就想到这个数字代表了下面的这么多个苹果： 10 =   但是，数字10之所以指的是这么多个苹果，其唯一的理由就在于这些苹果的数目与我们手指的数目相同。如果人类的手指不是10根，我们数数的方式就会有所不同，那么10就会是另外一个含义。 同样，数字10还可以代表这么多个苹果： 10 =   或者是这么多个苹果： 10 =   甚至可以是这么多个苹果： 10 =  设想一下: 如果人类像卡通人物一样每只手有4根手指那会怎样呢？ 我们可能就不会想到建立一个以10为基数的数字系统。我们会自然而然地、不可避免地想到建立一个以8为基数的数字系统。我们会称它为八进制数字系统。如果我们的数字系统是以8为基数而建立的，我们就不需要下面这个符号： 9 将这个给卡通人物看的话，他会得到这样的反应：”这是什么？它代表什么？“ 继续思考一下，你会发现我们连这样的一个符号也不会需要： 8 在十进制中，”十”没有特定的符号，因此在八进制中，同样也没有表示”八”的特定符号。十进制中我们的计数方式是：0、1、2、3、4、5、6、7、8、9，然后是10。八进制中我们的计数方式是：0、1、2、3、4、4、5、7，然后是什么呢？我们已经将符号用完了。在这里唯一有意义的只有10，而在这里的正确答案恰恰就是10。在八进制中，7之后的一个数字就是10。但这个“10”代表的并不是人类的手指的数量。在八进制中，“10”代表的是卡通人物手指的数量。 2进制如果我们是海豚呢，那么就必须用两个鳍来计数。这个数字系统称为以2为基数的数字系统(或二进制)。这样的话我们似乎只有两个数字了，分别为0和1。在二进制中，1的下一个数字是10。第一次见似乎有点难以理解，但也不用意外。因为无论使用哪种计数系统，当单个的数字用完时，第一个两位数就是10。 二进制数最大的问题是数字用完的很快! 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1110,1111,10000,10001,… 当然，二进制也有它的优点，比如做加法的时候: 11加法表 + 0 1 0 0 1 1 1 10 乘法比加法还容易，比起小时候背的”99乘法表”不知道简单了多少。 11乘法表 x 0 1 0 0 0 1 0 1 99乘法表 x 1 2 3 4 5 6 7 8 9 1 1 2 2 4 3 3 6 9 4 4 8 12 16 5 5 10 15 20 25 6 6 12 18 24 30 36 7 7 14 21 28 35 42 49 8 8 16 24 32 40 48 56 64 9 9 18 27 36 45 54 63 72 81 电磁铁与继电器电磁铁如果你手头有一根铁棒，那么在上面用细导线绕几百圈，然后接通电流，铁棒就变成了一块磁铁。现在它可以吸引其它的铁块或者钢块(电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象)。断开电流，铁棒将丧失磁性。 继电器继电器的作用就是通过吸引或弹开衔铁，进而控制另一个电路的通断。 继电器符号和电路图如下所示： 门非门结果与操作数相反。 真值表 NOT 0 1 1 0 符号 电路图 与门两个操作数都为1时结果为1。 真值表 AND 0 1 0 0 0 1 0 1 符号 电路图 或门有一个操作数为1结果就为1。 真值表 OR 0 1 0 0 1 1 1 1 符号 电路图 与非门跟与操作结果相反。 真值表 NAND 0 1 0 1 1 1 1 0 符号 或非门跟或操作相反。 真值表 NOR 0 1 0 1 0 1 0 0 符号 异或门一个操作数为1，另一个操作数为0时，结果才为1。 真值表 XOR 0 1 0 0 1 1 1 0 符号 电路图 二进制加法器半加器和全加器加法结果可以拆成两部分，一个是加和结果，另一个是进位结果。二进制加法也可以照下面这个方式进行拆分。 加和表 +加和 0 1 0 0 1 1 1 0 进位表 +进位 0 1 0 0 0 1 0 1 可以利用下面的两个逻辑门来实现上面的结果 异或门 XOR 0 1 0 0 1 1 1 0 与门 AND 0 1 0 0 0 1 0 1 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。因此我们可以将与门和异或门连接在一起来计算两个二进制数(即A和B)的和。 真值表 输入A 输入B 加和输出 进位输出 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 这个被叫做半加器(Half Adder)。之所以被叫半加器是有原因的。它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于1位的。半加器没有做到的是将前一次的加法可能产生的进位位纳入下一次运算。例如，假设我们要将如下两个二进制数相加。 1111 +1111 ----- 11110 我们只能将半加器用于最右面一列的相加：1加1等于0，进位1。对于右面算起的第二列，由于进位位的存在，实际上需要将三个二进制数相加，而随后的每一列的加法都是这样的。随后的每一列二进制数相加都需要将进位位算进来。为了对三个二进制数进行加法运算你，我们需要将两个半加器和一个或门做如下连接。 真值表 进位输入A 输入A 输入B 加和输出 进位输出 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 这个叫做全加器(Full Adder)。我们用如下的符号表示它: 到这里，我们已经迈出了关键的第一步。因为我们可以利用它做2进制的加法：1+1=10！ 多位二进制数相加当然，只能进行一位二进制数相加的加法器的用途实在是太窄了，我们更需要能支持多位二进制数做加法的加法器。答案就是将多个全加器连接起来，组成多位加法器。假设我们将4个全加器连接起来，那么它就能做4位二进制数的加法。如下图所示： 假设有两个4位二进制数A₃A₂A₁A₀和B₃B₂B₁B₀，只需要将它们按位相加，再逐级将低位的进位输出到高位进行计算即可。 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 –Charles Petzold 《穿越计算机的迷雾》 –李忠]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>加法器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
