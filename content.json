{"meta":{"title":"黄枫谷","subtitle":"练气十层","description":"外门弟子","author":"胡匪","url":"//huminxi.com"},"posts":[{"title":"一种基于前后端分离的单点登录实现方案","slug":"一种基于前后端分离的单点登录实现方案","date":"2017-12-10T12:43:57.000Z","updated":"2017-12-10T13:57:55.000Z","comments":true,"path":"2017/12/10/一种基于前后端分离的单点登录实现方案/","link":"","permalink":"//huminxi.com/2017/12/10/一种基于前后端分离的单点登录实现方案/","excerpt":"单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。相同的，单一注销（single sign-off）就是指，只需要单一的注销动作，就可以结束对于多个系统的访问权限。","text":"单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。相同的，单一注销（single sign-off）就是指，只需要单一的注销动作，就可以结束对于多个系统的访问权限。 单点登录机制一、单系统登录1、http 无状态协议web 应用采用 browser/server 架构，http 作为通信协议。http 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程如下图所示，三次请求/响应对之间没有任何联系。 但这也同时意味着，任何用户都能通过浏览器访问服务器上的资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求(响应合法请求，忽略非法请求)；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 2、会话机制当浏览器第一次请求服务器时，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器根据请求中的会话 id 就知道是不是同一个用户了(注:浏览器第一次请求时服务器还没有创建会话)，这个过程用下图说明，后续请求与第一次请求产生了关联。 服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？你可能会想到两种方式: 拼接在 url 中 cookie 将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式比较低级。那就换浏览器自己来维护这个会话 id 吧，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以 key/value 形式存储，浏览器发送 http 请求时自动附带 cookie 信息。tomcat 会话机制当然也实现了 cookie ，访问 tomcat 服务器时，浏览器中可以看到一个名为 JSESSIONID 的 cookie，这就是 tomcat 会话机制维护的会话id，使用了 cookie 的请求响应过程如下图。 3、登录状态有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下。HttpSession session = request.getSession;session.setAttribute(“isLogin”, true); 用户再次访问时，tomcat 在会话对象中查看登录状态。HttpSession session = request.getSession;session.getAttribute(“isLogin”); 实现了登录状态的浏览器请求服务器模型如下图所示。 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、多系统的复杂性web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样。 web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie。 既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如 “*.baidu.com”，然后将它们的 cookie 域设置为 “baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。然而，可行并不代表好，共享 cookie 的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间；第三，cookie 本身不安全。因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 三、单点登录什么是单点登录？单点登录全称 Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录。 1、登录相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，先由子系统产生临时令牌，然后 sso 认证中心验证用户的用户名密码没问题，最后 sso 认证中心再通知各子系统令牌生效。之后浏览器端可以利用之前就返回的令牌进行受限资源的访问。 下面对上图简要描述 用户访问 nrb 的受限资源，nrb 发现用户未登录，nrb 生成一个 tokenA，并将 tokenA 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，并关联 sessionId 和 userId sso 认证中心通知 nrb 绑定 tokenA 和 userId 并进行保存 sso 认证中心跳转回用户访问的nrb系统 用户利用之前就已经返回的 tokenA 来访问 nrb 的受限资源 用户访问 hades 的受限资源，hades 发现用户未登录，hades 生成一个 tokenB，tokenB 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户已登录 sso 认证中心通知 hades 绑定 tokenB 和 userId 并进行保存 sso 认证中心跳转回用户访问的hades系统 用户利用之前就已经返回的 tokenB 来访问 hades 的受限资源 2、注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明。 sso 认证中心一直监听会话的状态，一旦会话销毁，监听器将通知所有管理系统执行注销操作。 用户向 hades 系统发起注销请求 hades 系统向 sso 认证中心发起注销请求，并将用户的 tokenA 和存储在 cookie 中的 sessionId 当做参数传递 sso 认证中心取出与 sessionId 关联的系统地址和 token sso 认证中心向所有关联系统发起注销请求，并指定需要注销的 token 各关联系统接收 sso 认证中心的注销请求，销毁指定 token sso 认证中心引导用户至登录页面 四、部署图单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以发送令牌、保存令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述。 sso 认证中心与 sso 客户端通信方式有多种，这里以简单好用的 httpClient 为例，web service、rpc、restful api 都可以。 五、实现简要介绍下基于 java 的实现过程，sso 采用客户端/服务端架构，我们先看 sso-client 与 sso-server 要实现的功能（下面：sso 认证中心= sso-server）。 sso-client 拦截子系统未登录用户的请求，生成 token，并将 token、本地 cookie 值和子系统自身地址作为跳转 sso 认证中心的参数进行传递 接收 sso 认证中心通知的 token、userId 并进行保存 通过 token 与用户建立会话 拦截用户注销请求，向 sso 认证中心发送注销请求 接收 sso 认证中心发出的注销请求，注销指定 token sso-server 验证用户的账户信息 创建 session 将 sessionId 与子系统地址及相应的 token，userId 进行关联 与 sso-client 通信发送 token、userId 校验 session 有效性 接受 sso-client 注销请求，注销所有子系统中的 token 引用 单点登录原理与简单实现 HTML色彩","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.com/categories/编程实践/"}],"tags":[{"name":"单点登录","slug":"单点登录","permalink":"//huminxi.com/tags/单点登录/"}]},{"title":"单例模式","slug":"单例模式","date":"2017-11-28T14:04:34.000Z","updated":"2017-12-01T14:49:34.000Z","comments":true,"path":"2017/11/28/单例模式/","link":"","permalink":"//huminxi.com/2017/11/28/单例模式/","excerpt":"单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。","text":"单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单线程版本“懒汉模式” &amp; “饿汉模式”懒汉模式 123456789101112131415161718public class Singleton &#123; // 定义一个空的 Singleton 对象引用 SINGLETON private static Singleton SINGLETON = null; // 利用构造器私有化来限制外部使用 new 关键字，进而避免构造出多个实例 private Singleton() &#123; &#125; // 提供外部获取单例对象的方法 public static Singleton getInstance() &#123; // 如果 SINGLETON 还未指向任何一个 Singleton 对象，new 一个 Singleton 对象出来。 if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 对象引用一开始为 null，具体使用的时候才 new 一个对象出来，这种写法属于懒汉模式。 饿汉模式 123456789101112public class Singleton &#123; // 在定义时就直接 new 出单例对象 private static Singleton SINGLETON = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SINGLETON; &#125;&#125; 顾名思义，单例对象一开始就被 new Singleton() 主动构建，不再需要判空操作，这种写法属于饿汉模式。 多线程版本如果上面”懒汉模式”的代码是运行在多线程环境中，就会出现许多问题。最明显的一个，将有可能 new 出多个 Singleton 对象实例。最简单的修复方式是在 getInstance() 方法上加 synchronize 关键字。 123456789101112131415public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; // 方法上加 synchronized 关键字 public synchronized static Singleton getInstance() &#123; if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 但是这样的话，在每次调用 getInstance() 方法的时候都会加锁。 使用 double-checked lock(双检锁) 可以避免在 new 出单例对象之后还对 getInstance() 方法进行加锁。 1234567891011121314151617181920212223public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; // 第一次检查 if (SINGLETON == null) &#123; // new Singleton() 代码块才进行加锁 synchronized (Singleton.class) &#123; // 第二次检查 if (SINGLETON == null) &#123; SINGLETON = new Singleton(); &#125; &#125; &#125; return SINGLETON; &#125;&#125; 本文引自1.老生常谈双检锁（DCL） 2.The “Double-Checked Locking is Broken” Declaration","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.com/categories/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"//huminxi.com/tags/单例模式/"}]},{"title":"从零开始造一台自己的加法器","slug":"从零开始造一台自己的加法器","date":"2017-11-23T07:13:22.000Z","updated":"2017-11-23T07:26:29.000Z","comments":true,"path":"2017/11/23/从零开始造一台自己的加法器/","link":"","permalink":"//huminxi.com/2017/11/23/从零开始造一台自己的加法器/","excerpt":"在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如:二进制数乘法器的重要组成部分。","text":"在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如:二进制数乘法器的重要组成部分。 一.10进制与2进制10的替代品对我们人类而言，10是一个非常重要的数字。10是我们大多数人拥有的手指或脚趾的数目，因为手非常便于计数，于是我们已经适应了这个以10为基数的数字系统(也称为十进制数字系统)。起初也很难再构想出其它的数字系统。 当我们看到数字10的时候，我们不自觉地就想到这个数字代表了下面的这么多个苹果： 10 =   但是，数字10之所以指的是这么多个苹果，其唯一的理由就在于这些苹果的数目与我们手指的数目相同。如果人类的手指不是10根，我们数数的方式就会有所不同，那么10就会是另外一个含义。 同样，数字10还可以代表这么多个苹果： 10 =   或者是这么多个苹果： 10 =   甚至可以是这么多个苹果： 10 =  设想一下: 如果人类像卡通人物一样每只手有4根手指那会怎样呢？ 我们可能就不会想到建立一个以10为基数的数字系统。我们会自然而然地、不可避免地想到建立一个以8为基数的数字系统。我们会称它为八进制数字系统。如果我们的数字系统是以8为基数而建立的，我们就不需要下面这个符号： 9 将这个给卡通人物看的话，他会得到这样的反应：”这是什么？它代表什么？“ 继续思考一下，你会发现我们连这样的一个符号也不会需要： 8 在十进制中，”十”没有特定的符号，因此在八进制中，同样也没有表示”八”的特定符号。十进制中我们的计数方式是：0、1、2、3、4、5、6、7、8、9，然后是10。八进制中我们的计数方式是：0、1、2、3、4、4、5、7，然后是什么呢？我们已经将符号用完了。在这里唯一有意义的只有10，而在这里的正确答案恰恰就是10。在八进制中，7之后的一个数字就是10。但这个“10”代表的并不是人类的手指的数量。在八进制中，“10”代表的是卡通人物手指的数量。 2进制如果我们是海豚呢，那么就必须用两个鳍来计数。这个数字系统称为以2为基数的数字系统(或二进制)。这样的话我们似乎只有两个数字了，分别为0和1。在二进制中，1的下一个数字是10。第一次见似乎有点难以理解，但也不用意外。因为无论使用哪种计数系统，当单个的数字用完时，第一个两位数就是10。 二进制数最大的问题是数字用完的很快! 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1110,1111,10000,10001,… 当然，二进制也有它的优点，比如做加法的时候: 11加法表 + 0 1 0 0 1 1 1 10 乘法比加法还容易，比起小时候背的”99乘法表”不知道简单了多少。 11乘法表 x 0 1 0 0 0 1 0 1 99乘法表 x 1 2 3 4 5 6 7 8 9 1 1 2 2 4 3 3 6 9 4 4 8 12 16 5 5 10 15 20 25 6 6 12 18 24 30 36 7 7 14 21 28 35 42 49 8 8 16 24 32 40 48 56 64 9 9 18 27 36 45 54 63 72 81 二.电磁铁与继电器电磁铁如果你手头有一根铁棒，那么在上面用细导线绕几百圈，然后接通电流，铁棒就变成了一块磁铁。现在它可以吸引其它的铁块或者钢块(电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象)。断开电流，铁棒将丧失磁性。 继电器继电器的作用就是通过吸引或弹开衔铁，进而控制另一个电路的通断。 继电器符号和电路图如下所示： 三.门非门结果与操作数相反。 真值表 NOT 0 1 1 0 符号 电路图 与门两个操作数都为1时结果为1。 真值表 AND 0 1 0 0 0 1 0 1 符号 电路图 或门有一个操作数为1结果就为1。 真值表 OR 0 1 0 0 1 1 1 1 符号 电路图 与非门跟与操作结果相反。 真值表 NAND 0 1 0 1 1 1 1 0 符号 或非门跟或操作相反。 真值表 NOR 0 1 0 1 0 1 0 0 符号 异或门一个操作数为1，另一个操作数为0时，结果才为1。 真值表 XOR 0 1 0 0 1 1 1 0 符号 电路图 四.二进制加法器半加器和全加器加法结果可以拆成两部分，一个是加和结果，另一个是进位结果。二进制加法也可以照下面这个方式进行拆分。 加和表 +加和 0 1 0 0 1 1 1 0 进位表 +进位 0 1 0 0 0 1 0 1 可以利用下面的两个逻辑门来实现上面的结果 异或门 XOR 0 1 0 0 1 1 1 0 与门 AND 0 1 0 0 0 1 0 1 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。因此我们可以将与门和异或门连接在一起来计算两个二进制数(即A和B)的和。 真值表 输入A 输入B 加和输出 进位输出 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 这个被叫做半加器(Half Adder)。之所以被叫半加器是有原因的。它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于1位的。半加器没有做到的是将前一次的加法可能产生的进位位纳入下一次运算。例如，假设我们要将如下两个二进制数相加。 1111 +1111 ----- 11110 我们只能将半加器用于最右面一列的相加：1加1等于0，进位1。对于右面算起的第二列，由于进位位的存在，实际上需要将三个二进制数相加，而随后的每一列的加法都是这样的。随后的每一列二进制数相加都需要将进位位算进来。为了对三个二进制数进行加法运算你，我们需要将两个半加器和一个或门做如下连接。 真值表 进位输入A 输入A 输入B 加和输出 进位输出 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 这个叫做全加器(Full Adder)。我们用如下的符号表示它: 到这里，我们已经迈出了关键的第一步。因为我们可以利用它做2进制的加法：1+1=10！ 多位二进制数相加当然，只能进行一位二进制数相加的加法器的用途实在是太窄了，我们更需要能支持多位二进制数做加法的加法器。答案就是将多个全加器连接起来，组成多位加法器。假设我们将4个全加器连接起来，那么它就能做4位二进制数的加法。如下图所示： 假设有两个4位二进制数A₃A₂A₁A₀和B₃B₂B₁B₀，只需要将它们按位相加，再逐级将低位的进位输出到高位进行计算即可。 本文引自1.《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 –Charles Petzold 2.《穿越计算机的迷雾》 –李忠","raw":null,"content":null,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"//huminxi.com/categories/计算机基础/"}],"tags":[{"name":"加法器","slug":"加法器","permalink":"//huminxi.com/tags/加法器/"}]},{"title":"my first blog","slug":"my-first-blog","date":"2017-11-22T13:57:42.000Z","updated":"2017-11-22T13:57:42.000Z","comments":true,"path":"2017/11/22/my-first-blog/","link":"","permalink":"//huminxi.com/2017/11/22/my-first-blog/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-11-22T01:56:58.000Z","updated":"2017-11-23T09:42:15.000Z","comments":true,"path":"2017/11/22/hello-world/","link":"","permalink":"//huminxi.com/2017/11/22/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}