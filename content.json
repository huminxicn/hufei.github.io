{"meta":{"title":"黄枫谷","subtitle":"勿在浮沙筑高台。","description":null,"author":"胡匪","url":"//huminxi.netlify.com"},"pages":[{"title":"2017 总结","date":"2017-12-24T09:08:11.000Z","updated":"2018-12-29T05:39:05.850Z","comments":true,"path":"2017 总结.html","permalink":"//huminxi.netlify.com/2017 总结.html","excerpt":"时间过得跟狗一样的快!  –鲁迅","text":"时间过得跟狗一样的快! –鲁迅 年度事件转正述职原先预定的是 1 月 13 号的转正述职，后因为开”月需求讨论会”而推迟到了 14 号。我记得来到农分期的第一天就是 23 点钟下班的，黑牛、建国、孟铀、忠泽、嘟嘟 5 位后端小伙伴用实际行动告诉了我什么才叫做自愿加班。当时农人帮系统在重构，整个系统重构了大概 7、8 个月的时间。一直到 2016-10-10 才上线。开始的 3 个月基本上都是自己在看张龙老师的 java 教学视频，收益颇丰。后面的 3 个月才开始慢慢的接触需求开发，在建国的指导下也完成了几个功能的上线。当然，后面用了 N 多版本来修复 bug，N &gt;=10 。在实习期间，老韩的以身作则、黑牛的精益求精、孟铀的诲人不倦、建国的勇往直前、忠泽的积极乐观、嘟嘟的善解人意让我感触良多。因为和你们一比较，发现我一无是处。而且整个技术部的氛围是自由和温暖，这是最打动我的地方。后面也勉强达到了公司的及格线，幸运的留在了公司。 与孟铀合租房子1 月 18 号的时候与孟铀合租了位于南京市栖霞区尧林仙居碧水苑的一套两居室。月租 1900，水电不免，燃气自包。孟铀为了照顾我，他出 1000+每月网费，我 900。当时签的是一年的合同，现在也快要到期续租了。 年中考核具体的考核内容已经记不清了，现在只记得老韩对我说过的一句话:你可以多尝试，做更多的事情。 一周年2017-7-4 号，来农分期一周年了。公司送给我一张写满了同事祝福语的生日祝福卡、一个实用的枕头、一张价值 100 元的苏果购物卡。感谢我期。 青岛之行2017-11-18 至 2017-11-20 号去青岛玩了三天。顺带参加了一下青岛马拉松的 12.3 公里的体验跑。许多人一起跑步，旁边有志愿者帮你准备补给，还帮你喊加油的感觉真不错。明年也要参加至少一次的马拉松。 个人博客2017-11-22 利用 Hexo 框架和 Git Pages 搭建了个人博客。 明年目标 参加一次马拉松(最好是半程或以上) 看完《深入理解计算机系统》和《算法》这两本书 去一趟深圳","raw":null,"content":null},{"title":"2018 半年总结","date":"2018-06-20T14:38:45.000Z","updated":"2018-12-29T05:35:10.177Z","comments":true,"path":"2018 年中总结.html","permalink":"//huminxi.netlify.com/2018 年中总结.html","excerpt":"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。 –《道德经》","text":"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。 –《道德经》 目标进度预期目标 参加一次马拉松(最好是半程或以上) 看完《深入理解计算机系统》和《算法》这两本书 去一趟深圳 已完成 参加一次马拉松(最好是半程或以上) 根据小渊的建议，累计跑完 200km 之后就可以尝试参加半马了。 目前已经跑了 85km，还剩 115km。按照每次跑 5km 计算，还需要跑 23 次，如果每周跑两次，预计在 10 月份左右能全部跑完，到时候刚好去参加 2018-10-21 举办的南京马拉松。 累计跑程 看完《深入理解计算机系统》和《算法》这两本书 因为《深入理解计算机系统》这本书太晦涩了点，于是先看了《计算机网络–自顶向下方法》这本书。目前已经看到了第五章(链路层)。打算在 2018-06-31 号之前把第五章看完。 打算下半年再开始看《深入理解计算机系统》这本书。 计算机网络 deadline 去一趟深圳 ✅ 就着端午小长假(2018-06-16~2018-06-19)，去了趟深圳。 小伙伴带我逛了一天的深圳，其中印象最深的就是深圳图书馆，因为里面读书的氛围实在是太浓厚了。 最后一天上午还去了趟香港。 16 小伙伴 17 街道 深圳图书馆 18 胡匪 19 公交站台 尖沙咀码头 尖沙咀码头 尖沙咀码头 钟楼 龙城大药房 红花油 港币 目标更新 参加一次马拉松(最好是半程或以上) 看完《深入理解计算机系统》这本书 机器学习入门","raw":null,"content":null},{"title":"2018 总结","date":"2018-12-29T05:38:51.000Z","updated":"2018-12-29T07:11:39.280Z","comments":true,"path":"2018 总结.html","permalink":"//huminxi.netlify.com/2018 总结.html","excerpt":"成功只有一种：按照自己的方式，去度过人生。 ——《明朝那些事》","text":"成功只有一种：按照自己的方式，去度过人生。 ——《明朝那些事》 变化才是永恒回头看看自己在年初的时候立的那些目标。 现在想想，只完成了第三条。哈哈 工作上半年还在农分期按部就班地上着班，当时心想：明年一定要出去看看，毕竟已经在农分期呆的够久，有点过于安逸了。没想到，8 月份的时候公司突然裁员，干脆乘此机会休息一阵子，好好思考下一步该往哪走。于是乎，先回外婆家休息了一个多月的时间(顺便把之前一直拖着的驾照考完了)。随后重整旗鼓，回到南京准备面试，最后加入了领添。说句实话，今年下半年从农分期的离职是出乎我的意料的，这也正说明了世事难料。 学习今年通过《计算机网络-自顶向下方法》一书恶补了网络这块的基础知识，对现存的计算机网络结构有了个深刻的理解。同时还阅读了《图解设计模式》等应用类的书籍。阅读完这些书籍给我的一个直观感受就是，计算机基础知识很重要。打算明年继续恶补算法和计算机系统相关的基础知识。 明年目标 至少写 40 篇技术博客。 做眼睛的激光手术。 去杭州看看。","raw":null,"content":null},{"title":"个人简历","date":"2018-11-08T12:26:06.000Z","updated":"2019-03-25T02:39:46.646Z","comments":true,"path":"个人简历.html","permalink":"//huminxi.netlify.com/个人简历.html","excerpt":"个人简历，不定时更新。","text":"个人简历，不定时更新。 个人信息 胡敏喜/男/1995 18840847242/huminxi0214@qq.com 技术博客: https://www.huminxi.com 教育背景2012 年~ 2016 年 大连海事大学 本科学士学位 工作经历2016.07 ~ 2018.08 南京农分期电子商务有限公司 技能栈 熟练掌握 IntelliJ IDEA、DataGrip、Vim 等工具的使用 能熟练运用 java、python、groovy 语言进行开发 熟悉主流框架应用及原理，如 Spring、Spring-mvc、Spring-boot、Mybatis、Hibernate 等 熟悉常用协议规范，如 HTTP、SMTP、TCP、restful 等 熟悉 MySQL，了解常用 sql 优化技巧 了解机器学习相关的基本原理 自我评价 有过独立设计服务的经验 非常热衷于技术，坚持稳扎稳打的夯实计算机基础（计算机网络、数据结构、算法） 持续每天不间断学习英语一年 项目经验项目名称：GALEN(Base) 项目描述： 这是一个基础服务，对外负责对接第三方系统，如银生宝代扣、阿里支付、钉钉等；对内负责提供公用的服务接口。 工作内容： 负责对接代扣通道，例如银生宝、宝付等。 提供验证银行卡卡元信息的接口，能匹配 95% 以上的银行卡卡元信息。 项目名称：TMS(Domain) 项目描述： 这是公司的物流系统，一个具体的领域服务。物流客服可以在这个系统内完成从发货到确认收货的完整流程，例如为物流单添加配送人员信息、发货、确认收货、给厂家开具发票以及导出历史物流单的功能。 采用了 Spring-Boot 来搭建后端项目，同时以 Swagger 界面的形式提供了详细的接口文档。 相关技术博客：用 Java 怎么导出 CSV 格式的文件 工作内容： 这个项目的负责人是我，前期负责需求的确定和系统的搭建。 系统上线后负责功能上的优化。 项目名称：SSO(单点登录) 项目描述： 只需要在 SSO 登录界面登录一次，就能同时访问公司的多个 Gateway 项目。 相关技术博客：一种基于前后端分离的单点登录实现方案 工作内容： 因为公司采用的是前后端分离的开发模式，所以需要因地制宜地给出『基于前后端分离的单点登录实现方案』。 负责 SSO-client 端的具体实现。 项目名称：今日分享机器人 项目描述： 利用钉钉机器人来实现自动通知今日分享内容 整个项目主要由一个 python 脚本和 Linux 系统自带的 crontab 定时命令来完成。 相关技术博客：钉钉自定义机器人的一种用法 工作内容： 这其实是属于自己发现需求的一个项目，主要表达了自己的『用机器来代替人力工作』的思想。","raw":null,"content":null},{"title":"标签","date":"2018-02-05T15:36:56.000Z","updated":"2018-02-05T15:42:32.000Z","comments":true,"path":"tags/index.html","permalink":"//huminxi.netlify.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"分类","date":"2018-02-05T15:38:37.000Z","updated":"2018-02-05T15:42:32.000Z","comments":true,"path":"categories/index.html","permalink":"//huminxi.netlify.com/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"观《你的名字》有感","date":"2017-12-17T13:28:58.000Z","updated":"2018-12-10T10:49:00.214Z","comments":true,"path":"private/观《你的名字》有感.html","permalink":"//huminxi.netlify.com/private/观《你的名字》有感.html","excerpt":"今天下午第一次看 2016-12-2 号就已经上映的新海诚导演的影片《你的名字》，因为看完电影之后觉得故事还有不清晰的点，所以又去看了一下与电影相关的点评。这才理清楚了其中的故事脉络。","text":"今天下午第一次看 2016-12-2 号就已经上映的新海诚导演的影片《你的名字》，因为看完电影之后觉得故事还有不清晰的点，所以又去看了一下与电影相关的点评。这才理清楚了其中的故事脉络。 《你的名字》中的几个点，你 get 到了吗三叶其实比立花泷大三岁首先，我们知道随着剧情的推展，男女主角逐渐发现自己在睡梦中发生的事情，实际上并不作是梦，而是现实中确实与对方交换了灵魂。导演新海诚在这边添加了许多轻松幽默的元素，以此来说明两人不断摸索对方到底是谁的过程。最好笑的莫过于灵魂交换到三叶身体里的泷，每天早上醒来双手都放在胸部上面。在两人发现灵魂会互换后也彼此约法三章：要求不管做了什么都要记录下来让对方知道、喜欢体验东京生活的三叶不能乱花泷的钱、三叶要求泷坐姿要坐好、以及不能乱摸她的身体。 在两人渐渐的了解对方后，三叶发现在泷的心中暗恋着一起工作的奥寺前辈，决定帮他一把。知道女人心中喜好的三叶很快的就帮泷促成两人首次的约会，甚至担心约会当天如果灵魂没有交换过来，不擅长跟女人交谈的泷会不知所措，还帮泷制作了约会必胜笔记，笔记的最后写道「约会结束的时候正好可以看到彗星吧」。然而泷看到这句话时抬头看了下傍晚的天空，发现天空中并没有彗星，所以不明白三叶最后说的「约会结束的时候正好可以看到彗星吧」这句话是什么意思。这里正是导演新海诚埋下的第一个伏笔，透露出两人身处的时空其实是不相同的！ 为什么过去的历史可以被改变 三叶、四叶你们听过「结」（日文音译产灵）吗？是一个土地神，古语叫做「结」，这个名称有深远的含义。连接绳线是「结」，连接人与人是「结」，时间的流动也是「结」，全都是神的力量，我们做的结绳也是神的作品。这正是时间流动的体现，聚在一起、成型、扭曲、缠绕，有时又还原、断裂，再次连接，这就是「结」，这就是时间。 这段话正是贯穿整部电影的重点，电影核心剧情就建构在三叶奶奶这里口中所提到的「结」，就字面上表示的意思，时间的流动如同动画中三叶编的结绳拥有类似的性质，是可以还原、断裂甚至再次接上的，这也解释了为什么泷回到彗星坠落前日，可以改变原本要发生的事情，提醒敕使与耶香即将有灾难降临到系守镇。而这样的举动，让原先因为彗星坠落导致时间轴断裂（死亡）的三叶，能再次接续了她的生命。 为什么两人在黄昏之时可以相见站在科学的角度来理解，两人灵魂交换的理论依据其实是「莫比乌斯」环。莫比乌斯循环其实就是将一条长条纸带，其中一头旋转一百八十度后相黏，如果你事先在纸带的正反两面涂上不同颜色，相黏后你会发现不管你拿着笔沿着纸带上哪一个地方开始走，你可以不断的循环反覆经过两个不同的颜色区段。 而这边正反两面的颜色可以想像成：一种颜色是泷的身体，另一种颜色是三叶的身体，在正反两面行走的则是两人的灵魂。每当经过纸带黏接的交接处，原先位于纸带正面的灵魂会跑到背面，背面的会跑到正面，两人灵魂反覆交换的现象正是如同被扭曲连结的「莫比乌斯」循环。 故事前半段老师在黑板前上课时提到的「黄昏之时」，即傍晚非日非夜的这个时段，世界的轮廓会变得模糊，是可能看到非人之物的时段。世界的轮廓可以比喻成纸带相黏的交界处，也是两者唯一有机会短暂交会的时刻。 为什么泷和三叶会忘记对方的名字 前面就是黄泉世界，想要从黄泉世界回到这个世界，必须用你最重要的东西来交换。 很多人觉得泷始终想不起三叶的名字是因为他们的遭遇就像作梦一样，而经由潜意识产生的梦醒来后忘记是理所当然的。不过本片中不仅能看穿泷的灵魂在三叶体内、而且每句话还通通都是重点的”最强角色”三叶奶奶曾说过：要从黄泉世界回归原本的世界需要拿最珍贵的东西交换，而对三叶与泷来说最重要的东西就是两人之间一同经历的那段珍贵回忆，最后虽然泷成功把三叶从另一个世界带回来，但两人也因此都忘了记忆中最重要的彼此与对方的名字。 只有三叶才互换过灵魂吗其实不是的，影片中奶奶和回到三年前三叶身体的泷提到了自己还是少女时也曾做过不可思议的梦，但是有关这个梦的记忆现在却已经消失了，还提到无论是她自己还是三叶的母亲都曾有过类似的经历。且电影的最后也给了四叶成高中生后，抬头望向窗外的一个镜头，暗示了四叶开始了灵魂互换。 引用 《你的名字》中隐藏的五个秘密！ 你的名字中的一些暗线故事 有关命中注定和世界的自动修正 附加 点击下载《你的名字》小说 后续同人小说链接","raw":null,"content":null},{"title":"超长年假纪实","date":"2018-09-17T11:17:36.000Z","updated":"2018-10-24T13:37:35.000Z","comments":true,"path":"private/超长年假纪实.html","permalink":"//huminxi.netlify.com/private/超长年假纪实.html","excerpt":"自 2018-08-30 从农分期离职，到今天第 18 天了，每天过的就像放暑假一样开心。而且，目测这样的日子要持续到国庆节为止。看着身边的同事都忙着在找下一家，而我却没有一点点着急的感觉。甚至，脑子里还幻想着要是能一直这样那该多好。果然是——人之初，性本惰。算了，就当这是一个加长版的年假吧。乘此机会，刚好回家一趟。","text":"自 2018-08-30 从农分期离职，到今天第 18 天了，每天过的就像放暑假一样开心。而且，目测这样的日子要持续到国庆节为止。看着身边的同事都忙着在找下一家，而我却没有一点点着急的感觉。甚至，脑子里还幻想着要是能一直这样那该多好。果然是——人之初，性本惰。算了，就当这是一个加长版的年假吧。乘此机会，刚好回家一趟。 2018-09-16 18:30day 1 上午 10:30 坐上从南京——鄱阳的大巴，一直到 18:30 才到家。到家时他们已经在等着我吃晚饭了，而且外婆还专门弄了我爱吃的瘦肉汤，哦依稀！ 2018-09-17 19:32day 2 今天一直睡到上午 11:17 才起床，直接就早午饭一起吃了。但明天就不能起这么晚了，约了驾校教练，明天要早起去学车。晚上和家人聊天的时候，二舅也鼓励道，年轻人就是要多出去闯闯，不要害怕失败。还有，出门在外，有自信心才是最重要的。 2018-09-18 20:21day 3 今天 06:00 就起来了，台风刚过，天还下着雨，吃过早饭后就骑着我的小毛驴就往建材市场走，因为教练说 07:00 在那集合。但后来教练有事晚点到，于是今天我就先去了阿姨家，明天再去练车。 2018-09-19 19:59day 4 今天 06:05 就起来了，照样骑着小毛驴就往建材走。今天去桐山训练科目二，同时去的一共有 7 个人。一整天时间都在排队，实际也就训练了 100 分钟，时间有效利用率太低了。幸好明天白天不用过去，晚上直接过去打卡就行，这样效率能高不少。 2018-09-20 20:58day 5 从下午四点多开始，科目三打卡，一共打了四个小时。前面的一个小时还挺兴奋的，后面的三个小时就是在重复前面的一个小时，有种挂机了三个小时的感觉。 2018-09-21 18:55day 6 今天下午把科目三剩余的 100 分钟培训时间也打卡完毕。就等明天审核通过，直接预约科目三考试。 2018-09-22 22:33day 7 今日无事，明早 7 点集合训练。 2018-09-23 22:45day 8 今日把科目二打卡完毕，就等预约开考试了。 2018-09-24 16:34day 9 中午和外公外婆一起在家吃了午饭，晚上去鄱阳过夜，和基友见个面。 2018-09-25 17:58day 10 今天和基友见了面，下午回外婆家。不幸的是，身份证丢了。 2018-09-26 17:58day 11 今天约了科目二的考试。 2018-09-27 23:43day 12 今日无事。明天去鄱阳县公安局问一下怎么补办身份证和怎么迁移户口。 2018-09-28 20:21day 13 今天联系了一下 QQ，准备把户口从大连签回老家。 2018-09-29 21:26day 14 今天去熟悉了一下考场。明天上午考科目三，下午考科目二。加油，争取一起过了。 2018-09-30 18:10day 15 科目二过了，科目三挂了。等十天之后再预约不考。 2018-10-01 18:11day 16 今天高中同学结婚，去吃酒了。这似乎还是第一次参加同学的婚礼。 2018-10-02 23:08day 17 今天老妈回家，外婆做了饺子吃。 2018-10-03 18:43day 18 今天一家人去三舅家吃饭。顺带去鄱阳收了一下户口迁移证的快递。 2018-10-04 21:58day 19 今天去阿姨家吃饭，顺带一起去了芝山公园玩了一下。 2018-10-05 08:45day 20 今天下午回古县渡。明天去鄱阳。 2018-10-06 10:33day 21 今天在外婆家呆了一天。 2018-10-07 20:21day 22 今天胡鹏回学校了。 2018-10-08 20:21day 23 今天把户口签回了古县渡，顺带补办了一张临时身份证。 2018-10-09 20:21day 24 今天帮老妈买了一张去深圳的汽车票。她明天回深圳。 2018-10-10 18:28day 25 今天重新预约了科目三考试。老妈上午会深圳了。 2018-10-11 13:06day 26 今日无事。 2018-10-12 13:06day 27 今日无事。 2018-10-13 13:06day 28 今日无事。 2018-10-14 13:06day 29 下午去科目三的考场试车。 2018-10-15 09:34day 30 今天上午过了科目三。开始打卡科目四。 2018-10-16 09:34day 31 科目四打卡完毕，约考22号的科目四。 2018-10-16 09:34day 32 今日无事。 2018-10-17 09:34day 33 今天去鄱阳看了一下手。 2018-10-18 09:34day 34 今天补办的身份证到了南京。 2018-10-19 16:46day 35 今日无事。 2018-10-20 16:46day 36 今天看英雄联盟 S8 赛季总决赛八强赛，恭喜 ig 战队出线，RNG 遗憾出局。 2018-10-21 16:46day 37 今天看英雄联盟 S8 赛季总决赛八强赛，EDG 遗憾出局。 2018-10-22 16:46day 38 今天终于把科目四考完啦，买了后天回南京的汽车票。 2018-10-23 21:15day 39 收拾东西，准备回南京。 2018-10-24 21:15day 40 早上 8:40 从鄱阳出发，下午 17:00 到尧林仙居。 总结 考完了驾照 把户口从学校迁移回了原籍 重新补办了一张身份证 明天开始找工作。","raw":null,"content":null},{"title":"年会街舞纪实","date":"2018-01-08T14:57:31.000Z","updated":"2018-02-27T13:06:11.000Z","comments":true,"path":"private/年会街舞纪实.html","permalink":"//huminxi.netlify.com/private/年会街舞纪实.html","excerpt":"不知道是上周几，公司年会节目抽签，郭大侠一下子就给我们技术部抽中了舞蹈。于上周五晚上本人就被内定成了年会街(ga)舞成员，也不知郭大侠是否知情，我在校期间也曾报过一个学期的健身街(ga)舞课。从这周一(1 月 8 号)开始，我开始了紧张而刺激的街(ga)舞学习。","text":"不知道是上周几，公司年会节目抽签，郭大侠一下子就给我们技术部抽中了舞蹈。于上周五晚上本人就被内定成了年会街(ga)舞成员，也不知郭大侠是否知情，我在校期间也曾报过一个学期的健身街(ga)舞课。从这周一(1 月 8 号)开始，我开始了紧张而刺激的街(ga)舞学习。 2018-01-08 23:10练舞第一天。 大家利用 12:00 至 13:00 这一个小时的午休时间开始了第一次年会街(ga)舞练习。因为是第一次练习，许多小伙伴还有点羞涩，没有解放出天性。不过随着大家一起练习次数的增加，应该会越来越棒的，加油! 2018-01-09 22:41练舞第二天。 除了继续利用中午的一个小时，晚上大家在李教练的指导下又继续加练了一个小时。感觉进度应该没问题，现在只剩下年会时跳的到底是街舞还是街(ga)舞的问题了。 2018-01-10 23:23练舞第三天。 同昨天一样的训练时间，不过大家的热情明显高涨了不少。keep going! 2018-01-11 23:25练舞第四天。 由于中午练习对下午的工作的影响有点大，所以就只在晚上练习了。好消息是大家在今天已经完成了前半段的学习，明天开始后半段的学习。 2018-01-13 00:23练舞第五天。 今晚练了后半段的第一、二节。这样只剩下最后一节动作了。 2018-01-13 16:44练舞第六天。 由于明天是周日，所以今天也休息一天，但教练说下周就要辛苦一点了。 2018-01-15 20:39练舞第七天。 今天由于刷数据的原因，上去练习的时间缩短了，导致学习效果不佳。教练教的动作都没有完全掌握，明天要把这部分补上。 2018-01-16 21:54练舞第八天。 今天终于把所有内容都学完了，跟着教练也能勉强做完一整套动作。明天开始就是不断的练习了。 2018-01-17 20:56练舞第九天。 今天男生都去参加了”农分期大牛成长营”第一期的会议(17:40 ~ 18:40)，所以练习取消。这样一来本周就只剩下明天一天的练习时间了，而下周一就要出排练视频。所以明天加油吧！ 2018-01-18 20:17练舞第十天。 今天开始跟音乐了，发现几个问题。 动作还不太熟练 整体节奏不一致 人员不齐，无法排练队形 下周开始一个一个的解决上述问题。fighting! 2018-01-22 22:01练舞第十一天。 今天发现一个新的问题：村花同时是年会主持人，从今天开始她要参加主持人的排练。这样两个练习时间就有冲突。我的建议是：给村花预留一个位置，其它的人先把队形排练好，剩下村花再找时间单独给她排练一下，完美。 2018-01-23 21:47练舞第十二天。 村花今天也参加了队形的排练，所以队形大体上已经编排完成。但由于没有视频反馈，导致不太清楚整体上是否统一和协调。明天需要拍个视频给自己看看。 2018-01-24 19:11练舞第十三天。 今天小渊(撸代码)和村花(准备述职)都没有参加排练。大家勉强能跟上音乐了，就是还有部分动作跟不上节奏。明天人应该可以到齐吧。 2018-01-25 22:04练舞第十四天。 今天杨洋和佳欣没有参加排练，于是大家跟着音乐把动作又熟悉了几遍。不过，剩余的排练时间不多了。 2018-01-26 20:51练舞第十五天。 今天大家又跟着教练和音乐熟悉了几遍动作，感觉不错。加油。 2018-01-29 36:20练舞第十六天。 总部所有的会议室被占，今天的练习取消。 2018-01-30 12:20练舞第十七天。 明天就要上台了，今天上午大家又一起排练了几遍。晚上 18:30 到 21:00 大家在总部把所有节目都彩排一遍。 2018-01-30 22:28练舞第十八天。 明天，丑媳妇终于要见公婆了。回想这 1 月 8 号就开始的练习之旅，感触颇多。 我们从开始的拘谨、茫然、闷骚，到现在的开放、自信、外骚，谁知道我们经历了什么!不怕大家笑话，其实我从小就觉得跳街舞的人特帅，一直想着什么时候自己也能在大家面前表演一段完整的街舞。为此，大学期间我也曾报过一个学期的街舞课，但结果只拿了一个 B。说来也巧，这时郭星刚好指定我为”年会街舞成员”。当时心想，那就最后再试一遍吧，不管自己能不能通过这次的筛选，这可能是我最后的圆梦机会了。这 18 天来，大家每天都坚持抽出一个半小时练舞，没有你们的坚持和陪伴，像我，今生应该就与舞台绝缘了吧。谢谢你们给我的这个机会！明天我们什么都不要管，只需要跳好自己的舞蹈，相信结果一定不会让大家失望的。明天加油！ ps: 再次感谢一直都很认真负责的李小晴教练。 明天第二排的小伙伴记得和教练站紧一点，不然最后两排的小伙伴可能会被遮挡住。 2018-01-31 22:33练舞第十九天。 『International 秧歌 show』——有你们真好！ The End?","raw":null,"content":null},{"title":"过年纪实","date":"2018-02-16T11:34:58.000Z","updated":"2018-02-23T15:04:49.000Z","comments":true,"path":"private/过年纪实.html","permalink":"//huminxi.netlify.com/private/过年纪实.html","excerpt":"今年 2 月 11 号(腊月 26)就回家了，在家呆 13 天，初八左右去公司。","text":"今年 2 月 11 号(腊月 26)就回家了，在家呆 13 天，初八左右去公司。 2018-02-11 20:00过年第一天 今天坐灵敏舅的车回家，早上 8 点钟就从南京出发，一直到下午 17:30 才到新屋陈村，基本上一天时间都在路上了。 田畈街米饺 三舅家 2018-02-12 20:00过年第二天 今天坐 9 点钟的班车回古县渡。下午陪老妈去买了一下年货，并订了一个生日蛋糕，说是提前帮我过生日。 家 陈氏葡萄酒 小霸王学习机 🐸儿子 米饺 生日蛋糕 2018-02-13 20:00过年第三天 上午去买了一下烟花爆竹，中午去凡仔外婆家吃午饭(凡仔妈妈做的菜)，晚上请凡仔来我加吃饭，顺带尝一下『陈氏葡萄酒』。 烟花 爆竹 账单 午饭 2018-02-14 20:00过年第四天 今天是腊月 29，和胡鹏一起去外婆家过小年。 古县渡-&gt;新屋陈 外公 新屋陈-&gt;古县渡 2018-02-15 20:00过年第五天 上午去山上点灯，下午贴对联，最后吃年夜饭。 堂哥和我 上山的路 刚贴好的对联 年夜饭 2018-02-16 20:28过年第六天 早上在村里拜年，然后去山上拜年，最后一家人再去给菩萨拜年。 菩萨庙 山上的水库 2018-02-17 20:41过年第七天 在家呆了一天，顺便重新整理了一遍 《我眼中的互联网》 2018-02-18 20:30过年第八天 早上去阿姨家拜年，上午和胡鹏、老妈逛了一下街，还顺带吃了占师傅拌粉和瓦罐汤。 两元一个 占师傅拌粉-1 占师傅拌粉-2 2018-02-19 20:30过年第九天 和凡仔，大毛，兔子，皮皮等人在鄱阳浪。 2018-02-20 20:30过年第十天 和凡仔，大毛，兔子，皮皮等人在鄱阳浪。 2018-02-21 20:30过年第十一天 吃伟强哥的喜酒。 囍竹 和我 140 斤的大外甥 立人 2018-02-22 18:05过年第十二天 吃伟强哥的喜酒，明天(初八)回南京上班。 2018-02-23 23:04过年第十三天 早上 9:00 从新屋陈出发，晚上 22:00 到尧林仙居。","raw":null,"content":null}],"posts":[{"title":"Java 内存模型与线程","slug":"Java 内存模型与线程","date":"2020-01-15T05:24:29.000Z","updated":"2020-01-20T09:18:49.630Z","comments":true,"path":"2020/01/15/Java 内存模型与线程/","link":"","permalink":"//huminxi.netlify.com/2020/01/15/Java 内存模型与线程/","excerpt":"并发处理的广泛应用是 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的原因。Amdahl 定律描述了处理器并行运算之后运行效率提升的情况，而摩尔定律表明了处理器晶体管数量与运行效率之间存在正相关性。这两个定律的更替代表了近年来硬件从追求处理器频率到追求多核心并行处理的发展过程。","text":"并发处理的广泛应用是 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的原因。Amdahl 定律描述了处理器并行运算之后运行效率提升的情况，而摩尔定律表明了处理器晶体管数量与运行效率之间存在正相关性。这两个定律的更替代表了近年来硬件从追求处理器频率到追求多核心并行处理的发展过程。 概述一个常见并发应用场景则是一个服务端同时提供服务给多个客户端。衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而 TPS 值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。 多任务处理在现代计算机操作系统中几乎是一项必备的功能了。让计算机同时去做几件事情，不仅仅是因为计算机的运算能力变强了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力『压榨』出来，而让计算机同时处理几项任务则是最容易想到的手段之一。 硬件的效率与一致性在正式讲解 Java 虚拟机并发相关的知识之前，我们先花费一点时间去了解一下物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 『让计算机并发执行若干个运算任务』与『提高计算机处理的效率』之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单。其中一个重要的原因是绝大多数的运算任务都不可能只靠处理器『计算』就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作是很难消除的（无法仅靠寄存器来完成所有的运算任务）。 缓存的作用由于计算机的处理器与存储设备之间的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的 高速缓存 来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行；当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存了。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如下图所示。 处理器、高速缓存、主存间的交互关系 当多个处理器的运算任务都涉及同一块主内存区域时，可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？ 为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly 及 Dragon Protocol 等。 指令重排序为了使得处理器内部的运算单元能被充分利用，除了增加高速缓存之外，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。 与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。 Java 内存模型『内存模型』可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问操作的一种抽象。 Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（C/C++ 等）直接使用物理硬件和操作系统的内存模型。由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发访问正常，而在另外一套平台上并发访问出错，因此在某些场景就必须针对不同的平台来编写程序。 定义 Java 内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让 Java 的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在 JDK 1.5 发布后（实现了 JSR-133），Java 内存模型已经成熟和完善起来了。 主内存与工作内存Java 内存模型主要是定义程序中各个变量的访问规则，即虚拟机将变量存储到内存和从内存中取出这样的底层细节。此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享。 为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比）。每条线程还有自己的工作内存（Working Memory，可与前面的高速缓存类比）。线程的工作内存中保存了被该线程使用到的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示。 线程、主内存、工作内存间的交互关系 Java 线程并发不一定要依赖多线程（如 PHP 中很常见的多进程并发），但是在 Java 里面谈论并发，大多数都与线程脱不开关系。 线程的实现我们知道，线程是比进程更轻量级的调度单位，线程的引入，可以把一个进程的资源分配和执行分开，各个线程既可以共享进程资源（内存地址、文件 I/O 等），又可以独立调度（线程是 CPU 调度的基本单位）。 主流的操作系统都提供了线程实现，Java 语言也提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行 start 方法且还未结束的 java.lang.Thread 类的实例就代表了一个线程。我们注意到 Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的。在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段）。 实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。 使用内核线程实现内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间 1:1 的关系称为一对一的线程模型，如下图所示。 轻量级进程与内核线程之间 1:1 的关系 由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。但是轻量级进程具有它的局限性： 首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。 其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。 使用用户线程实现从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程（User Thread,UT），因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。 而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间 1:N 的关系称为一对多的线程模型，如图下图所示。 进程与用户线程之间 1:N 的关系 使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如『阻塞如何处理』、『多处理器系统中如何将线程映射到其他处理器上』这类问题解决起来将会异常困难，甚至不可能完成。 因而使用用户线程实现的程序一般都比较复杂，除了以前在不支持多线程的操作系统中（如 DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby 等语言都曾经使用过用户线程，最终又都放弃使用它。 混合实现线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁， 这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。 在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N:M 的关系，如下图所示。 许多 UNIX 系列的操作系统，如 Solaris、HP-UX 等都提供了 N:M 的线程模型实现。 用户线程与轻量级进程之间 N:M 的关系 Java 线程实现对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中（因为 Windows 和 Linux 系统提供的线程模型就是 1:1 的）。 Java 线程在 JDK 1.2 之前，是基于称为绿色线程（Green Threads）的用户线程实现的，而在 JDK 1.2 中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的 JDK 版本中，操作系统支持怎样的线程模型，在很大程度上决定了 Java 虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，因此在虚拟机规范中未限定 Java 线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对 Java 程序的编码和运行过程来说，这些差异都是透明的。 Java 线程调度线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。 如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。Lua 语言中的『协同例程』就是这类实现。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的 Windows 3.x 系统就是使用协同式来实现多进程多任务的，相当不稳定，一个进程坚持不让出 CPU 执行时间就可能会导致整个系统崩溃。 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在 Java中，Thread.yield 可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java 使用的线程调度方式就是抢占式调度。与前面所说的 Windows 3.x 的例子相对，在 Windows 9x/NT 内核中就是使用抢占式来实现多进程的，当一个进程出了问题，我们还可以使用任务管理器把这个进程『杀掉』，而不至于导致系统崩溃。 虽然 Java 线程调度是系统自动完成的，但是我们还是可以『建议』系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java 语言一共设置了 10 个级别的线程优先级（Thread.MIN_PRIORITY 至 Thread.MAX_PRIORITY），在两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。 不过，线程优先级并不是太靠谱，原因是 Java 的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与 Java 线程的优先级一一对应，如 Solaris 中有 2147483648（2³²）种优先级，但 Windows 中就只有 7 种，比 Java 线程优先级多的系统还好说，中间留下一点空位就可以了，但比 Java 线程优先级少的系统，就不得不出现几个优先级相同的情况了。下表显示了 Java 线程优先级与 Windows 线程优先级之间的对应关系，Windows 平台的 JDK 中使用了除 THREAD_PRIORITY_IDLE 之外的其余 6 种线程优先级。 Java 线程优先级与 Windows 线程优先级之间的对应关系 Java 线程优先级 Windows 线程优先级 1（Thread.MIN_PRIORITY） THREAD_PRIORITY_LOWEST 2 THREAD_PRIORITY_LOWEST 3 THREAD_PRIORITY_BELOW_NORMAL 4 THREAD_PRIORITY_BELOW_NORMAL 5（Thread.NORM_PRIORITY） THREAD_PRIORITY_NORMAL 6 THREAD_PRIORITY_ABOVE_NORMAL 7 THREAD_PRIORITY_ABOVE_NORMAL 8 THREAD_PRIORITY_HIGHEST 9 THREAD_PRIORITY_HIGHEST 10（Thread.MAX_PRIORITY） THREAD_PRIORITY_CRITICAL 上文说到『线程优先级并不是太靠谱』，不仅仅是说在一些平台上不同的优先级实际会变得相同这一点，还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变。 例如，在 Windows 系统中存在一个称为『优先级推进器』（Priority Boosting，当然它可以被关闭掉）的功能，它的大致作用就是当系统发现一个线程执行得特别『勤奋努力』的话，可能会越过线程优先级去为它分配执行时间。因此，我们不能在程序中通过优先级来完全准确地判断一组状态都为 Ready 的线程将会先执行哪一个。 状态转化Java 语言定义了 6 种线程状态（由 Thread 类内部枚举 State 定义），在任意一个时间点，一个线程只能有且只有其中的一种状态，这 6 种状态分别如下。 New：创建后尚未启动的线程处于这种状态。 RUNNABLE：包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间。 WAITING：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态： 没有设置 Timeout 参数的 Object.wait() 方法。 没有设置 Timeout 参数的 Thread.join() 方法。 LockSupport.park() 方法。 TIMED_WAITING：处于这种状态的线程也不会被分配 CPU 执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态： Thread.sleep()方法。 设置了 Timeout参数的 Object.wait() 方法。 设置了 Timeout参数的 Thread.join() 方法。 LockSupport.parkNanos() 方法。 LockSupport.parkUntil() 方法。 BLOCKED：线程被阻塞了，『阻塞状态』与『等待状态』的区别是：『阻塞状态』在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而『等待状态』则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 TERMINATED：已终止线程的线程状态，线程已经结束执行。 上述 6 种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如下图所示。 线程状态转换关系 小结Java 内存模型和操作系统内存模型的有着类似的结构。Java 线程是基于内核线程和用户线程混合使用的方式来实现的。 引用 《深入理解 Java 虚拟机》","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"内存模型","slug":"内存模型","permalink":"//huminxi.netlify.com/tags/内存模型/"}]},{"title":"Java 程序编译与代码优化续","slug":"Java 程序编译与代码优化续","date":"2019-12-23T13:30:53.000Z","updated":"2019-12-29T05:41:33.523Z","comments":true,"path":"2019/12/23/Java 程序编译与代码优化续/","link":"","permalink":"//huminxi.netlify.com/2019/12/23/Java 程序编译与代码优化续/","excerpt":"上一篇 我们主要是介绍编译期的代码优化，今天来介绍一下运行期的代码优化。在部分的商用虚拟机中（Sun HotSpot、IBM J9），Java 程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块运行的特别频繁时，就会把这些代码认定为『热点代码』（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码并进行优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，JIT 编译器）。","text":"上一篇 我们主要是介绍编译期的代码优化，今天来介绍一下运行期的代码优化。在部分的商用虚拟机中（Sun HotSpot、IBM J9），Java 程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块运行的特别频繁时，就会把这些代码认定为『热点代码』（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码并进行优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，JIT 编译器）。 概述即时编译器并不是虚拟机必需的部分，Java 虚拟机规范并没有规定 Java 虚拟机内必须要有即时编译器，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。 即时编译器由于 Java 虚拟机规范没有具体的规则去限制即时编译器应该如何实现，所以这部分功能完全依赖于虚拟机的具体实现，如无特殊说明，本文提及的编译器、即时编译器都是指 HotSpot 虚拟机内的即时编译器，虚拟机也是特指 HotSpot 虚拟机。 解释器与编译器解释器尽管并不是所有的 Java 虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如 HotSpot、J9 等，都同时包含解释器与编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样就可以获取更高的执行效率。 当程序运行环境中内存资源限制较大（如部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器激进优化时的一个『逃生门』，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现『罕见陷阱』（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的 C1 编译器担任『逃生门』的角色），因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，下图所示。 解释器与编译器的交互 编译器HotSpot 虚拟机中内置了两个即时编译器，分别称为 Client Compiler 和 Server Compiler，或者简称为 C1 编译器和 C2 编译器。在 HotSpot 虚拟机中，默认采用解释器与其中一个编译器互相配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式。 无论采用的编译器是 Client Compiler 还是 Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为『混合模式』（Mixed Mode），用户可以使用参数 -Xint 强制虚拟机运行于『解释模式』（Interpreted Mode），这时编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数 -Xcomp 强制虚拟机运行于『编译模式』（Compiled Mode），这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程，可以通过虚拟机的 -version 命令显示出这 3 种模式。 3 种模式 由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长。而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机还会逐渐启用分层编译（Tiered Compilation）的策略，分层编译的概念在 JDK 1.6 时期出现，后来一直处于改进阶段，最终在 JDK 1.7 的 Server 模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括： 第 0 层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第 1 层编译。 第 1 层，也称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。 第 2 层，也称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担性能监控的任务。 编译对象与触发条件编译对象在运行过程中会被即时编译器编译的『热点代码』有两类，即： 被多次调用的方法。 被多次执行的循环体。 前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为『热点代码』是理所当然的。而后者则是为了解决一个方法只被调用过少量的次数，但是方法体内部却存在循环次数较多的循环体的问题，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是『热点代码』。 对于第一种情况，是由方法调用触发的编译，编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的 JIT 编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对象。由于第二种编译方式发生在方法执行过程中，因此被形象地称之为栈上替换（On Stack Replacement，简称 OSR 编译，即方法栈帧还在栈上，整个方法就被替换了）。 触发条件判断一段代码是不是热点代码、是否需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection）。目前主要的热点探测判定方式有两种，分别如下： 基于采样的热点探测（Sample Based Hot Spot Detection） 采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是『热点方法』。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。 基于计数器的热点探测（Counter Based Hot Spot Detection） 采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是『热点方法』。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对来说更加精确。 HotSpot 虚拟机中使用的是第二种——基于计数器的热点探测方法，它为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值了，就会触发JIT编译。 方法调用计数器顾名思义，这个计数器就用于统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次，这个阈值可以通过虚拟机参数 -XX:CompileThreshold 来设定。当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在被 JIT 编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果超过阈值，将会向即时编译器提交一个编译该方法的请求。 如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。整个 JIT 编译的交互过程如下图所示。 方法调用计数器 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。热度衰减这个动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用 -XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。 回边计数器它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为『回边』（Back Edge）。当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译版本的代码，否则就把回边计数器的值加 1，然后判断方法调用计数器与回边计数器值之和是否超过阈值。当超过阈值时，将会提交一个 OSR 编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如下图所示。 回边计数器 与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环体执行的绝对次数。当回边计数器值超过阈值时，它还会把方法计数器的值也调整为超过阈值，这样下次再进入该方法的时候就会执行标准的 JIT 编译过程。 查看及分析即时编译结果OSR一般来说，虚拟机的即时编译过程对用户程序是完全透明的，虚拟机通过解释执行代码或者通过编译执行代码，对于用户来说并没有什么影响（执行结果没有影响，但速度上会有差别），在大多数情况下用户也没有必要知道。但是虚拟机也提供了一些参数用来输出即时编译和某些优化手段（如方法内联）的执行状况，本节将介绍如何从外部观察虚拟机的即时编译行为。 本节中提到的运行参数有一部分需要 Debug 或 FastDebug 版虚拟机的支持，Product 版的虚拟机无法使用这部分参数。Mac 用户可以参照这篇文章来 构建属于自己的 JDK，或者去网上下载已经构建好的 JDK。注意，本节中所有的测试都基于示例 1 中的代码。 代码示例 112345678910111213141516171819202122232425262728293031323334353637/** * 1.可以使用参数 -XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来。 * jvm 参数: -XX:+PrintCompilation * * 2.可以加上参数 -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining 要求虚拟机输出方法内联信息。 * jvm 参数: -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining * * 3.使用自己编译的 JDK 10，可以加参数。 * jvm 参数: -XX:+PrintOptoAssembly -XX:+PrintCFGToFile * * 4.使用 Ideal Graph Visualizer 工具。 * jvm 参数: -XX:PrintIdealGraphLevel=2 -XX:PrintIdealGraphFile=ideal.xml * */public class TestJIT &#123; public static final int NUM = 15000; public static int doubleValue(int i) &#123; for (int j = 0; j &lt; 1000000; j++) &#123; &#125; return i * 2; &#125; public static long calcSum() &#123; long sum = 0; for (int i = 0; i &lt; 100; i++) &#123; sum += doubleValue(i); &#125; return sum; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; NUM; i++) &#123; calcSum(); &#125; &#125;&#125; 首先运行这段代码，并且需要确认这段代码是否触发了即时编译。如果想知道某个方法是否被 JIT 编译过，可以使用参数 -XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来，如下图所示。（其中带有 % 的说明是由回边计数器触发的 OSR 编译）。 OSR 栈上替换 方法内联我们还可以加上参数 -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining 来要求虚拟机输出方法内联的信息，如下所示。 方法内联 本地机器码除了查看哪些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，不过如果虚拟机输出一串 0 和 1，对于我们来说是没有意义的，机器码必须反汇编成基本的汇编语言才可能被阅读。使用自己编译的 JDK 10，再加上参数 -XX:+PrintOptoAssembly -XX:+PrintCFGToFile 可以输出本地机器码反汇编结果，其中包含了许多注释。 部分本地机器码的反汇编信息 本地代码的生成过程如果想再进一步跟踪本地代码生成的具体过程，那还可以使用参数 -XX:+PrintCFGToFile（Client Compiler）或 -XX:PrintIdealGraphFile（Server Compiler）令虚拟机将编译过程中各个阶段的数据输出到文件中。下面以 Server Compiler 为例，一起来分析一下 JIT 编译器的代码生成过程。 Server Compiler 的中间代码表示是一种名为 Ideal 的 SSA 形式程序依赖图（ProgramDependence Graph），在 JVM 参数中加入 -XX:PrintIdealGraphLevel=2 -XX:PrintIdealGraphFile=ideal.xml，编译后将产生一个名为 ideal.xml 的文件，它包含了 Server Compiler 编译代码的过程信息，可以使用 Ideal Graph Visualizer 对这些信息进行分析。ideal-xml 文件 用 Ideal Graph Visualizer 加载 ideal.xml 文件后，Outline 面板上将显示程序运行过程中编译过的方法列表，如下图所示。这里列出的方法是示例 1 中的代码，其中 doubleValue 方法出现了两次，这是由于该方法的编译结果存在标准 JIT 编译和 OSR 编译两个版本。Ideal Graph Visualizer 在代码示例 1 中，笔者特别为 doubleValue 方法增加了一个空循环，这个循环对方法的运算结果不会产生影响，但如果没有任何优化，执行空循环会占用 CPU 时间，到今天还有许多程序设计的入门教程把空循环当做程序延时的手段来介绍，在 Java 中这样的做法真的能起到延时的作用吗？ 展开方法根节点，可以看到下面罗列了方法优化过程的各个阶段（根据优化措施的不同，每个方法所经过的阶段也会有所差别）。我们先打开『After Parsing』这个阶段，JIT 编译器在编译一个 Java 方法时，首先要把字节码解析成某种中间表示形式，然后才可以继续做分析和优化，最终生成代码。『After Parsing』就是 Server Compiler 刚完成解析，还没有做任何优化时的 Ideal 图表示，图中每一个方块就代表了一个程序的基本块（Basic Block），而右侧的 Control Flow 则代表了基本块的执行逻辑。After Parsing 这样我们要看空循环是否被优化，或者何时优化，只要观察代表循环的基本块是否被消除，或者何时消除就可以了。 要观察到这一点，可以在 Outline 面板上右键点击『Difference to current graph』，让软件自动分析指定阶段与当前打开的 Ideal 图之间的差异，如果基本块被消除了，将会以红色显示。对『After Parsing』和『PhaseIdealLoop 1』阶段的 Ideal 图进行差异分析，发现在『PhaseIdealLoop1』阶段循环操作被消除了，如图下图所示，这也就说明空循环实际上是不会被执行的。PhaseIdealLoop 1 从『After Parsing』阶段开始，一直到最后的『Final Code』阶段，可以看到 doubleValue 方法的 Ideal 图从繁到简的过程，这也是 Java 虚拟机在尽力优化代码的过程。到了最后的『Final Code』阶段，不仅空循环的开销消除了，许多语言安全和 Safepoint 轮询的操作也一起消除了，因为编译器判断即使不做这些安全保障，虚拟机也不会受到威胁。 final-code 最后提醒一下读者，要输出 CFG 或 IdealGraph 文件，需要一个 Debug 版或 FastDebug 版的虚拟机支持，Product 版的虚拟机无法输出这些文件。 这里 是一个相对比较全面的、在即时编译器中采用的优化技术列表，其中有经典的编译器优化手段，也有针对 Java 语言（准确地说是针对运行在 Java 虚拟机上的语言）本身进行的优化技术，感兴趣的同学可以自行阅读。 Java 与 C/C++ 的编译器对比大多数程序员都认为 C/C++ 会比 Java 语言快，甚至觉得从 Java 语言诞生以来『执行速度缓慢』的帽子就应当扣在它的头顶，这种观点的出现是由于 Java 在刚出现的时候即时编译技术还不成熟，主要靠解释器执行的 Java 语言性能确实比较低下。但目前即时编译技术已经十分成熟，Java 语言有可能在速度上与 C/C++ 一争高下吗？要想知道这个问题的答案，让我们从两者的编译器谈起。 Java 与 C/C++ 的编译器对比实际上代表了即时编译器与静态编译器的对比，很大程度上也决定了 Java 与 C/C++ 的性能对比的结果，因为无论是 C/C++ 还是 Java 代码，最终编译之后被机器执行的都是本地机器码，哪种语言的性能更高，除了它们自身的 API 库实现得好坏以外，其余的比较就成了一场『拼编译器』和『拼输出代码质量』的游戏。当然，这种比较也是剔除了开发效率的片面对比，语言间孰优孰劣、谁快谁慢的问题都是很难有结果的争论，下面我们就回到正题，看看这两种语言的编译器各有何种优势。 Java 的劣势Java 虚拟机的即时编译器与 C/C++ 的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势： 第一，因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。如果编译速度不能达到要求，那用户将在启动程序或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。 第二，Java 语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面上看，这就意味着虚拟机必须频繁地进行动态检查，如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时间。 第三，Java 语言中虽然没有 virtual 关键字，但是使用 虚方法 的频率却远远大于 C/C++ 语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于 C/C++ 语言，也意味着即时编译器在进行一些优化（例如方法内联）时的难度要远大于 C/C++ 的静态优化编译器。 第四，Java 语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行，因为编译器无法看见程序的全貌，许多全局的优化措施都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。 第五，Java 语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上分配。而 C/C++ 的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++ 中主要由用户程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅指运行效率，排除了开发效率）也比垃圾收集机制要高。 Java 的优势上面说了一大堆 Java 语言相对 C/C++ 的劣势，不是说 Java 就真的不如 C/C++了，相信读者也注意到了，Java 语言的这些性能上的劣势都是为了换取开发效率上的优势而付出的代价，动态安全、动态扩展、垃圾回收这些『拖后腿』的特性都为 Java 语言的开发效率做出了很大贡献。 何况，还有许多优化是 Java 的即时编译器能做而 C/C++ 的静态优化编译器不能做或者不好做的。例如，在 C/C++ 中，别名分析（Alias Analysis）的难度就要远高于 Java。Java 的类型安全保证了在类似如下代码中，只要 ClassA 和 ClassB 没有继承关系，那对象 objA 和 objB 就绝不可能是同一个对象，即不会是同一块内存两个不同别名。代码示例 2123456void foo(ClassA objA, ClassB objB)&#123; objA.x=123; objB.y=456; //只要 objB.y 不是 objA.x 的别名，下面就可以保证输出为 123 print(objA.x);&#125; 确定了 objA 和 objB 并非对方的别名后，许多与数据依赖相关的优化才可以进行（重排序、变量代换）。具体到这个例子中，就是无须担心 objB.y 其实与 objA.x 指向同一块内存，这样就可确定打印语句中的 objA.x 为 123。 Java 编译器另外一个红利是由它的动态性所带来的，由于 C/C++ 编译器所有优化都在编译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测（Call Frequency Prediction）、分支频率预测（Branch Frequency Prediction）、裁剪未被选择的分支（Untaken Branch Pruning）等，这些都会成为 Java 语言独有的性能优势。 小结《Java 程序编译与代码优化》、《Java 程序编译与代码优化续》分别介绍了 Java 程序从源码编译成字节码和从字节码编译成本地机器码的过程，虚拟机外部的 Javac 字节码编译器与虚拟机内部的 JIT 编译器的执行过程合并起来其实就等同于一个传统编译器所执行的编译过程。 通过这两篇文章，我们了解了虚拟机的热点探测方法、HotSpot 的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析 JIT 编译的数据和结果。对 Java 编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以自动帮我们处理的，哪些代码需要自己调节以便于编译器优化的。 引用 《深入理解 Java 虚拟机》","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"编译","slug":"编译","permalink":"//huminxi.netlify.com/tags/编译/"},{"name":"代码优化","slug":"代码优化","permalink":"//huminxi.netlify.com/tags/代码优化/"}]},{"title":"Java 程序编译与代码优化","slug":"Java 程序编译与代码优化","date":"2019-12-10T06:00:18.000Z","updated":"2020-01-02T07:22:15.255Z","comments":true,"path":"2019/12/10/Java 程序编译与代码优化/","link":"","permalink":"//huminxi.netlify.com/2019/12/10/Java 程序编译与代码优化/","excerpt":"因为 Java 代码到机器码之间还存在着字节码，所以 Java 语言的『编译期』其实是一段不确定的过程。它可能是指一个前端编译器把 *.java 文件转变成 *.class 文件的过程；也可能是指虚拟机的运行期编译器（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程；还可能是指使用提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成机器码的过程。","text":"因为 Java 代码到机器码之间还存在着字节码，所以 Java 语言的『编译期』其实是一段不确定的过程。它可能是指一个前端编译器把 *.java 文件转变成 *.class 文件的过程；也可能是指虚拟机的运行期编译器（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程；还可能是指使用提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成机器码的过程。 概述下面列举了这 3 类编译过程中一些比较有代表性的编译器。 前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。 JIT 编译器：HotSpot VM 的 C1、C2 编译器。 AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 这 3 类中最符合大家对 Java 程序编译认知的应该是第一类。在限定了编译范围之后，我们需要放宽『代码优化』的定义，因为 Javac 这类编译器对代码的运行效率几乎没有任何优化措施。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由 Javac 产生的 Class 文件（如 JRuby、Groovy 等语言的 Class 文件）也同样能享受到编译器优化所带来的好处。不过 Javac 也做了许多针对 Java 语言编码过程的优化来改善程序员的编码风格和提高编码效率。许多新生的 Java 语法特性，都是靠编译器的『语法糖』来实现，而不是依赖虚拟机的底层改进来支持。总的来说，前端编译器在编译期的优化过程对于程序编码来说更重要，即时编译器在运行期的优化过程对于程序运行来说更重要。 编译期优化Javac 编译器了解一项技术的实现内幕的最有效的手段是分析源码。Javac 编译器不像 HotSpot 虚拟机那样使用 C++ 语言实现，它本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。 源码下载去 OpenJDK 的官网下载源码。 openjdk 8 源码目录 创建一个 javac-source-code 项目，将 src/share/classes/com 目录下的所有内容拷贝至 src 目录。 执行 main 方法导入 Javac 的源码后，就可以运行 com.sun.tools.javac.Main 的 main 方法来执行编译了，这与直接在命令行中使用 Javac 没有什么区别。Javac 主函数入口 运行 main 方法，由于我们没有指定要编译的源代码路径，控制台会输出下面的内容。 新建一个 HelloWorld.java 文件，并在启动配置中加入这个文件的绝对路径。 再次运行 main 方法，最终会在 HelloWorld.java 的同级目录下生成 HelloWorld.class 文件。 加断点在 Main.java 中打上断点，然后发现不管怎么设置，调试时总会进入 JDK 自带的 Main.java 方法，没有进入自己打断点的地方。 打开 Project Structure 页面（File-&gt;Project Structure），选中图中 Dependencies 选项，将 &lt;Module source&gt; 顺序调整到 JDK 之前。 再次调试就可以进入到项目中的断点了。 Javac 的编译过程将一组源文件编译为一组相应的类文件的过程并不简单，但通常可以分为 三个过程： 解析与填充符号表过程 读取命令行上指定的源文件，将其解析为语法树，然后输出到符号表中。 注解处理过程 调用注解处理器。如果注解处理器生成了新的源文件，则重新编译，直到没有新文件创建为止。 分析和字节码生成过程 最后，分析语法树并将其转换为类文件。 Javac 的编译过程 Javac 编译动作的入口是 com.sun.tools.javac.main.JavaCompiler 类，上述 3 个过程的逻辑集中在这个类的 compile 和 compile2 方法中，其中主体代码如下图所示。整个编译最关键的处理就由图中标注的 8 个方法来完成。compile 代码片段compile2 代码片段 语法糖几乎各种语言都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高开发效率，或能提升语法的严谨性，或能减少编码出错的机会。不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用含糖的语法，容易让程序员产生依赖，无法看清语法糖背后程序代码的真实面目。 泛型与类型擦除泛型是 JDK 1.5 带来的一项新特性，它的本质是参数化类型（Parameterized Type）。也就是说，所操作的数据类型被指定为一个参数。这种参数可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。 Java 语言中的泛型只在程序源码中存在，在编译后的字节码文件中就已经替换成原来的类型了，并且在相应的地方插入了强制类型转换代码。因此，对于运行期的 Java 语言来说，ArrayList&lt;int&gt; 与 ArrayList&lt;String&gt; 就是同一个类，所以泛型技术实际上是 Java 语言的一颗语法糖，Java 语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。 示例 11234567public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"hello\", \"你好\"); map.put(\"how are you\", \"吃了没\"); System.out.println(map.get(\"hello\")); System.out.println(map.get(\"how are you\"));&#125; 把这段 Java 代码编译成 Class 文件，然后利用反编译工具(jd-gui-1.4.2)进行反编译后，发现泛型不见了，程序又变回了原生类型（Raw Type）。反编译后1234567public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap(); map.put(\"hello\", \"你好\"); map.put(\"how are you\", \"吃了没\"); System.out.println((String) map.get(\"hello\")); //这里进行了强制类型转换 System.out.println((String) map.get(\"how are you\")); &#125; 示例 212345public static void main(String[] args) &#123; Class&lt;? extends ArrayList&gt; aClass = new ArrayList&lt;String&gt;().getClass(); Class&lt;? extends ArrayList&gt; bClass = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(aClass == bClass);&#125; 反编译后12345public static void main(String[] args) &#123; Class&lt;? extends ArrayList&gt; aClass = new ArrayList().getClass(); //实际上创建的依然是 ArraysList 对象。 Class&lt;? extends ArrayList&gt; bClass = new ArrayList().getClass(); System.out.println(aClass == bClass);&#125; 代码的输出结果为 true。可以看出，新建的两个不同的 ArraysList&lt;&gt; 对象，编译之后都是 ArraysList，没有了泛型信息。 自动装箱、拆箱与遍历循环从纯技术的角度来讲，自动装箱、自动拆箱与遍历循环（Foreach 循环）这些语法糖，无论是实现上还是思想上都不能和上文介绍的泛型相比，两者的难度和深度都有很大差距。专门拿出一节来讲解它们只有一个理由：它们是 Java 语言里使用得最多的语法糖。 示例 312345678public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4); int sum = 0; for (int i : list) &#123; sum += i; &#125; System.out.println(sum);&#125; 反编译后123456789public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(new Integer[]&#123;Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4)&#125;); int sum = 0; for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123; int i = ((Integer) localIterator.next()).intValue(); sum += i; &#125; System.out.println(sum);&#125; 示例 3 中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数 5 种语法糖，我们一起来分析一下反编译后的代码。泛型就不必说了；自动装箱、拆箱在编译之后被转化成了对应的包装方法和还原方法，如本例中的 Integer.valueOf() 与 Integer.intValue() 方法；而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环要求被遍历的类实现 Iterable 接口的原因；最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员就是使用数组来完成类似功能的。 条件编译 许多程序设计语言都提供了条件编译的途径，如 C、C++ 中使用预处理器指示符 #ifdef 来完成条件编译。C、C++ 的预处理器最初的任务是解决编译时的代码依赖关系（如常用的 #include 预处理命令），而在 Java 语言之中并没有使用预处理器，因为 Java 语言的编译方式无须使用预处理器（编译器并非一个个地编译 Java 文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）。 那 Java 语言是否有办法实现条件编译呢？Java 语言当然也可以进行条件编译，方法就是使用条件是常量的 if 语句。 示例 412345678910111213141516public class ConditionCompile &#123; public static final int a = 1; public static void main(String[] args) &#123; if (true) &#123; System.out.println(\"block 1\"); &#125; else &#123; System.out.println(\"block 2\"); &#125; if (a == 1) &#123; System.out.println(\"block 3\"); &#125; else &#123; System.out.println(\"block 4\"); &#125; &#125;&#125; 反编译后12345678910111213import java.io.PrintStream;public class ConditionCompile &#123; public static final int a = 1; public static void main(String[] args) &#123; System.out.println(\"block 1\"); System.out.println(\"block 3\"); &#125;&#125; 如示例 4 所示，此代码中的 if 语句不同于其他 Java 代码，它在编译阶段就会被『运行』，生成的字节码之中只包括 System.out.println(&quot;block 1&quot;) System.out.println(&quot;block 1&quot;) 两条语句，并不会包含 if 语句及另外一个分支中的 System.out.println(&quot;block 2&quot;) System.out.println(&quot;block 4&quot;) 语句。 Java 语言中条件编译的实现，也是 Java 语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（com.sun.tools.javac.comp.Lower 类中）完成。由于这种条件编译的实现方式使用了 if 语句，所以它必须遵循最基本的 Java 语法，只能写在方法体内部，因此它只能实现语句基本块（Block）级别的条件编译，而没有办法实现根据条件调整整个 Java 类的结构。 枚举123public enum Week &#123; Mon,Tue,Wed,Thu, Fri, Sat,Sun;&#125; 使用 javap -p Week.class 反编译之后1234567891011121314public final class jvm.javac.suger.Week extends java.lang.Enum&lt;jvm.javac.suger.Week&gt; &#123; public static final jvm.javac.suger.Week Mon; public static final jvm.javac.suger.Week Tue; public static final jvm.javac.suger.Week Wed; public static final jvm.javac.suger.Week Thu; public static final jvm.javac.suger.Week Fri; public static final jvm.javac.suger.Week Sat; public static final jvm.javac.suger.Week Sun; private static final jvm.javac.suger.Week[] $VALUES; public static jvm.javac.suger.Week[] values(); public static jvm.javac.suger.Week valueOf(java.lang.String); private jvm.javac.suger.Week(); static &#123;&#125;;&#125; 可以看到，字节码中并不存在 enum 类型，所有的枚举类都继承自 java.lang.Enum 这个类。 Javac 编译器将 Week 类改成了 final 类型，这样就不能被继承，同时还将它的构造方法改成了 private，这样就不能通过 new 的方式来新增 Week 类的实例。 编写一个注解处理器实战目标通过阅读 Javac 编译器的源码，我们知道编译器在把 Java 程序源码编译为字节码的时候，会对 Java 程序源码做各方面的检查校验。这些校验主要以程序『写得对不对』为出发点，虽然也有各种 Warning 的信息，但总体来讲还是较少去校验程序『写得好不好』。有鉴于此，业界出现了许多针对程序『写得好不好』的辅助校验工具，如 CheckStyle、FindBug、Klocwork 等。这些代码校验工具有一些是基于 Java 的源码进行校验，还有一些是通过扫描字节码来完成，在本节的实战中，我们将会使用注解处理器 API 来编写一款拥有自己编码风格的校验工具：NameCheckProcessor。 当然，由于我们的实战都是为了学习和演示技术原理，而不是为了做出一款能媲美 CheckStyle 等工具的产品来，所以 NameCheckProcessor 的目标也仅定为对 Java 程序命名进行检查，根据《Java语言规范》中的要求，Java 程序命名应当符合下列格式的书写规范： 类（或接口）：符合驼式命名法，首字母大写。 方法：符合驼式命名法，首字母小写。 字段： 类或实例变量：符合驼式命名法，首字母小写。 常量：要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。 上文提到的驼式命名法（Camel Case Name），正如它的名称所表示的那样，是指混合使用大小写字母来分割构成变量或函数的名字，犹如驼峰一般，这是当前 Java 语言中主流的命名规范，我们的实战目标就是为 Javac 编译器添加一个额外的功能，在编译程序时检查程序名是否符合上述对类（或接口）、方法、字段的命名要求(参照 JDK 中的 com.sun.tools.javac.processing.PrintingProcessor 类)。 代码实现要通过注解处理器 API 实现一个编译器插件，首先需要了解这组 API 的一些基本知识。我们实现注解处理器的代码需要继承抽象类 javax.annotation.processing.AbstractProcessor，这个抽象类中有一个必须要覆盖的 process 方法，它是 Javac 编译器在执行注解处理器代码时要调用的过程。我们可以从这个方法的第一个参数 annotations 中获取到此注解处理器所要处理的注解集合，从第二个参数 roundEnv 中访问到当前这个 Round 中的语法树节点，每个语法树节点在这里表示为一个 Element。 除了 process 方法的入参之外，还有一个很常用的实例变量 processingEnv，它是 AbstractProcessor 中的一个 protected 变量，在注解处理器初始化的时候创建，继承了 AbstractProcessor 的类可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、向编译器输出信息、获取其他工具类等都需要用到这个实例变量。 注解处理器还有两个可以配合使用的 Annotations：@SupportedAnnotationTypes 和 @SupportedSourceVersion，前者代表了这个注解处理器对哪些注解感兴趣，可以使用星号 * 作为通配符代表对所有的注解都感兴趣，后者指出这个注解处理器可以处理哪些版本的 Java 代码。 每一个注解处理器在运行的时候都是单例的，如果不需要改变语法树的内容，process 方法就可以返回一个值为 false 的布尔值，通知编译器这个 Round 中的代码未发生变化，无须构造新的 JavaCompiler 实例，在这次实战的注解处理器中只对程序命名进行检查，不需要改变语法树的内容，因此 process 方法的返回值为 false。 NameCheckProcessor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package jvm.javac.processor;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.ProcessingEnvironment;import javax.annotation.processing.RoundEnvironment;import javax.annotation.processing.SupportedAnnotationTypes;import javax.annotation.processing.SupportedSourceVersion;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.TypeElement;/** * 在代码的根目录(src)下依次执行: * javac jvm/javac/processor/NameCheckProcessor.java * javac -processor jvm.javac.processor.NameCheckProcessor jvm/javac/processor/BADLY_NAMED_CODE.java * &lt;p&gt; * 可以用 * 表示支持所有 Annotations * 只支持 JDK 1.8 的 Java 代码 */@SupportedAnnotationTypes(\"*\")@SupportedSourceVersion(value = SourceVersion.RELEASE_8)public class NameCheckProcessor extends AbstractProcessor &#123; private NameChecker nameChecker; /** * 初始化名称检查插件 */ @Override public void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); nameChecker = new NameChecker(processingEnv); &#125; /** * 对输入的语法树的各个节点进行进行名称检查 */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; if (!roundEnv.processingOver()) &#123; for (Element element : roundEnv.getRootElements()) nameChecker.checkNames(element); &#125; return false; &#125;&#125; 从上面代码可以看出，NameCheckProcessor 能处理基于 JDK 1.8 的源码，它不限于特定的注解，对任何注解都感兴趣，而在 process 方法中是把当前 Round 中的每一个 RootElement 传递到一个名为 NameChecker 的检查器中执行名称检查逻辑，NameChecker 的代码如代码如下所示。NameChecker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package jvm.javac.processor;import javax.annotation.processing.Messager;import javax.annotation.processing.ProcessingEnvironment;import javax.lang.model.element.*;import javax.lang.model.util.ElementScanner8;import javax.tools.Diagnostic.Kind;import java.util.EnumSet;/** * 程序名称规范的编译器插件： * 如果程序命名不合规范，将会输出一个编译器的 WARNING 信息 */public class NameChecker &#123; private final Messager messager; NameCheckScanner nameCheckScanner = new NameCheckScanner(); NameChecker(ProcessingEnvironment processsingEnv) &#123; this.messager = processsingEnv.getMessager(); &#125; /** * 对Java程序命名进行检查，根据《Java语言规范》第三版第 6.8 节的要求，Java程序命名应当符合下列格式： * * &lt;ul&gt; * &lt;li&gt;类或接口：符合驼式命名法，首字母大写。 * &lt;li&gt;方法：符合驼式命名法，首字母小写。 * &lt;li&gt;字段： * &lt;ul&gt; * &lt;li&gt;类、实例变量: 符合驼式命名法，首字母小写。 * &lt;li&gt;常量: 要求全部大写。 * &lt;/ul&gt; * &lt;/ul&gt; */ public void checkNames(Element element) &#123; nameCheckScanner.scan(element); &#125; /** * 名称检查器实现类，继承了 JDK 1.8 中提供的 ElementScanner8 * 将会以 Visitor 模式访问抽象语法树中的元素 */ private class NameCheckScanner extends ElementScanner8&lt;Void, Void&gt; &#123; /** * 此方法用于检查 Java 类 */ @Override public Void visitType(TypeElement e, Void p) &#123; scan(e.getTypeParameters(), p); checkCamelCase(e, true); super.visitType(e, p); return null; &#125; /** * 检查方法命名是否合法 */ @Override public Void visitExecutable(ExecutableElement e, Void p) &#123; if (e.getKind() == ElementKind.METHOD) &#123; Name name = e.getSimpleName(); if (name.contentEquals(e.getEnclosingElement().getSimpleName())) messager.printMessage(Kind.WARNING, \"一个普通方法“\" + name + \"”不应当与类名重复，避免与构造函数产生混淆\", e); checkCamelCase(e, false); &#125; super.visitExecutable(e, p); return null; &#125; /** * 检查变量命名是否合法 */ @Override public Void visitVariable(VariableElement e, Void p) &#123; // 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查 if (e.getKind() == ElementKind.ENUM_CONSTANT || e.getConstantValue() != null || heuristicallyConstant(e)) checkAllCaps(e); else checkCamelCase(e, false); return null; &#125; /** * 判断一个变量是否是常量 */ private boolean heuristicallyConstant(VariableElement e) &#123; if (e.getEnclosingElement().getKind() == ElementKind.INTERFACE) return true; else if (e.getKind() == ElementKind.FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(javax.lang.model.element.Modifier.PUBLIC, javax.lang.model.element.Modifier.STATIC, javax.lang.model.element.Modifier.FINAL))) return true; else &#123; return false; &#125; &#125; /** * 检查传入的 Element 是否符合驼式命名法，如果不符合，则输出警告信息 */ private void checkCamelCase(Element e, boolean initialCaps) &#123; String name = e.getSimpleName().toString(); boolean previousUpper = false; boolean conventional = true; int firstCodePoint = name.codePointAt(0); if (Character.isUpperCase(firstCodePoint)) &#123; previousUpper = true; if (!initialCaps) &#123; messager.printMessage(Kind.WARNING, \"名称“\" + name + \"”应当以小写字母开头\", e); return; &#125; &#125; else if (Character.isLowerCase(firstCodePoint)) &#123; if (initialCaps) &#123; messager.printMessage(Kind.WARNING, \"名称“\" + name + \"”应当以大写字母开头\", e); return; &#125; &#125; else conventional = false; if (conventional) &#123; int cp = firstCodePoint; for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123; cp = name.codePointAt(i); if (Character.isUpperCase(cp)) &#123; if (previousUpper) &#123; conventional = false; break; &#125; previousUpper = true; &#125; else previousUpper = false; &#125; &#125; if (!conventional) messager.printMessage(Kind.WARNING, \"名称“\" + name + \"”应当符合驼式命名法（Camel Case Names）\", e); &#125; /** * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母 */ private void checkAllCaps(Element e) &#123; String name = e.getSimpleName().toString(); boolean conventional = true; int firstCodePoint = name.codePointAt(0); if (!Character.isUpperCase(firstCodePoint)) conventional = false; else &#123; boolean previousUnderscore = false; int cp = firstCodePoint; for (int i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123; cp = name.codePointAt(i); if (cp == (int) '_') &#123; if (previousUnderscore) &#123; conventional = false; break; &#125; previousUnderscore = true; &#125; else &#123; previousUnderscore = false; if (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123; conventional = false; break; &#125; &#125; &#125; &#125; if (!conventional) messager.printMessage(Kind.WARNING, \"常量“\" + name + \"”应当全部以大写字母或下划线命名，并且以字母开头\", e); &#125; &#125;&#125; NameChecker 的代码看起来有点长，但实际上注释占了很大一部分，其实即使算上注释也不到 180 行。它通过一个继承于 javax.lang.model.util.ElementScanner8 的 NameCheckScanner 类，以 Visitor 模式来完成对语法树的遍历，分别执行 visitType、visitVariable 和 visitExecutable 方法来访问类、字段和方法，这 3 个 visit 方法对各自的命名规则做相应的检查，checkCamelCase 与 checkAllCaps 方法则用于实现驼式命名法和全大写命名规则的检查。 整个注解处理器只需 NameCheckProcessor 和 NameChecker 两个类就可以全部完成，为了验证我们的实战成果，我们编写一个反面教材代码，其中的每一个类、方法及字段的命名都存在问题，但是使用普通的 Javac 编译这段代码时不会提示任何一个 Warning 信息。 BADLY_NAMED_CODE123456789101112131415161718public class BADLY_NAMED_CODE &#123; enum colors &#123; red, blue, green; &#125; static final int _FORTY_TWO = 42; public static int NOT_A_CONSTANT = _FORTY_TWO; protected void BADLY_NAMED_CODE() &#123; return; &#125; public void NOTcamelCASEmethodNAME() &#123; return; &#125;&#125; 运行与测试我们可以通过 Javac 命令的 -processor 参数来执行编译时需要附带的注解处理器，如果有多个注解处理器的话，用逗号分隔。 其它应用案例NameCheckProcessor 的实战例子只演示了 JSR-269 嵌入式注解处理器 API 中的一部分功能，基于这组 API 支持的项目还有用于校验 Hibernate 标签使用正确性的 Hibernate Validator Annotation Processor（本质上与 NameCheckProcessor 所做的事情差不多）、自动为字段生成 getter 和 setter 方法的 Project Lombok（根据已有元素生成新的语法树元素）等，有兴趣的读者可以参阅它们的官方文档。 运行期优化鉴于篇幅限制，运行期优化的相关内容我们留到 下一篇 中再进行介绍。 引用 《深入理解 Java 虚拟机》 Javac 源码调试教程 Compilation Overview","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"编译","slug":"编译","permalink":"//huminxi.netlify.com/tags/编译/"},{"name":"代码优化","slug":"代码优化","permalink":"//huminxi.netlify.com/tags/代码优化/"}]},{"title":"new 一个对象的过程中发生了什么","slug":"new 一个对象的过程中发生了什么","date":"2019-11-21T07:16:09.000Z","updated":"2019-11-22T11:25:03.657Z","comments":true,"path":"2019/11/21/new 一个对象的过程中发生了什么/","link":"","permalink":"//huminxi.netlify.com/2019/11/21/new 一个对象的过程中发生了什么/","excerpt":"JVM 在 new 一个对象的时候，会先查看对象所属的类有没有被加载到内存。如果没有的话，就通过类的全限定名来加载，等类加载完成之后，再创建对象。总的来说， new 一个对象可以分为两个过程：类加载和创建对象。","text":"JVM 在 new 一个对象的时候，会先查看对象所属的类有没有被加载到内存。如果没有的话，就通过类的全限定名来加载，等类加载完成之后，再创建对象。总的来说， new 一个对象可以分为两个过程：类加载和创建对象。 类加载虚拟机把描述类的数据从 Class 文件（不一定存在于磁盘中，这里所说的 Class 文件应当是一串二进制的字节流，无论以何种形式存在都可以）加载到内存，并对数据进行连接和初始化，最终形成可以被虚拟机直接使用的 Class 对象。 与那些在编译时需要进行连接工作的语言不同，在 Java 语言里，Class 的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然令类加载时增加一些性能开销，但是会给 Java 应用程序带来高度的灵活性。 例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其具体的实现类；用户可以通过 Java 预定义或自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGi 技术，都使用了 Java 语言运行期加载类的特性。 类加载的时机类的生命周期从加载到内存中开始，到卸载出内存为止，类的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析这 3 个阶段统称为连接。 类的生命周期 加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类加载的过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定。注意，这里笔者写的是按部就班地『开始』，而不是按部就班地『进行』或『完成』，强调这点是因为这些阶段通常都是互相交叉进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。 类的初始化条件什么情况下需要开始类加载过程的第一个阶段？Java 虚拟机规范中并没有进行强制约束，这由具体的虚拟机实现自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了以下 5 种情况必须立即对类进行『初始化』（加载、验证、准备自然需要在此之前开始）： 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main 方法的那个类），虚拟机会先初始化这个主类。 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果包含 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 对于这 5 种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：『有且仅有』，这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。下面举 3 个例子来说明何为被动引用： 代码示例 1-1 1234567891011121314151617181920212223242526272829303132333435363738public class SuperClass &#123; static &#123; System.out.println(\"SuperClass init\"); &#125; public static int value = 123;&#125;public class SubClass extends SuperClass &#123; static &#123; System.out.println(\"SubClass init\"); &#125;&#125;public class ConstClass &#123; static &#123; System.out.println(\"ConstantClass init\"); &#125; public static final String HELLO_WORLD=\"hello world\";&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; /** * 例子1：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 */ System.out.println(SubClass.value); /** * 例子2：通过数组定义来引用类，不会触发此类的初始化 */ SuperClass[] sca = new SuperClass[10]; /** * 例子3：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 */ System.out.println(ConstClass.HELLO_WORLD); &#125;&#125; 运行结果 类加载的过程接下来我们详细讲解一下 Java 虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。 加载加载是类加载过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在方法区中生成一个代表这个类的 java.lang.Class 对象，作为这个类的访问入口。 虚拟机规范的这 3 点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如『通过一个类的全限定名来获取定义此类的二进制字节流』这条，它没有指明二进制字节流要从一个 Class 文件中获取，准确地说是根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的舞台，Java 发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的 Java 技术都建立在这一基础之上，例如： 从 ZIP 包中读取，这很常见，最终成为 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用就是 Applet。 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 $Proxy 的代理类的二进制字节流。 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 验证验证阶段是连接的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 Java 语言本身是相对安全的语言（相对于 C/C++ 来说），使用纯粹的 Java 代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class 文件并不一定要求用 Java 源码编译而来，可以使用任何途径产生，甚至可以用十六进制编辑器直接编写 Class 文件。在字节码语言层面上，上述 Java 代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证 Class 文件是虚拟机对自身的一种保护工作。 验证又大致分为 4 个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。 文件格式验证第一阶段要验证字节流是否符合 Class 文件格式 的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点： 是否以魔数 0xCAFEBABE 开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。… 元数据验证第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，这个阶段可能包括的验证点如下： 这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 字节码验证第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如： 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个 int 类型的数据，使用时却按 long 类型来加载入本地变量表中。 保证跳转指令不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。… 如果一个方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。 即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题 停机问题。 符号引用验证最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合字段描述符所描述的方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。… 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。 对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。这里有两点需要强调一下： 这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 这里所说的初始值『通常情况』下是数据类型的零值。 假设一个类变量的定义为： 1public static int value=123; 那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。把 value 赋值为 123 的 putstatic 指令存放于类构造器方法 &lt;clinit&gt;() 之中，所以把 value 赋值为 123 的动作将在初始化阶段执行。下表列出了 Java 中所有基本数据类型的零值。 数据类型 零值 数据类型 零值 int 0 boolean false long 0 L float 0.0 f short (short) 0 double 0.0 d char ‘\\u0000’ reference null byte (byte) 0 上面提到，在『通常情况』下初始值是零值，那么也存在一些『特殊情况』。如果将类变量 value 的定义改为：1public static final int value=123; 那么在准备阶段时，虚拟机会直接将 value 赋值为 123。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化初始化阶段是类加载过程的最后一步，在前面的类加载过程中，除了加载阶段用户应用程序可以通过自定义的类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。 在准备阶段，变量已经赋过一次系统要求的零值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。 或者可以从另外一个角度来表达：初始化阶段是执行类构造器方法 &lt;clinit&gt;() 的过程。 &lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码示例 1-2 所示。 代码示例 1-2 12345678public class Test &#123; static &#123; i = 0; //给变量赋值可以正常编译通过。 System.out.println(i); //这句编译器会提示 \"illegal forward reference\"。 &#125; static int i = 1;&#125; 类加载机制虚拟机设计团队把加载阶段中『通过一个类的全限定名来获取定义此类的二进制字节流』这个动作放到了 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为类加载器。 类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 Java Applet 的需求而开发出来的。虽然目前 Java Applet 技术基本上已经死掉，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了 Java 技术体系中一块重要的基石，可谓是失之东隅，收之桑榆。 类与类加载器类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否『相等』，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 这里所指的『相等』，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属类型的判定。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。代码示例 1-3 演示了不同的类加载器对 instanceof 关键字运算结果的影响。 代码示例 1-31234567891011121314151617181920212223242526/** * 类加载器与 instanceof 关键字演示 */public class ClassLoaderTest &#123; public static void main(String[] args) throws Exception&#123; ClassLoader myLoader = new ClassLoader() &#123; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) &#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125;catch (Exception e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass(\"jvm.clazz.ClassLoaderTest\").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof jvm.clazz.ClassLoaderTest); &#125;&#125; 运行结果 代码清单 1-3 中构造了一个简单的类加载器。它可以加载与自己在同一路径下的 Class 文件。我们使用这个类加载器去加载了一个名为 jvm.clazz.ClassLoaderTest 的类，并实例化了这个类的对象。两行输出结果中，从第一行可以看出，这个对象确实是类 jvm.clazz.ClassLoaderTest 实例化出来的对象，但从第二行可以发现，这个对象与类 jvm.clazz.ClassLoaderTest 做所属类型检查的时候却返回了 false。这是因为虚拟机中存在了两个 jvm.clazz.ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为 false。 双亲委派模型从 Java 虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分。 另一种就是所有其它的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader） 这个类将器负责将存放在 &lt;JAVA_HOME&gt;/jre/lib 目录中的，并且是虚拟机识别的（按照文件名识别，如 rt.jar）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader） 这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 &lt;JAVA_HOME&gt;/lib 目录中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader） 这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图所示。 类加载器双亲委派模型 图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 类加载器的双亲委派模型在 JDK 1.2 期间被引入并被广泛应用于之后几乎所有的 Java 程序中，但它并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种类加载器实现方式。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它不会首先加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到对应的类），子加载器才会尝试自己去加载。 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如 java.lang.Object 类，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果读者有兴趣的话，可以尝试去编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但永远无法被加载运行。 破坏双亲委派模型上文提到过双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过 3 较大规模的『被破坏』情况。 第一次被破坏双亲委派模型的第一次被破坏其实发生在双亲委派模型出现之前——即 JDK 1.2 发布之前。由于双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。 为了向前兼容，JDK 1.2 之后的 java.lang.ClassLoader 添加了一个新的 findClass() 方法，在此之前，用户去继承 java.lang.ClassLoader 的唯一目的就是重写 loadClass() 方法。因为双亲委派的具体逻辑就实现在 loadClass() 方法中，JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到新增的 findClass() 方法。在 loadClass() 方法的逻辑里，如果父类加载失败，则会调用 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。 java.lang.ClassLoader 中的 loadClass() 方法 第二次被破坏双亲委派模型的第二次被破坏是由这个模型自身的缺陷所导致的。双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的类加载器进行加载），基础类之所以称为『基础』，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？ 这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进了 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI,Service Provider Interface）的代码，但启动类加载器不可能认识这些代码啊！那该怎么办？ 为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 有了线程上下文类加载器，就可以做一些『舞弊』的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。 第三次被破坏双亲委派模型的第三次被破坏是由于用户对程序动态性的追求而导致的。这里所说的『动态性』指的是当前一些非常热门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。 Sun 公司所提出的 JSR-294、JSR-277 规范在与 JCP 组织的模块化规范之争中落败给 JSR-291（即 OSGi R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGi 已经成为了业界『事实上』的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。 虽然使用了『被破坏』这个词来形容上述不符合双亲委派模型原则的行为，但这里『被破坏』并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可认为是一种创新。 正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，就可以算是掌握了类加载器的精髓。 创建对象创建对象可分为 3 个步骤： 在堆区分配对象需要的内存 分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量。 对所有实例变量赋零值 将方法区内对实例变量的定义拷贝一份到堆区，然后赋零值。 执行实例初始化代码 初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法。 如果有类似于 Child c = new Child() 形式的 c 引用的话，在栈区定义 Child 类型引用变量 c，然后将堆区对象的地址赋值给它。 需要注意的是，每个子类对象持有父类对象的引用，可在内部通过 super 关键字来调用父类对象，但在外部不可访问。 通过实例引用调用实例方法时，先从方法区中对象的类型信息中找，找不到的话再去父类的类型信息中找。如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为 虚方法表 的方式来优化调用的效率。 引用 《深入理解 Java 虚拟机》 PDD面试题：new一个对象的过程中发生了什么？ 深入理解Java Class文件格式（一） 这个世界根本没有什么面向对象！","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"new","slug":"new","permalink":"//huminxi.netlify.com/tags/new/"},{"name":"创建对象","slug":"创建对象","permalink":"//huminxi.netlify.com/tags/创建对象/"}]},{"title":"Java 垃圾收集续","slug":"Java 垃圾收集续","date":"2019-10-31T05:44:10.000Z","updated":"2019-11-12T08:48:30.354Z","comments":true,"path":"2019/10/31/Java 垃圾收集续/","link":"","permalink":"//huminxi.netlify.com/2019/10/31/Java 垃圾收集续/","excerpt":"前一篇 主要介绍了垃圾收集的算法思路，今天来看看垃圾收集器的具体实现。HotSpot 实现了 JVM 规范。最初由 Sun 开发，现在由 Oracle 拥有。JVM 规范还有其他的实现，例如 JRockit 和 IBM J9 等等。","text":"前一篇 主要介绍了垃圾收集的算法思路，今天来看看垃圾收集器的具体实现。HotSpot 实现了 JVM 规范。最初由 Sun 开发，现在由 Oracle 拥有。JVM 规范还有其他的实现，例如 JRockit 和 IBM J9 等等。 算法实现前一篇文章从理论上介绍了对象存活判定算法和垃圾收集算法，HotSpot 虚拟机在实现这些算法时，必须对算法的执行效率有严格的考量，这样才能保证虚拟机的高效运行。 枚举根节点我们知道执行可达性分析的第一步是先确定 GC Roots。可作为 GC Roots 的节点主要在全局性的引用（例如类静态属性或常量）与执行上下文（例如栈帧的本地变量表）中。现在很多应用仅方法区就有数百兆，如果要逐个检查这些引用，必然会消耗很多时间。 GC 停顿另外，可达性分析对执行时间的敏感性还体现在 GC 停顿上，因为这项分析工作必须在一个能确保『一致性』的快照中进行。这个『一致性』的意思是指在可达性分析期间整个执行系统看起来就像被冻结在某个时间点上，不能出现分析过程中对象的引用关系还在不断的变化，该点不满足的话分析结果的准确性就无法得到保证。这也是 GC 时必须停顿所有 Java 执行线程的一个重要原因（Sun 将这件事情称为『Stop The World』），即使是在几乎不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。 准确式 GC准确式 GC 就是让虚拟机可以准确的知道内存中某个位置的数据类型是什么。比如某个内存位置到底是一个整型的变量，还是对某个对象的 reference；这样在进行 GC Roots 枚举时，只需要枚举 reference 即可。在能够准确地确定 reference 位置之后，虚拟机就能极大地缩短 GC Roots 枚举时间。 HotSpot 是使用一组称为 OopMap 的数据结构来达到这个目的的。在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来；在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。 示例代码123456789101112package jvm.gc;/** * jvm 参数: -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly * jre 建议使用 1.8 及以上版本。 * */public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World\"); &#125;&#125; idea 配置 String.hashCode() 方法编译后的本地代码 安全点在 OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：有可能导致引用关系变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。 实际上，HotSpot 也的确没有为每条指令都生成 OopMap，只会在『特定的位置』记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。这些『特定的位置』包括： 循环的末尾 调用方法的 call 指令后 可能抛异常的位置 对于 Sefepoint，另一个需要考虑的问题是如何在 GC 发生时让所有线程（除了调用 JNI 的线程）都跑到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。而主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为 true 时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 下面的 test 指令是 HotSpot 生成的轮询指令，当需要暂停线程时，虚拟机把 0x6991750 的内存页设置为不可读，线程执行到 test 指令时就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。 test 指令 安全区 使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题，但实际情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序不执行的时候呢？所谓的程序不执行就是没有分配 CPU 时间，典型的例子就是线程处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，跑到安全的地方去中断挂起，JVM 也显然不太可能等待线程重新被分配 CPU 时间。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region。那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。当线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 Serial 收集器Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的『单线程』的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 『Stop The World』这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。 Serial 收集器运行示意图 写到这里，笔者似乎已经把 Serial 收集器描述成一个『食之无味弃之可惜』的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。 Parallel 收集器Parallel 收集器其实就是 Serial 收集器的多线程版本。除了使用多条线程进行垃圾收集之外，其余行为都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 Parallel 收集器运行示意图 Parallel 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。当然，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU 动辄就 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。 CMS 收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 从名字上就可以看出，CMS 收集器是基于『标记—清除』算法实现的，它的运作过程相对来说更复杂一些，整个过程分为 4 个步骤，包括： 初始标记（Initial Mark） 并发标记（Concurrent Mark） 重新标记（Remark） 并发清除（Concurrent Sweep） 其中，初始标记、重新标记这两个步骤仍然需要『Stop The World』。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记阶段就是进行 GC Roots Tracing 的过程；而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 CMS 收集器运行示意图 CMS 收集器无法处理浮动垃圾（Floating Garbage），可能出现『Concurrent ModeFailure』失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为『浮动垃圾』。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。 还有一个缺点，因为 CMS 是一款基于『标记—清除』算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。 G1 收集器G1 是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点： 并行与并发 G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop The World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合 与 CMS 的『标记-清理』算法不同，G1 从整体来看是基于『标记—整理』算法实现的收集器，从局部（两个 Region 之间）上来看是基于『复制』算法实现的。这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 Full GC。 可预测的停顿 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 G1 把内存『化整为零』的思路，理解起来似乎很容易，但其中的实现细节却远远没有想象中那样简单，否则也不会从 2004 年 Sun 实验室发表第一篇 G1 的论文开始直到 2014 年才开发出 G1 的商用版。笔者以一个细节为例：把 Java 堆分为多个 Region 后，垃圾收集是否就真的能以 Region 为单位进行了？听起来顺理成章，再仔细想想就很容易发现问题所在：Region 不可能是孤立的。一个对象分配在某个 Region 中，它并非只能被本 Region 中的其他对象引用，而是可以与整个 Java 堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个 Java 堆才能保证准确性？这个问题其实并非在 G1 中才有，只是在 G1 中更加突出而已。在以前的分代收集中，新生代的规模一般都比老年代要小许多，新生代的收集也比老年代要频繁许多，那回收新生代中的对象时也面临相同的问题，如果回收新生代时也不得不同时扫描老年代的话，那么 Minor GC 的效率可能下降不少。 在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking） 并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面。 最终标记（Final Marking） 最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation） 筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，从 Sun 公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 G1 收集器运行示意图 小结没有任何场景都适用的 GC 收集器，所以我们需要了解各个 GC 收集器的特性，这样才能根据具体的应用场景选出合适的 GC 收集器。 引用 《深入理解 Java 虚拟机》 HotSpot 虚拟机的算法实现 找出栈上的指针/引用","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/tags/JVM/"},{"name":"垃圾收集","slug":"垃圾收集","permalink":"//huminxi.netlify.com/tags/垃圾收集/"}]},{"title":"Java 垃圾收集","slug":"Java 垃圾收集","date":"2019-10-28T05:35:52.000Z","updated":"2019-11-12T08:47:22.603Z","comments":true,"path":"2019/10/28/Java 垃圾收集/","link":"","permalink":"//huminxi.netlify.com/2019/10/28/Java 垃圾收集/","excerpt":"Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的『高墙』，墙外面的人想进去，墙里面的人想出来。","text":"Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的『高墙』，墙外面的人想进去，墙里面的人想出来。 概述 说起垃圾收集(Garbage Collection,GC)，大部分人都把这项技术当做 Java 语言的伴生产物。事实上，GC 的历史比 Java 久远，1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言。当 Lisp 还在胚胎时期时，人们就在思考 GC 需要完成的 3 件事情： 哪些内存需要回收 什么时候回收 如何回收 经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了『自动化』时代，那为什么我们还要去了解 GC 和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时；当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些『自动化』的技术实施必要的监控和调节。 把时间从半个多世纪前回拨到现在，回到我们熟悉的 Java 语言。《Java 运行时数据区域》 介绍了 Java 运行时的各个内存区域。其中程序计数器、Java 虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，这几个区域的内存分配和回收都具有确定性。而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，JVM 只有在程序运行期间才能知道要创建哪些对象。因此这部分内存分配和回收都是动态的，同时也是垃圾收集器关注的部分。 对象已经死了吗在堆里面存放着 Java 世界中几乎所有的对象实例，垃圾收集器在对它们进行回收前，第一件事情就是要确认哪些对象还『存活』着，哪些已经『死去』(即不可能再被任何途径使用的对象)。 引用计数算法一个简单的实现就是给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的就是不可能再被使用的对象。 引用计数算法(Reference Counting)的实现简单，判定效率也很高。但是主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，因为它很难解决对象之间循环引用的问题。 来看个例子：对象 objA 和 objB 都有字段 instance。赋值 objA.instance = objB 及 objB.instance = objA，除此之外，这两个对象无任何引用。实际上这两个对象不可能再被访问，但因为他们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通过 GC 收集器回收它们。 代码 1 12345678910111213141516171819202122232425262728/** * jvm 运行参数: -verbose:gc -XX:+PrintGCDetails */public class ReferenceCountingGC &#123; public static void main(String[] args) &#123; GCObject objA = new GCObject(); // Step1 GCObject objB = new GCObject(); // Step2 objA.instance = objB; // Step3 objB.instance = objA; // Step4 objA = null; // Step5 objB = null; // Step6 //假设在这行发生 GC，objA 和 objB 能否被回收？ System.gc(); &#125; public static class GCObject &#123; public GCObject instance = null; private static final int _1MB = 1024 * 1024; /** * 这个属性的唯一意义就是占点内存，以便能在 GC 日志中看清楚是否回收过。 */ private byte[] bigSize = new byte[2 * _1MB]; &#125;&#125; 如果采用的是引用计数算法，会产生什么结果呢？我们一起来分析一下。 来看 main 方法的前 6 个步骤： Step1：GCObject 实例 1 的引用计数加 1，实例 1 的引用计数=1； Step2：GCObject 实例 2 的引用计数加 1，实例 2 的引用计数=1； Step3：GCObject 实例 2 的引用计数再加 1，实例 2 的引用计数=2； Step4：GCObject 实例 1 的引用计数再加 1，实例 1 的引用计数=2； 执行到 Step4 时，GCObject 实例 1 和 实例 2 的引用计数都等于 2。 继续执行 Step5 和 Step6 之后结果图 Step5：栈帧中 objA 不再指向堆，GCObject 实例 1 的引用计数减 1，实例 1 引用计数=1； Step6：栈帧中 objB 不再指向堆，GCObject 实例 2 的引用计数减 1，实例 2 引用计数=1。 至此，发现 GCObject 实例 1 和实例 2 的引用计数都不为 0。如果采用引用计数算法的话，这两个实例所占的内存将得不到释放，这便发生了内存泄露。 代码 1 的执行结果 从日志中可以看到 6717K-&gt;560K，这意味着 Java 虚拟机并没有因为这两个对象互相引用就不回收它们，侧面说明了 Java 虚拟机并不是通过引用计数算法来判断对象是否存活的。 可达性分析算法在一些语言(Java、C#，Lisp)的主流实现中，都号称是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列称为『GC Roots』的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)。当一个对象到 『GC Roots』没有任何引用链相连时(用图论的话来说，就是从『GC Roots』到这个对象不可达)，则证明此对象是不可用的。 在 Java 语言中，可作为『GC Roots』的包括以下几种： 方法区中类静态属性或常量 虚拟机栈中栈帧的局部变量 本地方法栈中的 JNI 由上图可知，reference 1、reference 2、reference 3 都是 GC Roots，可以看出： reference 1 -&gt; 对象 1； reference 2 -&gt; 对象 2； reference 3 -&gt; 对象 4； reference 3 -&gt; 对象 4 -&gt; 对象 6； 因此可得对象 1、2、4、6 都具有 GC Roots 可达性，也就是存活对象。而对象 3、5 之间虽然有引用，但它们与 GC Roots 之间没有引用链，这便是 GC Roots 不可达的对象，也是需要进行 GC 的对象。 垃圾收集算法标记-清除算法最基础的收集算法是『标记-清除』(Mark-Sweep)算法，如同它的名字，算法分为『标记』和『清除』两个阶段：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。 之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足之处进行改进而得到的。它的主要不足之处有两个： 一个是效率问题，标记和清除这两个过程的效率都不高； 一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 标记—清除算法的执行过程 复制算法为了解决效率问题，一种称为『复制』(Copying)的收集算法出现了，它将内存按容量划分为大小相等的两块，每次只使用其中的一块。当某一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。这样一来，每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法将可用内存缩小为了原来的一半，代价未免太高了一点。 复制算法的执行过程 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是『朝生夕死』的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1。也就是说，每次新生代中可用内存空间为整个新生代容量的 90%(80%+10%)，只有 10%的内存会被『浪费』。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。 标记-整理算法复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都存活(即 100% 存活)的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种『标记-整理』(Mark-Compact)算法，标记过程仍然与『标记-清除』算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 标记-整理算法的执行过程 分代收集算法当前商业虚拟机的垃圾收集都采用『分代收集』(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用『标记—清理』或者『标记—整理』算法来进行回收。 垃圾收集器今天主要介绍了垃圾收集的算法思路，下一篇 我们将介绍垃圾收集器的具体实现。 引用 《深入理解 Java 虚拟机》 垃圾回收机制中，引用计数法是如何维护所有对象引用的？ Garbage Collection in Java","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/tags/JVM/"},{"name":"垃圾收集","slug":"垃圾收集","permalink":"//huminxi.netlify.com/tags/垃圾收集/"}]},{"title":"Java 运行时数据区域","slug":"Java 运行时数据区域","date":"2019-10-25T07:25:07.000Z","updated":"2019-10-30T08:10:45.260Z","comments":true,"path":"2019/10/25/Java 运行时数据区域/","link":"","permalink":"//huminxi.netlify.com/2019/10/25/Java 运行时数据区域/","excerpt":"Java 虚拟机规范定义了在程序运行期间使用的各种数据区域。其中一些数据区域是在 Java 虚拟机启动时创建的，仅在 Java 虚拟机退出时才被销毁。其它的数据区域是属于线程私有的，在线程创建时创建，线程退出时销毁。","text":"Java 虚拟机规范定义了在程序运行期间使用的各种数据区域。其中一些数据区域是在 Java 虚拟机启动时创建的，仅在 Java 虚拟机退出时才被销毁。其它的数据区域是属于线程私有的，在线程创建时创建，线程退出时销毁。 概览 线程共享区域方法区域方法区域(Method Area)，又称方法区。Java 虚拟机维护一个在所有线程间共享的方法区域。方法区域类似于 C 语言的已编译代码的存储区域，或类似于操作系统进程中的 text segment。 方法区域存储每个类的结构，例如运行时常量池、字段、方法数据、方法代码、构造函数代码。方法区域是在 Java 虚拟机启动时创建的。 如果方法区域中的内存不满足分配请求，则 Java 虚拟机将抛出 OutOfMemoryError。 12-XX:PermSize=20M //方法区初始为 20MB。 -XX:MaxPermSize=64M //方法区最大为 64MB。 堆堆(Heap)，又称 Java 堆。Java 虚拟机维护一个在所有线程间共享的堆。堆是运行时数据区域，从中分配所有类实例和数组的内存。 堆是在虚拟机启动时创建的。自动存储管理系统(俗称 垃圾收集器)可以回收对象的堆存储。堆的大小可以是固定的，也可以根据需要进行扩展。堆的内存可以不连续。 如果计算需要的堆多于自动存储管理系统可以提供的堆，则 Java 虚拟机将抛出一个 OutOfMemoryError。 12-Xms20M //JVM 启动时申请的初始 Heap 为 20MB。-Xmx40M //JVM 可申请的最大 Heap 为 40MB。 线程私有区域PC 寄存器PC 寄存器(Program Counter Register)，又称程序计数器。Java 虚拟机可以同时运行多个线程，每个线程都有自己的 PC 寄存器。如果线程执行的不是 native 方法，则该 PC 寄存器保存着当前正在执行的 Java 虚拟机指令的地址。如果线程执行的是 native 方法，则 PC 寄存器的值未知。 Java 虚拟机栈Java 虚拟机栈(JVM Stack)。每个线程都有一个 Java 虚拟机栈，它与该线程同时创建。Java 虚拟机栈用来保存局部变量和部分结果，并参与方法调用和返回。每个方法执行时会在虚拟机栈中创建栈帧。Java 虚拟机栈的内存可以不连续。 Java 虚拟机规范允许 Java 虚拟机栈具有固定大小或能根据要求进行动态扩展。如果 Java 虚拟机栈的大小固定，则在创建每个 Java 虚拟机栈时可以指定其大小。 如果计算时所需的 Java 虚拟机栈超出允许的范围，则 Java 虚拟机将抛出 StackOverflowError。 如果可以动态扩展 Java 虚拟机栈，并且尝试进行扩展，但是此时没有足够的内存来实现扩展，或者是没有足够的内存来为新线程创建初始的 Java 虚拟机栈，则 Java 虚拟机机器抛出一个 OutOfMemoryError。 Java HotSpot VM 没有实现动态扩展，但可以用下面的参数来指定线程栈大小。 1-XX:ThreadStackSize=512 //虚拟机栈大小。以 KB 为单位，0 表示使用默认的堆栈大小。 本地方法栈本地方法栈(Native Method Stack)。Java 虚拟机可以使用传统栈(俗称 C 栈)来支持 native 方法。如果 Java 虚拟机无法加载 native 方法而且自身不依赖传统栈，那么该 Java 虚拟机无需提供本地方法栈。如果提供，通常在创建线程时为它们分配本地方法栈。 引用 《深入理解 Java 虚拟机》 The Structure of the Java Virtual Machine Java HotSpot VM 选项","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/tags/JVM/"},{"name":"Java 虚拟机","slug":"Java-虚拟机","permalink":"//huminxi.netlify.com/tags/Java-虚拟机/"}]},{"title":"RSA 加密算法的实现原理","slug":"RSA 加密算法的实现原理","date":"2019-09-20T10:51:51.000Z","updated":"2019-09-24T02:53:03.392Z","comments":true,"path":"2019/09/20/RSA 加密算法的实现原理/","link":"","permalink":"//huminxi.netlify.com/2019/09/20/RSA 加密算法的实现原理/","excerpt":"\n\n\nRSA 加密算法 是一种非对称加密算法，在公开密钥加密中被广泛使用。RSA 是 1977 年由 Ron Rivest、Adi Shamir、Leonard Adleman 一起提出的，RSA 就是他们三人姓氏的开头字母。","text":"RSA 加密算法 是一种非对称加密算法，在公开密钥加密中被广泛使用。RSA 是 1977 年由 Ron Rivest、Adi Shamir、Leonard Adleman 一起提出的，RSA 就是他们三人姓氏的开头字母。 杨辉三角形和二项式系数杨辉三角形，又称帕斯卡三角形，是 二项式系数 的一种几何排列。出现在南宋数学家杨辉所著的《详解九章算法》一书中。 二项式 \\((x+1)^n \\) 的各项展开式系数就是第 n 行杨辉三角形上的数字。$$(x+1)^0=1 \\\\(x+1)^1=x+1 \\\\(x+1)^2=x^2+2x+1 \\\\(x+1)^3=x^3+3x^2+3x+1 \\\\(x+1)^4=x^4+4x^3+6x^2+4x+1 \\\\… \\\\(x+1)^n=x^n+nx^{n-1}+\\frac{n(n-1)}{2}x^{n-2}+\\frac{n(n-1)(n-2)}{2\\times3}x^{n-3}+…+1$$ 其中每一项的系数都是一个组合数 \\( C_n^p \\)，可以表示成如下形式 $$ C_n^p={\\tbinom {n}{p}}={\\tfrac {n!}{p!(n-p)!}} $$ 特性 当 n 为质数时，除了第一项和最后一项，中间所有项的系数均为 n 的倍数。 证明 p 不为 n 或 0 时，由于分子有质数 n，但分母不含 n，故分子的 n 能保留，不会因约分而除去。即 \\( {\\tbinom {n}{p}} \\) 恒为 n 的倍数。 (这里隐含了一个前提条件，即 \\({\\tbinom {n}{p}}\\) 是一个整数。) 费马小定理假如 a 是一个整数，p 是一个质数，那么 \\( a^p-a\\) 是 p 的倍数，可以表示为 $$ a^p \\equiv a \\pmod p $$ 例如，$$ 7^3-7=343-7=336=7\\times48 \\\\ 6^5-6=7776-6=7770=6\\times1296$$ 皮埃尔·德·费马于 1636 年发现了这个定理。在一封 1640 年 10 月 18 日的信中他第一次使用了上面的书写方式。 证明 可以利用杨辉三角形来证明。 如果 a 不是 p 的倍数，这个定理也可以写成 $$ a^{p-1} \\equiv 1 \\pmod p \\,\\,\\,\\,\\,\\,\\,\\,\\,(费马小定理) $$ 欧拉 \\( \\varphi \\) 函数在数论中，对于正整数 n，欧拉函数 \\( \\varphi (n) \\) 是小于或等于 n 的正整数中与 n 互质的数的数量。 例如，\\( \\varphi (8) =4 \\)，因为 1，3，5，7 均与 8 互质。由此可以推出，当 n 为素数时， \\( \\varphi (n) = (n-1) \\)。 性质 欧拉 \\(\\varphi\\) 函数是积性函数。即是说若 m,n 互质，则 \\( \\varphi(mn)=\\varphi(m) \\varphi(n) \\)。 费马-欧拉定理1736 年，欧拉证明了费马小定理。同时还对其进行了拓展，拓展之后的定理被称为 『费马-欧拉定理』)。 若 n，a 为正整数，且 n，a 互素，则 $$ a^{\\varphi(n)}\\equiv 1\\pmod n \\,\\,\\,\\,\\,\\,\\,\\,\\,(费马-欧拉定理)$$ 当 n 为素数，\\(\\varphi(n)=n-1\\)，这时就变成了费马小定理 $$ a^{p-1} \\equiv 1 \\pmod p $$ RSA 算法公钥与私钥的产生假设 Alice 想要通过一个不可靠的媒体接收 Bob 的一条私人消息。她可以用下面的方法来产生一对公私钥: 选择任意两个大素数 p 和 q，p 不等于 q，计算 \\( N=pq \\)。 求出 \\(\\varphi(N)\\)，令 \\(r = \\varphi(N)=\\varphi(m) \\varphi(n)=(p-1)(q-1)\\)。 选择一个小于 r 且与 r 互质的整数 e。 选择一个数 d，使得 \\(ed-1=r\\,的倍数\\)。即 d 是 e 关于 r 的模逆元。 销毁 p 和 q。 \\((N,e)\\) 是公钥， \\((N,d)\\) 是私钥。Alice 将公钥传给 Bob，而将私钥藏起来。 加密消息假设 Bob 想给 Alice 发送一个消息 m (m&lt;N)，需要先找到一个正整数 c，使得 \\(m^e-c=N\\,的倍数 \\) ①。这个 c 就是加密后的密文。 解密消息Alice 拿到密文 c 后，需要找到一个数 x。使得 \\(c^d-x=N\\,的倍数 \\) ②。然后你会发现，在小于 N 的正整数中，只有 m 这一个解。 怎么样，加解密过程是不是特别简单？ 证明其实只需要证明从式子 ① 可以变换到式子 ② 即可。 拓展提问 1如果消息 m 过长，即 m &gt; N 时怎么办？ 提问 2有没有可能在已知公钥 \\((N,e)\\) 的情况下，推导出私钥 \\((N,d)\\)？ 回答 1可以先将消息 m 分段，然后再传输。 回答 21) \\(ed\\equiv 1 \\pmod {\\varphi(N)} \\)。只有知道 e 和 \\(\\varphi(N)\\)，才能算出 d。2) \\(\\varphi(N)=(p-1)(q-1)\\)。只有知道 p 和 q，才能算出 \\(\\varphi(N)\\)。3) \\(N=pq\\)。只有将 N 因数分解，才能算出 p 和 q。 结论：如果 N 可以被因数分解，d 就可以算出，也就意味着私钥被破解。 大整数的因数分解，是一件非常困难的事情(属于 NPC 问题)。除了暴力破解，目前还没有发现别的有效方法。人类已经分解的最大整数是（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。 证明过程的 Latex 语句1234567891011121314\\begin&#123;align*&#125; &amp; m^e-c=N的倍数 \\qquad\\qquad\\qquad\\qquad\\qquad\\quad (1)将\\,c\\,提至一边 \\\\&amp; c=m^e-N的倍数 \\qquad\\qquad\\qquad\\qquad\\qquad\\quad (2)两边同时进行\\,d\\,次方 \\\\&amp; c^d=(m^e-N的倍数)^d \\qquad\\qquad\\qquad\\qquad\\quad\\,\\,\\, (3)将\\,(m^e-N的倍数)^d\\,展开，并且将包含\\,N的倍数\\,项合并\\\\&amp; c^d=m^&#123;ed&#125;-N的倍数 \\qquad\\qquad\\qquad\\qquad\\qquad\\, (4)将\\,ed=1+r的倍数\\,带入式中 \\\\&amp; c^d=m^&#123;1+r的倍数&#125;\\,\\,\\,-N的倍数 \\qquad\\qquad\\qquad\\qquad\\, (5)将指数\\,1\\,提出来 \\\\&amp; c^d=m \\cdot m^&#123;r的倍数&#125;\\,\\,\\,-N的倍数 \\qquad\\qquad\\qquad\\quad\\,\\,\\, (6)将\\,r=\\varphi(N)\\,带入式中 \\\\&amp; c^d=m \\cdot m^&#123;\\varphi(N)的倍数&#125;\\,\\,\\,-N的倍数 \\qquad\\qquad\\qquad\\,\\, (7)根据\\,费马-欧拉定理，将\\,m^&#123;\\varphi(N)&#125;=1+N的倍数\\,带入式子 \\\\&amp; c^d=m \\cdot (1+N的倍数)^&#123;\\varphi(N)的倍数-1&#125;\\,\\,\\,-N的倍数 \\quad (8) 重复第\\,(7)\\,步 \\\\&amp; c^d=m \\cdot (1+N的倍数)-N的倍数 \\qquad\\qquad\\,\\,\\,\\, (9)将\\,(1+N的倍数)^&#123;\\varphi(N)的倍数-1&#125;\\quad展开，并且合并\\,N的倍数 \\\\&amp; c^d=m+N的倍数 \\qquad\\qquad\\qquad\\qquad\\qquad\\,\\,\\, (10) 证毕。\\end&#123;align*&#125; 引用 素数（五）费马是如何检验素数的？杨辉三角形和素数有什么关系？ 素数（六）基于欧拉函数的RSA算法加密原理是什么？RSA算法详解 RSA算法原理（二） RSA加密算法 二项式定理","raw":null,"content":null,"categories":[{"name":"数学","slug":"数学","permalink":"//huminxi.netlify.com/categories/数学/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"//huminxi.netlify.com/tags/RSA/"},{"name":"加密算法","slug":"加密算法","permalink":"//huminxi.netlify.com/tags/加密算法/"}]},{"title":"虚拟内存","slug":"虚拟内存","date":"2019-06-05T03:28:29.000Z","updated":"2019-06-24T08:44:25.954Z","comments":true,"path":"2019/06/05/虚拟内存/","link":"","permalink":"//huminxi.netlify.com/2019/06/05/虚拟内存/","excerpt":"一个系统中的进程是与其它进程共享 CPU 和内存资源的。然而，共享内存会形成一些特殊的挑战。如果有太多的进程占用内存，内存很快就会被占满，当一个新来的进程没有内存空间可用时，那它就无法运行。内存中的数据还很容易被破坏，例如，当某个进程不小心写了另一个进程使用的内存，原来的数据就被覆盖，这可能会导致非业务逻辑上的程序错误，这些错误往往都难以定位原因。为了更加有效地管理内存并且减少出错，现代操作系统提出了一个抽象的概念，叫做虚拟内存(Virtual Memory)。","text":"一个系统中的进程是与其它进程共享 CPU 和内存资源的。然而，共享内存会形成一些特殊的挑战。如果有太多的进程占用内存，内存很快就会被占满，当一个新来的进程没有内存空间可用时，那它就无法运行。内存中的数据还很容易被破坏，例如，当某个进程不小心写了另一个进程使用的内存，原来的数据就被覆盖，这可能会导致非业务逻辑上的程序错误，这些错误往往都难以定位原因。为了更加有效地管理内存并且减少出错，现代操作系统提出了一个抽象的概念，叫做虚拟内存(Virtual Memory)。 什么是虚拟内存虚拟内存是硬件异常、地址翻译硬件、内存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的、私有的地址空间。虚拟内存机制提供了三个重要的能力： 它将内存看成是磁盘的高速缓存，在内存中只保留磁盘的活动区域，并根据需要在磁盘和内存之间来回传送数据，通过这种方式，它高效地使用了内存。 它为每个进程提供了一致的虚拟地址空间，从而简化了内存管理。 它保护了每个进程的内存不被其他进程破坏。 虚拟内存的原理物理寻址和虚拟寻址计算机系统的内存可以视为一个 M 字节大小的数组。每字节都有一个唯一的物理地址(Physical Address, PA)。第一个字节的地址为 0，接下来为 1，再下一个为 2，以此类推。 图 1-1 物理寻址 图 1-1 展示了一个物理寻址的示例，假设 CPU 正在执行的是一条加载指令，它将读取从物理地址 4 开始的 4 字节数据。当 CPU 执行这条加载指令时，会生成一个有效物理地址 4，4 通过内存总线传递到内存。然后内存取出从物理地址 4 开始的 4 字节数据，并将数据返回给 CPU，CPU 会将数据存放在一个寄存器里。像这样 CPU 直接访问物理地址的形式就被称为物理寻址(physical addressing)。 早期的 PC 都使用物理寻址。而且，诸如数字信号处理器、嵌入式微控制器以及 Cray 超级计算机这样的系统仍然继续在这种寻址方式。 然而，现代处理器使用的是一种称为虚拟寻址(virtual addressing)的寻址形式。 如图 1-2 所示 图 1-2 虚拟寻址 使用虚拟寻址，CPU 生成一个虚拟地址(Virtual Address, VA)来访问内存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的过程叫做地址翻译(address translation)。地址翻译需要硬件和操作系统之间的紧密合作。CPU 芯片上的硬件叫做内存管理单元(Memory Management Unit, MMU)，它利用存放在内存中的页表来动态翻译虚拟地址，该表的内容由操作系统来管理。 地址空间地址空间(address space)是一个非负整数地址的有序集合： $$ \\{0,\\;1,\\;2,\\; …\\} $$ 在一个带虚拟内存的系统中，CPU 从一个有 N=2ⁿ 个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间(virtual address space)。 $$ \\{0,\\;1,\\;2,\\; …,\\;N-1\\} $$ 一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含 N=2ⁿ 个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统通常支持 32 位或者 64 位虚拟地址空间。一个系统还有一个物理地址空间(physical address space)，对应于系统中物理内存的 M 个字节： $$ \\{0,\\;1,\\;2,\\; …,\\;M-1\\} $$ 地址空间的概念是重要的，因为它解除了数据和物理地址的绑定。一旦认识到这一点，我们就可以允许每个数据有多个地址，其中每个地址都选自一个不同的地址空间。 内存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。 虚拟内存作为缓存的工具从概念上来说，虚拟内存同样可以视为一个存放在磁盘上的 N 字节大小的数组，每字节都有一个唯一的虚拟地址。磁盘上数组的内容被缓存在内存中。和 存储器层次结构 中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和内存（较高层）之间的传输单元。VM 系统通过将虚拟内存分割为虚拟页(Virtual Page, VP)来处理这个问题，每个虚拟页的大小为 P=2ᴾ 字节。类似地，物理内存被分割为物理页(Physical Page, PP)，大小也为 P 字节。 在任意时刻，虚拟页面的集合都分为三个不相交的子集： 未分配的：VM 系统还未分配或者创建页。未分配的页没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 已缓存的：当前已缓存在物理内存中的已分配页。 未缓存的：当前未缓存在物理内存中的已分配页。 图 1-3 内存作为缓存 图 1-3 展示了一个有 8 个虚拟页的虚拟内存。虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。虚拟页 2、5 和 7 虽然已经被分配了，但是当前并未缓存在内存中。 DRAM 缓存的组织结构为了清晰理解存储层次结构中不同的缓存概念，我们将使用术语 SRAM 缓存来表示位于 CPU 和内存之间的 L1、L2 和 L3 高速缓存，用术语 DRAM 缓存来表示虚拟内存系统的缓存，它在内存中缓存虚拟页。 在存储器层次结构中，DRAM 缓存所处的层次对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要慢大约 10 倍，而磁盘要比 DRAM 慢大约 100 000 倍。因此，DRAM 缓存不命中比起 SRAM 缓存不命中所花费的代价要昂贵得多，这是因为 DRAM 缓存不命中要由磁盘来服务，而 SRAM 缓存不命中通常是由内存来服务的。 而且，从磁盘的一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节要慢大约 100 000 倍。归根到底，DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。 由于极高的不命中代价和访问第一个字节的开销，虚拟页往往很大，通常是 4KB-2MB。 DRAM 缓存是全相联的，即任何虚拟页都可以放置在任何物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的代价也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂更精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回，而不是直写。 12# Linux、Mac 系统可以通过以下命令来查看虚拟页大小getconf PAGE_SIZE 页表同任何缓存一样，虚拟内存系统需要判断一个虚拟页是否缓存在 DRAM 中。如果命中，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统需要知道这个虚拟页存放在磁盘的哪个位置，然后在 DRAM 中选择一个牺牲页，再将虚拟页从磁盘复制到 DRAM，替换掉这个牺牲页。 这些功能是由软硬件联合提供的，包括操作系统、地址翻译硬件和一个存放在物理内存中叫做页表(page table)的数据结构，页表将虚拟页映射到物理页。 每当地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。 图 1-4 页表的基本组织结构 图 1-4 展示了一个页表的基本组织结构。页表就是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。 为了方便描述，我们将假设每个 PTE 是由一个有效位(valid bit)和一个 n 位地址字段组成的。有效位表明了该虚拟页是否被缓存在 DRAM 中。如果设置了有效位，那么地址字段就表示 DRAM 中物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，如果是一个空地址，则表示这个虚拟页还未被分配；否则，这个地址就指向该虚拟页在磁盘上的起始位置。 示例中展示了一个有 8 个虚拟页和 4 个物理页的系统的页表。四个虚拟页(VP 1、VP 2、VP 4、VP 7)被缓存在 DRAM 中。两个虚拟页(VP 0、VP 5)还未被分配，而剩下的虚拟页(VP 3、VP 6)已经被分配了，但是还未被缓存。 页命中考虑一下当 CPU 想要读包含在 VP 2 中的一个字时会发生什么，VP 2 被缓存在 DRAM 中。地址翻译硬件根据虚拟地址定位到 PTE 2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件知道 VP 2 已经缓存在内存中了。所以它使用 PTE 2 中的地址字段(该地址字段指向 PP 1 的起始位置)构造出这个字的物理地址。 图 1-5 页命中 缺页在虚拟内存的习惯说法中，DRAM 缓存不命中称为缺页(page fault)。图 1-6 展示了缺页之前页表的状态。CPU 引用了 VP 3 中的一个字，VP 3 未缓存在 DRAM 中。地址翻译硬件从内存中读取 PTE 3，从有效位推断出 VP 3 未缓存，这时触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(假定是存放在 PP 3 中的 VP 4)，如果 VP 4 已经被修改了，那么内核就会将它复制回磁盘。同时，内核也会修改 PTE 4 的信息，用来反映 VP 4 不再缓存在内存中这一事实。 图 1-6 VM 缺页之前页表的状态 接下来，内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE 3，随后返回。最后，当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发到地址翻译硬件。现在 VP 3 已经缓存在内存中，那么地址翻译硬件也能正常处理了。图 1-7 展示了在缺页之后页表的状态。 图 1-7 VM 缺页之后页表的状态 虚拟内存是在 20 世纪 60 年代早期发明的，远在 CPU-内存之间差距的加大而产生 SRAM 缓存之前。因此，虚拟内存系统使用了和 SRAM 缓存不同的术语，即使它们的许多概念是相似的。在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping)或者页面调度(paging)。页从磁盘换入 DRAM 或从 DRAM 换出磁盘时会一直等待到最后时刻(也就是当有不命中发生时)才换入页面的这种策略称为按需页面调度(demand paging)。也可以采用其他的方法，例如，尝试着预测不命中，在页面实际被引用之前就换入页面。然而，所有现代系统使用的都是按需页面调度的方式。 分配虚拟页面图 1-8 展示了当操作系统分配一个新的虚拟内存页时对页表的影响(例如 C 调用 malloc 函数的结果)。VP 5 的分配过程是在磁盘上创建页面并更新 PTE 5，使它指向磁盘上这个新创建的页面的起始位置。 图 1-8 分配虚拟页面 程序的局部性当我们了解虚拟内存的概念之后，如果和直接使用物理内存相比较，我们会担心它的效率。因为页不命中的处罚很大，我们担心页面调度会破坏程序性能。实际上，虚拟内存工作得相当好，这主要归功于我们的老朋友——局部性(locality)。 尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存的总数，但是局部性保证了在任意时刻，程序将趋向于在一个较小的活动页面(active page)集合上工作，这个集合叫做工作集(working set)或者常驻集合(resident set)。 在初始开销之后(也就是将工作集页面调度到内存中)，接下来对这个工作集的引用将导致命中，不会产生额外的磁盘流量。 只要我们的程序有好的局部性，虚拟内存系统就能工作得相当好。但是，不是所有的程序都能展现良好的局部性。如果工作集的大小超出了物理内存的大小，那么程序将处于一种不幸的状态，叫做抖动(thrashing)，这时页面将不断地换进换出。 虽然虚拟内存通常是高效的，但是如果一个程序跑起来慢的像爬一样，那么聪明的程序猿会考虑是不是发生了抖动。 小结在前文中，我们看到虚拟内存提供了一种机制，用 DRAM 缓存来自(通常更大的)虚拟地址空间的页面。有趣的是，一些早期的系统，比如 DEC PDP-11/70，支持的是一个比物理内存更小的虚拟地址空间。然而，虚拟内存仍然是一个有用的机制，因为它大大地简化了内存管理，并提供了一种自然的保护内存的方法。 12# Linux 系统可以通过以下命令来查看物理地址空间和虚拟地址空间大小cat /proc/cpuinfo | grep address 虚拟内存作为内存管理的工具到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。 图 1-9 展示了基本思想。进程 i 的页表将 VP 1 映射到 PP 2，VP 2 映射到 PP 7。相似地，进程 j 的页表将 VP 1 映射到 PP 7，VP 2 映射到 PP 10。注意，多个虚拟页面可以映射到同一个物理页面上。 图 1-9 进程的独立页表 按需页面调度和独立虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。 特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。 图 1-10 进程地址空间 简化链接。独立的虚拟地址空间允许每个进程的内存映像使用相同的格式，而不管代码和数据实际存放在物理内存的何处。 就像图 1-10 中看到的，一个给定的 Linux 系统上的每个进程都使用类似的内存格式。对于 64 位虚拟地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成链接完全的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。 简化加载。虚拟内存使得向内存中加载可执行文件和共享对象文件更加容易。 要把目标文件中 .text 和 .data 段加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为未被缓存的，将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。每个虚拟页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页，而不需要加载器来操心。 简化共享。独立虚拟地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的机制。 一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。然而，在另一些情况下，还是需要进程来共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个 C 程序都会调用 C 标准库中的函数，比如 printf。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和 C 标准库的副本，如图 1-10 所示。 简化内存分配。虚拟内存向用户进程提供了一个简单的分配额外内存的机制。 当一个运行在用户进程中的程序要求额外的堆空间时(如调用 malloc 函数)，操作系统分配一个适当数字(例如 k)个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个物理页面。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。页面可以随机地分散在物理内存中。 虚拟内存作为内存保护的工具任何现代计算机系统必须为操作系统提供手段来控制对内存的访问 不允许一个用户进程修改它的只读代码段 不允许它读或修改任何内核中的代码和数据结构 不允许它读或者写其他进程的私有内存 不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做(通过进程间通信来实现)。 基于 VM 地址翻译机制，我们能用一种十分简单的方式来提供访问控制。因为 CPU 每次生成一个虚拟地址时，地址翻译硬件都会读一个 PTE，所以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面的访问。图 1-11 展示了大致的思想。 图 1-11 带许可位的页表 示例中，每个 PTE 已经添加了三个许可位。SUP 位表示进程是否必须运行在内核(超级用户)模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VP 0 和读写 VP 1 的权限。然而，不允许它访问 VP 2。 如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给内核中的一个异常处理程序。Linux shell 一般将这种异常报告为段错误(segmentation fault)。 虚拟内存的实现内存映射Linux 通过将一个虚拟内存区域与一个磁盘上的对象(object)关联起来，以此来初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。虚拟内存区域可以映射成两种类型的对象： Linux 文件系统中的普通文件。 一个虚拟内存区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区(section)被分成页大小的片，每一片都包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际进入物理内存，直到 CPU 第一次引用到页面。如果虚拟内存区域比文件区要大，那么就用零来填充这个区域的余下部分。 匿名文件。 一个虚拟内存区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。 无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件(swap file)之间换来换去。交换文件也叫做交换空间(swap space)或者交换区域(swap area)。需要注意的一点是，在任何时刻，交换空间 都限制着当前运行着的进程能够分配的虚拟页面的总数。 动态内存分配虽然可以使用低级的 mmap 和 munmap 函数来创建和删除虚拟内存的区域，但是 C 程序员还是会觉得当运行时需要额外虚拟内存时，用动态内存分配器(dynamic memory allocator)更方便，也有更好的可移植性。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)(见图 1-12)，它紧接在未初始化的数据区域后开始，并向上生长(向更高的地址)。对于每个进程，内核维护着一个变量 brk(读做 break)，它指向堆的顶部。 图 1-12 堆 分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk)，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块可用来分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显示分配器(explicit allocator)，要求应用显式地释放任何已分配的块。 例如，C 标准库提供一种叫做 malloc 程序包的显式分配器。C 程序通过调用 malloc 函数来分配一个块，并通过调用 free 函数来释放一个块。C++ 中的 new 和 delete 操作符与 C 中的 malloc 和 free 相当。 隐式分配器(implicit allocator)，要求分配器检测一个已分配块何时不再被程序所使用并进行释放。 隐式分配器也叫做垃圾收集器(garbage collector)，自动释放未使用的已分配的块的过程叫做垃圾收集(garbage collection)。诸如 Lisp、Java 之类的高级语言就依赖垃圾收集来释放已分配的块。 总结虚拟内存是对内存的一个抽象。支持虚拟内存的 CPU 通过使用一种叫做虚拟寻址的间接形式来引用内存。CPU 产生一个虚拟地址，在被发送到内存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合作。地址翻译硬件通过使用页表来翻译虚拟地址，而页表的内容是由操作系统负责维护的。 引用 《深入理解计算机系统》 Linux 交换空间 Linux 中缺页中断","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"内存","slug":"内存","permalink":"//huminxi.netlify.com/tags/内存/"},{"name":"Virtual Memory","slug":"Virtual-Memory","permalink":"//huminxi.netlify.com/tags/Virtual-Memory/"}]},{"title":"计算机的存储器系统","slug":"计算机的存储器系统","date":"2019-04-19T08:06:41.000Z","updated":"2019-06-10T08:30:39.537Z","comments":true,"path":"2019/04/19/计算机的存储器系统/","link":"","permalink":"//huminxi.netlify.com/2019/04/19/计算机的存储器系统/","excerpt":"按照冯·诺伊曼设计的计算机模型，CPU 执行指令，存储器系统负责存放 CPU 执行的指令和数据。在现代计算机中，存储器系统由不同容量、不同成本、不同访问时间的各级存储器组成。为什么要这样设计呢？","text":"按照冯·诺伊曼设计的计算机模型，CPU 执行指令，存储器系统负责存放 CPU 执行的指令和数据。在现代计算机中，存储器系统由不同容量、不同成本、不同访问时间的各级存储器组成。为什么要这样设计呢？ 存储技术一般来说，访问速度越快的存储器造价也越高。下面我们介绍几种常见的存储器。 寄存器寄存器(Register)是 CPU 的组成部分。寄存器容量非常小，它们可用来暂存指令、数据和地址。 RAM随机访问存储器(Random-Access Memory, RAM)分为两类，静态的和动态的。静态 RAM (SRAM) 比动态 RAM (DRAM) 更快，但也贵的多。SRAM 用来做高速缓存，DRAM 用来做主存以及图形系统的帧缓存区。通常来说，一个计算机系统的 SRAM 不会超过几 MB，但是 DRAM 却可以有几 GB。 Mac-pro 15 RAM 中的信息需要通电才能维持。 机械硬盘机械硬盘是常见的保存大量数据的存储设备，现代机械硬盘一般能存储几百 GB 的数据，远远大于基于 RAM 的存储器所能存储的数据。不过，从机械硬盘上读取信息的时间为毫秒级，比从 DRAM 读慢了 10 万倍，比从 SRAM 读慢了 100 万倍。 机械硬盘内部的碟片在通电后开始高速转动 你的浏览器不支持 video 标签。 机械硬盘中的信息一旦保存后，不通电也能维持。 SSD固态硬盘(Solid-state driver, SSD)是一种主要以 闪存 作为永久性存储器的计算机设备。由于价格及存储空间与机械硬盘有巨大差距，固态硬盘目前还无法完全取代机械硬盘。其读写速度比机械硬盘快 2-3 倍，且无噪音。 Mac-pro 15 局部性一个编写良好的计算机程序常常具有良好的访问局部性(Locality of reference)。访问局部性分为两种，一种是时间局部性，一种是空间局部性。 时间局部性 被引用过一次的内存位置很可能在不远的将来再被多次引用。 空间局部性 如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。 存储器层次结构在 CPU 和一个较大较慢的设备(例如主存)之间插入一个更快更小的存储设备(例如高速缓存)的想法已经成为了一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从上至下，设备的访问速度越来越慢，容量越来越大，并且每个字节的造价也越来越便宜。 存储器层次结构 寄存器在层次结构中的最顶部，也就是第 0 级或记为 L0。这里我们展示的是三层高速缓存 L1 到 L3，占据存储器层次结构的第 1 层到第 3层。主存在第 4 层，以此类推。 高速缓存存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。 因此，寄存器就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存， L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中的数据的高速缓存。 小结存储器系统之所以设计成层次结构，主要是以下两点因素导致的 CPU 的周期时间与各级存储器的访问时间相差过大 节约成本 访问速度越快的存储器造价也就越高，我们无法全部用 SRAM 来做存储器。 根据程序的局部性原理，我们可以利用高一层的存储器作为低一层的存储器的高速缓存，这样总体上也能达到不错的访问速度。 CPU 周期时间与各级存储器的访问时间 引用 《深入理解计算机系统》 寄存器 硬盘内部的碟片在通电后开始高速转动 固态硬盘 memory-access-time","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"存储器系统","slug":"存储器系统","permalink":"//huminxi.netlify.com/tags/存储器系统/"},{"name":"hierarchy","slug":"hierarchy","permalink":"//huminxi.netlify.com/tags/hierarchy/"}]},{"title":"浮点数在计算机中的表示","slug":"浮点数在计算机中的表示","date":"2019-03-29T07:20:22.000Z","updated":"2019-04-22T07:11:40.371Z","comments":true,"path":"2019/03/29/浮点数在计算机中的表示/","link":"","permalink":"//huminxi.netlify.com/2019/03/29/浮点数在计算机中的表示/","excerpt":"\n\n现实世界中不仅有整数，还有小数，有没有一种编码，能同时表示它们呢。IEEE 754 是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，简单来说，它采用了类似科学记数法的形式来表示整数和小数。该标准的设计者，William Morton Kahan 教授在 1989 年获得图灵奖。","text":"现实世界中不仅有整数，还有小数，有没有一种编码，能同时表示它们呢。IEEE 754 是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，简单来说，它采用了类似科学记数法的形式来表示整数和小数。该标准的设计者，William Morton Kahan 教授在 1989 年获得图灵奖。 产生背景因为 定点数 存在两个缺陷 不能有效的表示非常大的数字。 例如，表达式 \\( 5\\times2^{100}\\) 是 \\((101)_2\\) 后面跟着 100 个零的位模式来表示，如果用定点表示法，容易产生溢出。 不能有效的表示小数。 为了解决上述问题，浮点数应运而生。 表示方法科学记数法参照科学记数法，IEEE 浮点标准采用如下形式来表示一个数(Value) $$V = (-1)^s \\times M \\times 2^E$$ \\((-1)^s\\) 表示符号位，当 s=0， V 为正数；当 s=1，V 为负数。 M 表示有效数字，范围属于 [1,2)。 \\(2^E\\) 表示指数位。 例 1十进制的 5.0 写成二进制是 101.0，相当于 \\((1.01)\\times2^2\\)。按照上面的格式，可以得出 s=0，M=1.01，E=2。 有效数字 M因为 \\(1 \\le M &lt; 2\\)，也就是说，M 的整数部分总是为 1，所以我们可以只保留它的小数(fraction)部分，而将开头的 1 省略。这样一来，就能多表示一位有效数字。 在单精度浮点格式中，s、exp、fraction 字段分别为 1、8、23 位。 在双精度浮点格式中，s、exp、fraction 字段分别为 1、11、52 位。 指数 E指数 E 的取值情况比较复杂，我们以 float 浮点类型为例。 当 exp 既不全为 0，也不全为 1 时 E = exp - 127。\\(这里的\\;127\\;是一个偏置值\\;=\\;2^7-1\\)。 \\(有效数字\\;M=1+fraction。\\) 当 exp 全为 0 时 E = 1 - 127。\\(有效数字\\;M=fraction,\\;不用在前面加上\\;1\\)。特别的，当 fraction 全为 0 时，表示 \\(\\pm0\\) (取决于符号位)。 当 exp 全为 1 时 如果 fraction 全为 0，表示 \\(\\pm\\infty\\) (取决于符号位)。 如果 fraction 不全为 0，表示 NaN (Not a Number)。 精度问题十进制和二进制相互转化先看看十进制数和二进制数如何相互转换。用下标表示数的基，\\(d_{10}\\) 表示十进制数，\\(d_2\\) 表示二进制数。 一个具有 n+1 位整数，m 位小数的十进制数 \\(d_{10}\\) 表示为 例 2 $$ (1234.5678)_{10} = 1\\times10^3 + 2\\times10^2 + 3\\times10^1 + 4\\times10^0 + 5\\times10^{-1} + 6\\times10^{-2} + 7\\times10^{-3} + 8\\times10^{-4}$$ 同理，一个具有 n+1 位整数 m 位小数的二进制数 \\(b_2\\) 表示为 例 3 $$ (1010.1001)_2 = 1\\times2^3 + 0\\times2^2 + 1\\times2^1 + 0\\times2^0 + 1\\times2^{-1} + 0\\times2^{-2} + 0\\times2^{-3} + 1\\times2^{-4} $$ 将二进制数转换成十进制数，比较容易，如例 3 所示。而将十进制数转换成二进制数，需要把整数部分和小数部分分开转换，整数部分用 2 除，取余数；小数部分用 2 乘，取整数位。 例 3把 \\((13.125)_{10}\\) 转换成二进制数。 整数部分: \\( (13)_{10} = (1101)_2 \\)\\((1)\\;13\\div2=6 \\; 余数为\\;1 \\Rightarrow 1 \\)\\((2)\\;6\\div2=3 \\; 余数为\\;0 \\Rightarrow 01 \\)\\((3)\\;3\\div2=1 \\; 余数为\\;1 \\Rightarrow 101 \\)\\((4)\\;最后得到的商小于\\;2，\\;所以不用再继续除了。 \\Rightarrow 1101 \\) 小数部分: \\( (0.125)_{10} = (001)_2 \\)\\((1)\\;0.125\\times2=0.25 \\;整数位是\\;0 \\Rightarrow .0 \\)\\((2)\\;0.25\\times2=0.5 \\;整数位是\\;0 \\Rightarrow .00 \\)\\((3)\\;0.5\\times2=1.0 \\;整数位是\\;1 \\Rightarrow .001 \\)\\((4)\\;最后得到的乘积是个整数，所以不用再继续乘了。\\) 所以 \\( (13.125)_{10} = (1101.001)_2 \\)。 一个十进制数能否用二进制浮点数精确表示，关键在于小数部分。 我们来看一个最简单的小数 \\((0.1)_{10}\\) 能否精确表示。\\((1)\\;0.1\\times2=0.2\\;整数位是\\;0 \\Rightarrow .0\\)\\((2)\\;0.2\\times2=0.4\\;整数位是\\;0 \\Rightarrow .00\\)\\((3)\\;0.4\\times2=0.8\\;整数位是\\;0 \\Rightarrow .000\\)\\((4)\\;0.8\\times2=1.6\\;整数位是\\;1 \\Rightarrow .0001\\)\\((5)\\;0.6\\times2=1.2\\;整数位是\\;1 \\Rightarrow .00011\\)\\((6)\\;0.2\\times2=0.4\\;整数位是\\;0 \\Rightarrow .000110 \\ 由第(2)步开始循环。\\)… 我们得到一个无限循环的二进制小数 \\((0.1)_{10}=(0.0\\;0011\\;0011\\;0011\\;…)_2\\)。 用有限位无法表示无限循环小数，因此，\\((0.1)_{10}\\) 无法用 IEEE 754 浮点数精确表示。同时我们还可以得出 \\((0.2)_{10} = (0.0011\\;0011 …)_2\\) \\((0.4)_{10} = (0.0110\\;0110 …)_2\\) \\((0.6)_{10} = (0.1001\\;1001 …)_2\\) \\((0.8)_{10} = (0.1100\\;1100 …)_2\\) 这四个数也无法精确表示。同理 \\((0.3)_{10}\\times2 = 0.6 \\) \\((0.7)_{10}\\times2 = 1.4 \\) \\((0.9)_{10}\\times2 = 1.8 \\) 这三个数也无法精确表示。 所以，从 0.1 到 0.9 这 9 个小数中，只有 0.5 可以精确表示 \\((0.5)_{10} = (0.1)_2\\) 二进制小数能精确表示的十进制小数的基本规律一个十进制小数要能用浮点数精确表示，最后一位必须是 5，因为 1 除以 2 永远是 0.5。当然，这是必要条件，并非充分条件。 一个 m 位二进制小数能够精确表示的小数有多少个呢？ 当然是 \\(2^m\\) 个。而 m 位十进制小数有 \\(10^{m}\\)个，因此，能精确表示的十进制小数的比例是 \\(\\frac{2^m}{10^{m}}=(0.2)^{m}\\)。m 越大，比例值越小。 其实不管是用十进制、二进制或者其它进制，都存在着有限位数无法精确表示的数字。这时候就需要进行舍入。 舍入IEEE 标准列出 4 种不同的舍入方法 最近舍入 舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）。 朝 \\(+\\infty\\) 方向舍入 朝 \\(-\\infty\\) 方向舍入 朝 0 方向舍入 代码验证show-byte.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;/*C 语言中的 typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代码的可读性，因为深度嵌套的类型声明很难读懂。typedef 的语法与声明变量的语法十分相像，除了它使用的是类型名，而不是变量名。1 typedef int *int_pointer;2 int_pointer ip;3 int *ip;2，3 行中的定义是等价的。*/typedef unsigned char * byte_pointer; //用 byte_pointer 声明和用 unsigned char * 声明效果是相同的。void show_bytes(byte_pointer start, size_t len) &#123; size_t i; for(i=0; i&lt;len; i++) &#123; printf(\"%.2x\", start[i]); &#125; printf(\"\\n\");&#125;int main() &#123; float f1=1.1; printf(\"\\nf1 = %0.1f\\n\", f1); show_bytes((byte_pointer)&amp;f1, sizeof(f1)); double d=1.1; show_bytes((byte_pointer)&amp;d, sizeof(d)); float f2=1.3; printf(\"\\nf2 = %0.1f\\n\", f2); show_bytes((byte_pointer)&amp;f2, sizeof(f2)); double d2=1.3; show_bytes((byte_pointer)&amp;d2, sizeof(d2)); float f3=1.7; printf(\"\\nf3 = %0.1f\\n\", f3); show_bytes((byte_pointer)&amp;f3, sizeof(f3)); double d3=1.7; show_bytes((byte_pointer)&amp;d3, sizeof(d3)); float f4=1.9; printf(\"\\nf4 = %0.1f\\n\", f4); show_bytes((byte_pointer)&amp;f4, sizeof(f4)); double d4=1.9; show_bytes((byte_pointer)&amp;d4, sizeof(d4));&#125; little-big-endian1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int i = 0x11223344; char *p; p = (char *) &amp;i; if (*p == 0x44) &#123; printf(\"little endian\\n\"); &#125;else if(*p == 0x11) &#123; printf(\"big endian\\n\"); &#125; return 0;&#125; 我的电脑是 小端序，最低位先输出。 \\((1.1)_{10}\\) \\((3f8ccccd)_{16} = (0011\\;1111\\;1000\\;1100\\;1100\\;1100\\;1100\\;1101)_2\\) 符号位 S = 0 指数 E = exp-127 = 127-127 = 0 小数部分 = \\(000\\;\\overline{1100}\\) 有效数字 M = 1.000 1100 1100 1100 1100 1101 舍入 \\(11\\Rightarrow1\\) \\(Value = (-1)^0\\times(1.000\\;1100\\;…\\;1101)\\times2^0 = 1.000\\;1100\\;1100\\;1100\\;1100\\;1101\\) \\((3ff99999999999a)_{16} = (0011\\;1111\\;1111\\;0001\\;1001\\;1001\\;…\\;1001\\;1010)_2\\) 符号位 S = 0 指数位 E = exp-1023 = 1023-1023 = 0 小数部分 = \\(0001\\;\\overline{1001}\\) 有效数字 M = 1.0001 1001 1001 1001 … 1010 舍入 \\(10\\Rightarrow1\\) \\(Value = (-1)^0\\times(1.0001\\;1001\\;…\\;1010)\\times2^0 = 1.0001\\;1001\\;1001\\;…\\;1001\\;1010\\) \\((1.3)_{10}\\) \\((3fa66666)_{16} = (0011\\;1111\\;1010\\;0110\\;0110\\;0110\\;0110\\;0110)_2\\) 小数部分 = \\(010\\;\\overline{0110}\\) 舍入 \\(01\\Rightarrow0\\) \\((3ff4cccccccccccd)_{16} = (0011\\;1111\\;1111\\;0100\\;1100\\;1100\\;…\\;1100\\;1101)_2\\) 小数部分 = \\(0100\\;\\overline{1100}\\) 舍入 \\(11\\Rightarrow1\\) \\((1.7)_{10}\\) \\((3fd9999a)_{16} = (0011\\;1111\\;1101\\;1001\\;1001\\;1001\\;1001\\;1001)_2\\) 小数部分 = \\(101\\;\\overline{1001}\\) 舍入 \\(10\\Rightarrow1\\) \\((3ffb333333333333)_{16} = (0011\\;1111\\;1111\\;1011\\;0011\\;0011\\;…\\;0011\\;0011)_2\\) 小数部分 = \\((1011\\;\\overline{0011})\\) 舍入 \\(00\\Rightarrow0\\) \\((1.9)_{10}\\) \\((3ff33333)_{16} = (0011\\;1111\\;1111\\;0011\\;0011\\;0011\\;0011\\;0011)_2\\) 小数部分 = \\(111\\;\\overline{0011}\\) 舍入 \\(00\\Rightarrow0\\) \\((3ffe666666666666)_{16} = (0011\\;1111\\;1111\\;1110\\;0110\\;0110\\;…\\;0110\\;0110)_2\\) 小数部分 = \\((1110\\;\\overline{0110})\\) 舍入 \\(01\\Rightarrow0\\) 拓展Q1为什么 exp 需要加上一个偏置值？ A1采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用补码表示的话，符号位 S 和 Exp 自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。 引用 《深入理解计算机系统》 IEEE 754 浮点数的二进制表示 二进制、十进制和十六进制转换器 IEEE 754 浮点数的表示精度探讨","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"浮点数","slug":"浮点数","permalink":"//huminxi.netlify.com/tags/浮点数/"},{"name":"IEEE 754","slug":"IEEE-754","permalink":"//huminxi.netlify.com/tags/IEEE-754/"}]},{"title":"整数在计算机中的表示","slug":"整数在计算机中的表示","date":"2019-03-28T01:52:00.000Z","updated":"2019-04-22T07:11:40.365Z","comments":true,"path":"2019/03/28/整数在计算机中的表示/","link":"","permalink":"//huminxi.netlify.com/2019/03/28/整数在计算机中的表示/","excerpt":"C 语言中编码整数有两种不同的方式，一种只能表示非负数，也称为无符号数；另一种能够表示负数、零和正数，称为有符号数。而 Java 语言中没有无符号数，所有的整数都是有符号数。","text":"C 语言中编码整数有两种不同的方式，一种只能表示非负数，也称为无符号数；另一种能够表示负数、零和正数，称为有符号数。而 Java 语言中没有无符号数，所有的整数都是有符号数。 整数数据类型C 语言支持多种整数数据类型。下图给出了典型的 32 位和 64 位机器上的取值范围。其中 long 类型的取值范围与机器相关。 32 位机器 64 位机器 我们注意到 负数和正数的取值范围是不对称的，负数范围比正数范围大 1。 无符号数假设一个整数数据类型有 w 位，每一位取值为 0 或 1。那么一个 w 位的比特串总共有 2ᵂ 种组合。如果我们把这些组合与整数一一对应起来，我们可以表示 2ᵂ 个整数。其中一种映射关系如下所示。 [0001] = 0x2³ + 0x2² + 0x2¹ + 1x2⁰ = 0 + 0 + 0 + 1 = 1[0101] = 0x2³ + 1x2² + 0x2¹ + 1x2⁰ = 0 + 4 + 0 + 1 = 5[1010] = 1x2³ + 0x2² + 1x2¹ + 0x2⁰ = 8 + 0 + 2 + 0 = 10[1111] = 1x2³ + 1x2² + 1x2¹ + 1x2⁰ = 8 + 4 + 2 + 1 = 15 在整数和比特串之间建立映射关系的过程就是编码的过程。 w 位的二进制数可以表示的无符号整数范围是 0 ~ 2ᵂ-1。 有符号数不知道是从哪里听到过一种说法，说可以把最高位当做是符号位，这样就能区分正负数了。但是，把最高位当做符号位只是人为规定的，计算机并不知情。 模在日常生活中，仔细观察会发现 把物体左转 90 度和右转 270 度，在不考虑圈数的情况下，最终的效果是相同的。 把分针顺时针拨 20 分钟和逆时针拨 40 分钟，在不考虑时针的情况下，效果也是相同的。 把数字 87 减去 25 和加上 75，在不考虑百位数的情况下，效果也是相同的。 上述几组数字，有这样的关系: 90 + 270 = 36020 + 40 = 6025 + 75 = 100 式中的 360、60 和 100 就是模。假如我们提前就知道模的值，那么就能把减法化为加法。 自定义编码如果用 8 位二进制数来编码有符号数，2⁸ = 256，那么模就是 256。例如，计算 127 - 1 = ?。利用模的特性，我们可以将减法化为加法。即 127 - 1 &lt;=&gt; 127 + 255。 127 127 - 1 &lt;=&gt; + 255 ---- ----- 126 256+126，忽略最左边的进位 256，最后结果为 126。 用二进制表示如下 0111 1111 0111 1111 - 0000 0001 &lt;=&gt; + 1111 1111 --------- --------- 0111 1110 1 0111 1110 ，忽略最左边的进位 1，最后结果为 126。 在不考虑进位的前提下，不难发现 -1 和 [1111 1111] 之间存在着一种映射关系。假如我们按如下的方式来编码 8 位二进制数： 二进制数 十进制数 1000 0000 -128 1000 0001 -127 1000 0010 -126 1000 0011 -125 … … 1111 1101 -3 1111 1110 -2 1111 1111 -1 0000 0000 0 0000 0001 1 0000 0010 2 … … 0111 1101 125 0111 1110 126 0111 1111 127 在得到 [-128, 127] 的二进制编码的同时，又将减法运算化为了加法运算。这种编码方式，叫做补码(two’s complement)，这是最常见的有符号数在计算机中的表示方式。 引用 《Code:The Hidden Language of Computer Hardware and Software》 《深入理解计算机系统》 原码、反码和补码","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"整数","slug":"整数","permalink":"//huminxi.netlify.com/tags/整数/"},{"name":"无符号数","slug":"无符号数","permalink":"//huminxi.netlify.com/tags/无符号数/"}]},{"title":"聊聊内网穿透","slug":"聊聊内网穿透","date":"2019-02-28T02:52:41.000Z","updated":"2019-03-13T03:44:10.034Z","comments":true,"path":"2019/02/28/聊聊内网穿透/","link":"","permalink":"//huminxi.netlify.com/2019/02/28/聊聊内网穿透/","excerpt":"最近在开发支付系统，在和第三方支付渠道联调出现一个问题：我的电脑是在公司的内网中，无法收到渠道发出的异步回调通知。要想解决这个问题，就需要进行内网穿透，于是在内网穿透工具 frp 的帮助下，成功的解决了这个问题。","text":"最近在开发支付系统，在和第三方支付渠道联调出现一个问题：我的电脑是在公司的内网中，无法收到渠道发出的异步回调通知。要想解决这个问题，就需要进行内网穿透，于是在内网穿透工具 frp 的帮助下，成功的解决了这个问题。 什么是内网网络中进程怎么通信我们知道，IP 地址相当于每个计算机在网络中的唯一编号，端口号(Port)则是运行在这台计算机中的进程的唯一编号。所以，利用 IP + Port 就能在互联网中实现进程间的通信。 私有 IP 地址在互联网的地址架构中，有一些 IP 地址是私有 IP 地址，这些地址无法直接连接互联网。与公网 IP 地址相比，私有 IP 是免费的，常用于家庭、学校和企业的局域网。 IPv4 私有地址如下所示 IP 地址区段 最大 CIDR 区块(子网掩码) IP 数量 10.0.0.0 - 10.255.255.255 10.0.0.0/8(255.0.0.0) 1677 7216 172.16.0.0 - 172.31.255.255 172.16.0.0/12(255.240) 104 8576 192.168.0.0 - 192.168.255.255 192.168.0.0/16(255.255.0.0) 6 5536 Mac 电脑上可以用 ifconfig 命令来查看自己的 IP 地址。 用 ifconfig 命令展示出来的有 en0 en1 en2 en3 en4。到底那个才是我正在使用的 IP 地址呢，运行一下命令: 1networksetup -listallhardwareports IP 数据报IP 数据报(datagram)可分为 Head 和 Data 两个部分。 IPv4 datagram format 由上图我们可以发现，每个 IP 数据报中都包含了源 IP 地址、目的 IP 地址两个字段，分别用来标识数据报的发送主机 IP 和目标主机 IP。 问题 1假设我现在要访问 Google 的搜索服务(216.58.200.36)，那么由我的主机发送出的每个 IP 报文中的源 IP 地址就是 10.100.21.4，目的地址就是 216.58.200.36。但是， 10.100.21.4 是一个私有 IP 地址，之前说过，私有 IP 地址无法直接和互联网相连。那么我们平时又是怎么上的网呢？(假定路由器的内网 IP 地址为 10.100.20.254，公网 IP 地址为 118.184.5.17) 怎么穿透这时候就要用到 NAT(Network Address Translation) ，它是一种在 IP 数据报通过路由器或防火墙时重写源 IP 地址或目的 IP 地址的技术。 Basic NAT它的功能比较简单，仅支持地址转换，不支持端口映射。Basic NAT 要求对每一个当前连接都要对应一个公网 IP 地址。Basic NAT 要维护一个如下的转换表。 内网 IP 公网 IP 192.168.1.220 169.254.34.148 192.168.1.221 169.254.34.149 192.168.1.222 169.254.34.150 缺点 很多时候我们没有大量的公网 IP 地址，无法做到一一映射。 NAPT网络地址端口转换(Network Address Port Translation)，这种方式支持端口映射，允许多台主机共享一个公网 IP 地址。NAPT 要维护一个 IP + Port 的转换表。 内网 IP 公网 IP 192.168.1.220:7788 169.254.34.148:10001 192.168.1.221:80 169.254.34.149:10002 192.168.1.222:443 169.254.34.150:10003 回答 1回到我们之前提出的问题 1，当我向 Google 的搜索服务(216.58.200.36:80)发送的报文到达路由器时，它会将报文中的源 IP 地址改为它自己的公网 IP 地址(118.184.5.17)，并且随机分配一个未被占用的端口号 9102(1024-65535)，最后在转换表中插入一条这样的记录。 内网 IP 公网 IP … … 10.100.21.4:2048 118.184.5.17:9102 当 IP 数据报到达 Google 的搜索服务之后，Google 给我们回复的 IP 数据报中的源 IP 地址就为 216.58.200.36:80，而目的 IP 地址就是我们路由器的 IP 地址 118.184.5.17:9102。而路由器接收到这份报文之后，根据转换表中的记录，将数据报中的目的 IP 地址替换成 10.100.21.4:2048，这样就能正确地转发 IP 数据报到我的主机上了。 小结一下完成内网穿透的三要素: 一台内网中的主机 一台拥有公网 IP 的 NAT 服务器。 一台公网中的主机 内网穿透工具很多工具都能实现内网穿透，像 nogrok、花生壳、frp 等，这里使用的是 frp。 frp 介绍 frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。 frp 使用step0建议先看一下 README.md。 step1去 github 上下载 RELESAE 包。 利用 ssh 命令登录到 Linux 服务器然后按顺序执行以下命令。 123wget https://github.com/fatedier/frp/releases/download/v0.24.1/frp_0.24.1_linux_amd64.tar.gztar -zxvf frp_0.24.1_linux_amd64.tar.gzcd frp_0.24.1_linux_amd64 解压之后的目录 step3修改 frps.ini 文件1234#frps.ini[common]bind_port = 7000vhost_http_port = 8080 启动 frps 1./frps -c frps.ini frps 日志 step4修改 frpc.int 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x 123456789#frpc.ini[common]server_addr = x.x.x.x server_port = 7000[web]type = httplocal_port = 8080custom_domains = x.x.x.x 启动 frpc 1./frpc -c frpc.ini frpc 日志 frps 日志 启动过程中可能会遇到的问题 服务器/客户端的指定的端口已经被占用。 Linux 通过 netstat -nap | grep 7000 命令查看 7000 端口是否已经被占用。 Mac 通过 netstat -nap tcp | grep 8080 命令查看 8080 端口是否已经被占用。 服务器的 7000 端口没有开放。 用 firewall-cmd --query-port=7000/tcp --zone=public 命令看看是否已经打开。 如果关闭着，用 firewall-cmd --zone=public --add-port=7000/tcp --permanent 命令打开，然后重启服务器。 其它问题 Google step5至此，你已经成功的建立起了一个 NAT 映射，快去验证一下吧。 frps 日志 拓展正向代理和反向代理 引用 IPv4 frp 网络地址转换 专用网络 linux 如何开放端口 frp 实现内网穿透 Mac OS X ifconfig 命令解释 正向代理与反向代理","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"NAT","slug":"NAT","permalink":"//huminxi.netlify.com/tags/NAT/"},{"name":"内网穿透","slug":"内网穿透","permalink":"//huminxi.netlify.com/tags/内网穿透/"}]},{"title":"Observer","slug":"Observer","date":"2019-02-13T06:59:39.000Z","updated":"2019-02-28T03:54:29.242Z","comments":true,"path":"2019/02/13/Observer/","link":"","permalink":"//huminxi.netlify.com/2019/02/13/Observer/","excerpt":"看过直播的同学都知道，直播房间里有个订阅按钮，当你点击订阅之后，下次主播再开播时你就能在第一时间收到通知，以免你错过精彩内容。这就是观察者模式的一种经典应用。","text":"看过直播的同学都知道，直播房间里有个订阅按钮，当你点击订阅之后，下次主播再开播时你就能在第一时间收到通知，以免你错过精彩内容。这就是观察者模式的一种经典应用。 示例程序场景假设我们有一个记录天气的气象站，它会收集湿度、温度、气压这三个天气数据，需要在不同类型的显示装置中展示天气。如下图所示 现在我们有一个记录天气变化的类 WeatherData。还有不同类型的显示装置类 FullConditionsDisplay 和 PartConditionsDisplay。 类结构图 Observer123public interface Observer &#123; public void update(float temperature, float humidity, float pressure);&#125; Subject12345public interface Subject &#123; public void addObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125; DisplayElement123public interface DisplayElement &#123; public void display();&#125; 天气123456789101112131415161718192021222324252627282930313233343536373839public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;&gt;(); &#125; @Override public void addObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; observers.remove(o); &#125; @Override public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++) &#123; Observer observer = observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; 观察者 1 号1234567891011121314151617181920212223242526//展示全部的天气数据。public class FullConditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private float pressure; private Subject weatherData; public FullConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.addObserver(this); &#125; @Override public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; display(); &#125; @Override public void display() &#123; System.out.println(\"full conditions:: temperature:\" + temperature + \"\\t humidity:\" + humidity + \"\\t pressure:\" + pressure); &#125;&#125; 观察者 2 号1234567891011121314151617181920212223//展示部分天气数据。(温度和湿度)public class PartConditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public PartConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.addObserver(this); &#125; @Override public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = pressure; display(); &#125; @Override public void display() &#123; System.out.println(\"part conditions:\" + temperature + \"F degrees and \" + humidity + \"% humidity.\"); &#125;&#125; Main12345678910public class Main &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); PartConditionsDisplay partConditionsDisplay = new PartConditionsDisplay(weatherData); FullConditionsDisplay fullConditionsDisplay = new FullConditionsDisplay(weatherData); weatherData.setMeasurements(80, 65, (float) 30.44); weatherData.setMeasurements(75, 70, (float) 38.44); &#125;&#125; 运行结果 github 代码地址 扩展 JDK 内置了 Observer 模式，但是却在 JDK9 之后将其标记为 @Deprecated，为什么呢？ Observable 被定义成一个类，而不是接口。由于 Java 是单继承的，JDK 内置的实现不够灵活(比如你还想额外继承一个自己的类)，无法满足特定场景。 Observable 没有实现 Serializable 接口，无法进行序列化，导致其无法适用于网络编程。 既然如此，有能替代它的吗？有，在 java.beans 包中。 PropertyChangeListener(Observer)。 PropertyChangeSupport(Observable)。 引用 Head First 设计模式 Observer is deprecated in Java 9. What should we use instead of it?","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.netlify.com/categories/设计模式/"}],"tags":[{"name":"Observer","slug":"Observer","permalink":"//huminxi.netlify.com/tags/Observer/"},{"name":"观察者模式","slug":"观察者模式","permalink":"//huminxi.netlify.com/tags/观察者模式/"}]},{"title":"POP OOP and AOP","slug":"POP OOP and AOP","date":"2019-01-08T02:05:10.000Z","updated":"2019-04-22T07:17:46.451Z","comments":true,"path":"2019/01/08/POP OOP and AOP/","link":"","permalink":"//huminxi.netlify.com/2019/01/08/POP OOP and AOP/","excerpt":"POP(Procedure Oriented Programming) 面向过程编程；OOP(Object Oriented Programming) 面向对象编程；AOP(Aspect Oriented Programming) 面向切面编程。这三组单词代表了三种不同的编程思想，今天我们就一起来研究一下它们具体的含义吧。","text":"POP(Procedure Oriented Programming) 面向过程编程；OOP(Object Oriented Programming) 面向对象编程；AOP(Aspect Oriented Programming) 面向切面编程。这三组单词代表了三种不同的编程思想，今天我们就一起来研究一下它们具体的含义吧。 POP and OOP记得刚开始学习 C 语言的时候，老师给我们布置了一个作业，写一个运行在 DOS 窗口的简易学生信息系统。当时也没想太多，就一门心思想着怎么才能实现功能。代码如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAX 20typedef struct student&#123; long int sno; //学号 int sage; //年龄 char sname[MAX]; //姓名 char sclass[MAX]; //班级 struct student *next; //结构体指针&#125;student; student *head; //链表的头指针（全局变量） //提前声明接下来将会用到的函数。void menu(); void toAdd(); void toModify(); void toDelete(); void toSearch(); void toOutput(); void toReadData(); void toSaveData(); void main()&#123; int n = -1; //作为接受用户输入的操作指令的变量。 head = (student *)malloc(sizeof(struct student)); //程序中链表的形式为带有头结点的形式。 head-&gt;next = NULL; toReadData(); //当程序开始运行后，toReadData() 函数中把所有的学生信息数据以单向链表的形式读入到内存当中。 menu(); while(n) //具体实现。 &#123; printf(\"输入(0-5)进行操作:\\n\"); scanf(\"%d\", &amp;n); while(n&lt;0 || n&gt;5) &#123; printf(\"错误，输入(0-5)进行操作:\\n\"); scanf(\"%d\", &amp;n); &#125; switch(n) &#123; case 1: toAdd(); break; case 2: toDelete(); break; case 3: toSearch(); break; case 4: toModify(); break; case 5: toOutput(); break; case 0: printf(\"谢谢使用！\\n\"); exit(0); break; default: printf(\"错误！\"); &#125; &#125;&#125; void menu() //菜单函数，用来提示用户进行操作。&#123; printf(\"----~~~~----~~~~----~~~~----~~~~----~~~~----~~~~----~~~~----~~~~----~~~~----~~~~\"); printf(\" ~~~~----~~~~----~~~~----~~~~----~~~~----~~~~\\n\"); printf(\" ---- 欢迎来到学生信息管理系统 ----\\n\"); printf(\" ~~~~ ~~~~\\n\"); printf(\" ----~~~~----~~~~----~~~~----~~~~----~~~~----\\n\"); printf(\" ~~~~----~~~~----~~~~----~~~~----~~~~----~~~~\\n\"); printf(\" ---- 操作 示例: ----\\n\"); printf(\" ~~~~ 1. 注册 ~~~~\\n\"); printf(\" ---- 2. 删除 ----\\n\"); printf(\" ~~~~ 3. 寻找 ~~~~\\n\"); printf(\" ---- 4. 修改 ----\\n\"); printf(\" ~~~~ 5. 概览 ~~~~\\n\"); printf(\" ---- 0. 退出 ----\\n\"); printf(\" ~~~~----~~~~----~~~~----~~~~----~~~~----~~~~\\n\"); &#125; void toAdd() //新增学生。&#123;...&#125;void toModify() //修改学生的信息。&#123;...&#125;void toDelete() //删除学生。&#123;...&#125;void toSearch() //查询学生信息。&#123;...&#125;void toOutput() //输出全部学生的信息。&#123;...&#125;void toReadData() //读取文件。&#123;...&#125;void toSaveData() //写入文件。&#123;...&#125; 上面的这个程序充分体现了 POP 的思想，即以功能为中心来思考和组织程序。注重的是数据加工和处理的过程，说白了就是注重功能的实现，效果达到了就行。 而 OOP 则注重封装，强调整体性的概念，以对象为中心，将对象的内部组织和外部环境区分开来。有一个比较贴切的例子如下图所示。 假如我们把程序设计比喻为房子的布局。在一间房子的布局中，需要不同功能的家具和洁具(method)，例如马桶、浴缸、洗浴台、燃气灶、水槽、餐桌、床、电视等。POP 的程序设计更注重的是功能的实现(method 是否存在)，效果符合预期就好。因此 POP 的程序设计会更倾向于左边的房间布局，各种家具齐备(method 都在)，房子也就可以正常居住了。 这对于 OOP 的程序设计来说则是无法忍受的，这样布局下的家具和洁具不仅摆放随意，而且相互之间暴露的几率大大增加。 为了更优雅的设计，OOP 程序设计采用了右侧的布局。其中设置了许多小房间，每个小房间都有各自的名称和相应功能(在 Java 语言中这样的小房间被称为 Class)。例如，卫生间是大小解和洗澡梳妆用的，卧室是休息用的，厨房则是做饭用的，每个小房间都各司其职且无需时刻向外界暴露内部的结构，整个房子结构清晰，外界只需要知道有某个房间并使用该房间提供的各项功能即可(method 调用)。 OOP 这样布局的好处是显而易见的。 有利于后期的拓展。 毕竟哪些功能需要添加到哪个小房间，依照分类标准很快就能找到。 可以组织更复杂的程序。 当代码量上来之后，不可能都写在同一个 .c 文件中，需要根据职责拆分成多个 .c 文件，这也符合 单一功能原则。 OOP and AOP但随着软件规模的增大，应用的逐渐升级，慢慢地，OOP 也开始暴露出一些问题。 123456789public class A &#123; public void methodA() &#123; //其它业务操作省略... recordLog(); &#125; public void recordLog() &#123; ... &#125;&#125; 123456789public class B &#123; public void methodB() &#123; //其它业务操作省略... recordLog(); &#125; public void recordLog() &#123; ... &#125;&#125; 123456789public class C &#123; public void methodC() &#123; //其它业务操作省略... recordLog(); &#125; public void recordLog() &#123; ... &#125;&#125; 假设存在 A、B、C 三个类，需要在它们的方法被访问时进行日志记录，于是它们的代码中均实现了 recordLog 方法。或许对现在的工程师来说几乎不可能写出如此糟糕的代码，但 OOP 中这样的写法是允许的，而且在 OOP 的初期这样的代码确实存在着。 直到某一天，工程师实在忍受不了『一次修改，到处挖坟』（到处修改 recordLog 方法），才下定决心要解决该问题。为了解决程序间冗余代码的问题，工程师开始使用下面的编码方式。 123456789101112131415161718192021222324252627282930//A 类public class A &#123; public void executeA() &#123; //其他业务操作省略... Report.recordLog(args ...); &#125;&#125;//B 类public class B &#123; public void executeB() &#123; //其他业务操作省略... Report.recordLog(args ...); &#125;&#125;//C 类public class C &#123; public void executeC() &#123; //其他业务操作省略... Report.recordLog(args ...); &#125;&#125;//recordLogpublic class Report &#123; public static void recordLog(args ...) &#123; ... &#125;&#125; 采取这样的编码方式，我们欣喜地发现『挖坟问题』被有效地解决了，当 recordLog 方法需要调整时，只需调整 Report 类就行，这就大大降低了软件后期维护的复杂度。而且除了上述的解决方案，还存在一种利用继承来解决的方式(不推荐，应优先使用聚合而不是继承)。 123456789101112131415161718192021222324252627//父类public class Parent &#123; public void recordLog() &#123; ... &#125;&#125;//A 继承 Parent public class A extends Parent &#123; public void executeA() &#123; //其他业务操作省略... recordLog(); &#125;&#125;//B 继承 Parent public class B extends Parent &#123; public void executeB() &#123; //其他业务操作省略... recordLog(); &#125;&#125;//C 继承 Parent public class C extends Parent &#123; public void executeC() &#123; //其他业务操作省略... recordLog(); &#125;&#125; 事实上，有了上述两种解决方案后，大部分业务场景下的代码冗余问题被有效地解决了，其原理如下图所示。 解决 OOP 代码冗余问题的两种方案 随着软件系统越来越复杂，工程师发现，OOP 又面临新的问题。核心业务中总掺杂着一些它并不关心的通用业务。 如日志记录，权限验证，事务控制，性能检测，错误信息检测等等。 我们来看一个简单例子。 123456789101112131415161718192021222324public class UserServiceImpl implements UserService &#123; private Authorization auth; //权限管理对象 private Log log; //日志操作对象 private UserDao userDao; //核心业务对象 private Transaction transaction; //事务控制对象 @Override public void saveUser() &#123; auth.valid(); //权限验证 log.record(); //日志操作 userDao.saveUser(); //核心业务操作 transaction.commit(); //事务控制 &#125; @Override public void deleteUser() &#123; ... &#125; @Override public void findUser() &#123; ... &#125;&#125; 真正核心业务代码其实就只有一行，但它已经淹没在了众多通用代码之中。 新的问题又来了。 模块混杂。 核心业务模块可能需要兼顾通用业务模块，这些通用业务可能会混乱核心业务的代码。而且当通用业务模块有重大修改时也会影响到核心业务模块，这显然是不合理的。 代码冗余 通用业务模块的代码在许多核心业务模块随处可见，又出现了冗余代码问题。 在新问题面前，前面提及的两种解决方案都已经束手无策了，那么该如何解决呢？事实上我们知道诸如日志、权限、事务、性能监测等业务几乎涉及到了所有的核心业务。如果把这些通用业务的代码直接写入核心业务的代码中就会造成上述的问题，所以工程师希望的是这些通用业务模块可以实现 热插拔 特性 。 假设现在我们把日志、权限、事务、性能监测等通用业务看作单独的模块(concerns)，每个模块都可以在需要它们的时刻及时被运用且无需提前整合到核心模块中，这种形式相当于下图所示。 AOP 从图可以看出，每个关注点与核心业务模块分离，作为单独的功能，进而横切了几个核心业务模块。这样的做的好处是显而易见的——核心模块只需关注自己相关的业务，当需要通用业务(日志，权限，性能监测、事务控制)时，这些通用业务会通过一种特殊的技术自动应用到核心模块中，而这种技术的名称就叫作 AOP。 AOP 的实现技术有多种，其中与 Java 无缝对接的是一种称为 AspectJ 的技术。那么这种 AspectJ 是如何在 Java 中的应用呢？它与 Spring AOP 又有什么关联呢？咱们下次再聊。 小结无论是 POP OOP 还是 AOP，都只是程序设计的一种指导思想而已，本身并没有什么高低之分。也没有 OOP AOP 就一定比 POP 好用的说法，这需要具体程序具体分析。 引用 关于 Spring AOP (AspectJ) 你该知晓的一切 简易学生信息管理系统 Getting Started with AspectJ","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"POP","slug":"POP","permalink":"//huminxi.netlify.com/tags/POP/"},{"name":"AOP","slug":"AOP","permalink":"//huminxi.netlify.com/tags/AOP/"},{"name":"OOP","slug":"OOP","permalink":"//huminxi.netlify.com/tags/OOP/"}]},{"title":"macOS 编译 OpenJDK 10","slug":"macOS 编译 OpenJDK 10","date":"2019-01-03T01:27:14.000Z","updated":"2019-10-25T11:45:30.213Z","comments":true,"path":"2019/01/03/macOS 编译 OpenJDK 10/","link":"","permalink":"//huminxi.netlify.com/2019/01/03/macOS 编译 OpenJDK 10/","excerpt":"最近在阅读 《深入理解 Java 虚拟机》 一书，于是就想跟书中一样编译一个自己的 JDK 出来。","text":"最近在阅读 《深入理解 Java 虚拟机》 一书，于是就想跟书中一样编译一个自己的 JDK 出来。 前期准备开始前建议阅读一下 OpenJDK 的官方构建文档 Building OpenJDK。 下载 OpenJDK 源码因为 OpenJDK 源码是用的 Mercurial 管理的，所以需要先安装一下 Mercurial 工具。1brew install mercurial 安装完成后按顺序执行下面的命令。123hg clone http://hg.openjdk.java.net/jdk10/jdk10cd jdk10bash ./get_source.sh (或 chmod +x get_source.sh &amp;&amp; ./get_source.sh) 注意 get_source.sh 脚本下载时间较长，而且容易中断。需要多次执行 bash ./get_source.sh 命令。 execute ./get_source.sh before execute ./get_source.sh complete boot JDK Paradoxically, building OpenJDK requires a pre-existing JDK. This is called the “boot JDK”. The boot JDK does not have to be OpenJDK, though. 所以这里准备的 boot JDK 是 Oracle JDK 8u191。 boot JDK Xcode因为之前没用过 Xcode，于是就去 AppStore 中下载了一个最新版的 Xcode(10.1)，结果就被坑了。原来是 c++ 相关的 stdlibc++ 库被替换 成了 libc++，只能去 官网 重新下载了 Xcode(9.4.1)。 freetype FreeType2 from The FreeType Project is required on all platforms. At least version 2.3 is required. 1brew install freetype 1brew reinstall freetype 环境描述 OS: macOS Mojave 10.14.1 Boot JDK: 1.8.0_191 freetype: 2.9.1 Xcode: 9.4.1 开始编译初始化先清理一下之前的编译结果，如果是第一次编译的话可以跳过这步。1make clean 配置参数1sh configure --with-debug-level=slowdebug --disable-warnings-as-errors --with-freetype-include=/usr/local/Cellar/freetype/2.9.1/include/freetype2 --with-freetype-lib=/usr/local/Cellar/freetype/2.9.1/lib 这里我用的 freetype 版本是 2.9.1，记得替换版本号。 具体的编译参数通过 sh configure -h 查看，可以自行定义。 编译1make all 验证123cd build/macosx-x86_64-normal-server-slowdebug/jdk/bin./java -versionjava -version 总结 不要放弃 如果今天编译不出来，那就明天再来。 如果 OpenJDK 10 编译不出来，那就换 OpenJDK 9。还不行，那就用 9u。我自己就是从 7 一直试到了 10。 不要用 Xcode 10，建议用 Xcode 9 因为 10 中将 c++ 相关的依赖库由 stdlibc++ 替换成了 libc++。我自己还没有解决这个依赖问题，干脆就重新下载了 Xcode 9.4.1。 善用 Google 这只是在我的环境中编译成功了，在你们的环境中也许还会遇到其它的问题，这时候就要自己去问 Google。 引用 《深入理解 Java 虚拟机》 Building OpenJDK 自己动手，在 macOS High Sierra 中编译一个可 debug 的 JDK Xcode 10 beta 4 - stdlibc++ headers not found","raw":null,"content":null,"categories":[{"name":"JVM","slug":"JVM","permalink":"//huminxi.netlify.com/categories/JVM/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"//huminxi.netlify.com/tags/macOS/"},{"name":"openJDK","slug":"openJDK","permalink":"//huminxi.netlify.com/tags/openJDK/"}]},{"title":"Bridge","slug":"Bridge","date":"2018-12-24T05:23:33.000Z","updated":"2018-12-24T09:15:39.205Z","comments":true,"path":"2018/12/24/Bridge/","link":"","permalink":"//huminxi.netlify.com/2018/12/24/Bridge/","excerpt":"在现实世界中，桥梁的功能是将河流的两侧连接起来。Bridge 模式的作用也是将两样东西连接起来，它们分别是『类的功能层次结构』和『类的实现层次结构』。那么，『类的功能层次结构』和『类的实现层次结构』分别指的是什么呢？","text":"在现实世界中，桥梁的功能是将河流的两侧连接起来。Bridge 模式的作用也是将两样东西连接起来，它们分别是『类的功能层次结构』和『类的实现层次结构』。那么，『类的功能层次结构』和『类的实现层次结构』分别指的是什么呢？ 类的层次结构在开始阅读 Bridge 模式的示例代码之前，我们需要先来理解一下这两种层次结构。这是因为如果不能理解河流两边的土地，也就无法理解桥梁存在的意义了。 划分增加新的功能假设有一个类 Something。当我们想在 Something 中增加新功能时(想增加一个具体的方法)，会编写一个 Something 类的子类，即 SomethingGood 类。这样就构成了一个小小的层次结构。 12Something SomethingGood 这就是为了增加新的功能而产生的层次结构。 父类具有基础功能 在子类中增加新的功能 以上这种层次结构被称为『类的功能层次结构』。 增加新的实现在 Template Method 模式中，我们学习了抽象类的作用。抽象类声明了一些抽象方法，定义好 API，然后由子类去负责实现这些抽象方法。 这里其实也存在层次结构。例如，当子类 ConcreteClass 实现了父类 AbstractClass 类的抽象方法时，他们之间就构成了一个小小的层次结构。 12AbstractClass concreteClass 但是，这里的类的层次结构并非用于增加功能。它的真正作用是帮助我们实现下面这样的任务分担。 父类通过声明抽象方法来定义接口 子类通过实现具体方法来实现接口 这种层次结构被称为『类的实现层次结构』。 作用通过前面的学习，大家应该理解了类的功能层次结构与类的实现层次结构。那么，当我们想要编写子类时，就需要像这样先确认自己的意图：我是要增加功能呢？还是要增加实现呢？ 示例程序下面我们来看一段使用了 Bridge 模式的示例程序。这段程序的功能是『显示一些东西』。 在桥的哪一侧 类名 说明 功能层次 Display 负责『显示』的类 功能层次 CountDisplay 增加了『指定显示次数』功能 实现层次 DisplayImpl 负责『显示』的类 实现层次 StringDisplayImpl 『用字符串显示』的类 Main 测试程序行为 类结构图 功能_Display123456789101112131415161718192021public class Display &#123; private DisplayImpl impl; public Display(DisplayImpl impl) &#123; this.impl = impl; &#125; public void open() &#123; impl.rawOpen(); &#125; public void print() &#123; impl.rawPrint(); &#125; public void close() &#123; impl.rawClose(); &#125; public final void display() &#123; open(); print(); close(); &#125;&#125; Display 类的功能是抽象的，负责『显示一些东西』。该类位于『类的功能层次结构』的最上层。 impl 字段中保存的是实现了 Display 类的具体功能的实例。impl 字段即是类的两个层次结构之间的桥梁。 open、print、close 这三个方法是 Display 类提供的接口，他们表示显示的步骤。这三个方法都调用了 impl 字段的实现方法。这样，Display 的接口就被转换成为了 DisplayImpl 的接口。 功能_CountDisplay1234567891011121314public class CountDisplay extends Display &#123; public CountDisplay(DisplayImpl impl) &#123; super(impl); &#125; //循环显示 times 次。 public void multiDisplay(int times) &#123; open(); for (int i = 0; i &lt; times; i++) &#123; print(); &#125; close(); &#125;&#125; CountDisplay 类在 Display 类的基础上增加了一个新功能。Display 类只具有『显示』的功能，CountDisplay 类则具有『显示规定次数』的功能，这就是 multiDisplay 方法。 实现_DisplayImpl12345public abstract class DisplayImpl &#123; public abstract void rawOpen(); public abstract void rawPrint(); public abstract void rawClose();&#125; DisplayImpl 类位于『类的实现层次结构』的最上层。DisplayImpl 是抽象类，它声明了 rawOpen、rawPrint、rawClose 这三个抽象方法，他们分别与 Display 类中的 open、print、close 方法相对应。 实现_StringDisplayImpl12345678910111213141516171819202122232425262728public class StringDisplayImpl extends DisplayImpl &#123; private String string; private int width; public StringDisplayImpl(String s) &#123; this.string = s; this.width = s.getBytes().length; &#125; @Override public void rawOpen() &#123; printLine(); &#125; @Override public void rawPrint() &#123; System.out.println(\"|\" + string + \"|\"); &#125; @Override public void rawClose() &#123; printLine(); &#125; private void printLine() &#123; System.out.print(\"+\"); for (int i = 0; i &lt; width; i++) &#123; System.out.print(\"-\"); &#125; System.out.println(\"+\"); &#125;&#125; StringDisplayImpl 是真正的实现类。它继承了 DisplayImpl 类，实现了 DisplayImpl 中定义的接口。 Main1234567891011public class Main &#123; public static void main(String[] args) &#123; Display d1 = new Display(new StringDisplayImpl(\"Hello, China.\")); Display d2 = new CountDisplay(new StringDisplayImpl(\"Hello, World.\")); CountDisplay d3 = new CountDisplay(new StringDisplayImpl(\"Hello, Universe.\")); d1.display(); d2.display(); d3.display(); d3.multiDisplay(5); &#125;&#125; 运行结果 Bridge 中的角色Bridge 中的角色介绍 总结分开后更容易扩展Bridge 模式的特征是将『类的功能层次结构』与『类的实现层次结构』分离开了。将类的这两个层次结构分离开有利于独立地对它们进行扩展(见习题)。当想要增加功能时，只需要在『类的功能层次结构』一侧增加类即可，不必对『类的实现层次结构』做任何修改。而且，增加后的功能可以被所有的实现使用。 例如，我们可以将『类的功能层次结构』应用于软件所运行的操作系统上。如果我们将某个程序中依赖于操作系统的部分划分为 Windows 版、Macintosh 版、Unix 版，那么我们就可以用 Bridge 模式中的『类的实现层次结构』来表现这些依赖于操作系统的部分。也就是说，我们需要编写一个定义这些操作系统的共同接口(API)的 Implementor 角色，然后编写 Windows 版、Macintosh 版、Unix 版的 3 个 ConcreteImplementor 角色。这样一来，无论在『类的功能层次结构』中增加多少个功能，它们都可以工作于这 3 个操作系统上。 习题(1) 请在本章的示例程序中增加一个类，实现『显示字符串若干（随机）次』的功能。请注意此时应当扩展（继承）哪个类。提示用于显示的方法是 void randomDisplay(int times)，它的作用是将字符串随机显示 0-times 次。 (2) 请在本章的示例程序中增加一个类，实现『显示文本文件的内容』的功能。请注意此时应当扩展（继承）哪个类。 (3) 请在本章的示例程序中增加类，以实现下图的输出效果。 输出结果示例1输出结果示例2 请思考我们是应当在『类的功能层次结构』中增加类呢？还是应当在『类的实现层次结构』中增加类呢？ 需要一种新的显示方式，那么应当是在『类的功能层次结构』中增加类吧？不过，又好像只要增加一个新的显示字符串的方法就可以了，那么还是在『类的实现层次结构』中增加类会更好吧？究竟应该如何在 Bridge 模式中增加这个类呢？ 答案github 地址 引用 图解设计模式","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.netlify.com/categories/设计模式/"}],"tags":[{"name":"Bridge","slug":"Bridge","permalink":"//huminxi.netlify.com/tags/Bridge/"},{"name":"桥接模式","slug":"桥接模式","permalink":"//huminxi.netlify.com/tags/桥接模式/"}]},{"title":"Builder","slug":"Builder","date":"2018-12-19T08:30:43.000Z","updated":"2018-12-24T08:38:33.010Z","comments":true,"path":"2018/12/19/Builder/","link":"","permalink":"//huminxi.netlify.com/2018/12/19/Builder/","excerpt":"想必受过 POJO 中 getter、setter、toString 方法折磨的同学都用过 Lombok，今天我们就一起来探讨一下 Lombok 中是怎样实现 Builder 模式的。","text":"想必受过 POJO 中 getter、setter、toString 方法折磨的同学都用过 Lombok，今天我们就一起来探讨一下 Lombok 中是怎样实现 Builder 模式的。 User 类假设我们存在这样一个 POJO 类，而且客户端在构建 User 对象时并非所有的字段都是必选的。123456public class User &#123; private String name; private int age; private String phone; private Address address;&#125; 1234public class Address &#123; private String zip; private String name;&#125; 不用 Builder 模式为了满足上述场景，我们需要为 User 类构建如下所示的构造函数。 123456789101112131415161718public User(String name) &#123; this(name, 0);&#125;public User(String name, int age) &#123; this(name, age, null);&#125;public User(String name, int age, String phone) &#123; this(name, age, phone, null);&#125;public User(String name, int age, String phone, Address address) &#123; this.name = name; this.age = age; this.phone = phone; this.address = address;&#125; 不但有着繁杂的构造函数，而且客户端调用时还需要注意传参的顺序。 使用 Builder 模式通过 Lombok 中 @Builder 注解生成的 User 类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class User &#123; private String name; private int age; private String phone; private Address address; //User 类只需要一个接收全部参数的构造函数即可，剩下的工作交给 UserBuilder 类。 User(String var1, int var2, String var3, Address var4) &#123; this.name = var1; this.age = var2; this.phone = var3; this.address = var4; &#125; //这里之所以将方法定义为 static，是为了方便客户端通过 User.builder() 的调用形式来生成 UserBuilder 对象。 public static User.UserBuilder builder() &#123; return new User.UserBuilder(); &#125; public static class UserBuilder &#123; private String name; private int age; private String phone; private Address address; UserBuilder() &#123; &#125; //通过链式调用避免了 User 中繁杂的构造函数 public User.UserBuilder name(String var1) &#123; this.name = var1; return this; &#125; public User.UserBuilder age(int var1) &#123; this.age = var1; return this; &#125; public User.UserBuilder phone(String var1) &#123; this.phone = var1; return this; &#125; public User.UserBuilder address(Address var1) &#123; this.address = var1; return this; &#125; //最后通过 build 方法构建出指定的 User 对象，然后返回给客户端。 public User build() &#123; return new User(this.name, this.age, this.phone, this.address); &#125; public String toString() &#123; return \"User.UserBuilder(name=\" + this.name + \", age=\" + this.age + \", phone=\" + this.phone + \", address=\" + this.address + \")\"; &#125; &#125;&#125; 而客户端只需要一行代码就可以生成任意入参的 User 对象，十分方便。 1User user = User.builder().name(\"小明\").age(13).build(); 总结 Builder 模式可以避免繁杂的构造函数。 Builder 模式可以简洁客户端的代码。 代码github 地址 引用 The builder pattern in practice","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.netlify.com/categories/设计模式/"}],"tags":[{"name":"Builder","slug":"Builder","permalink":"//huminxi.netlify.com/tags/Builder/"},{"name":"建造模式","slug":"建造模式","permalink":"//huminxi.netlify.com/tags/建造模式/"}]},{"title":"怎么在命令行编译和执行 Java 程序","slug":"怎么在命令行编译和执行 Java 程序","date":"2018-12-18T10:18:32.000Z","updated":"2018-12-18T10:18:32.000Z","comments":true,"path":"2018/12/18/怎么在命令行编译和执行 Java 程序/","link":"","permalink":"//huminxi.netlify.com/2018/12/18/怎么在命令行编译和执行 Java 程序/","excerpt":"今天本来是在学习 Builder 模式，联想到之前使用过的 lombok 工具包，其中有一个 @Builder 注解，于是就想看看 lombok 是怎么实现 Builder 模式的。尴尬的是，由于一直以来都依赖 IDE，以至于忘了怎么在命令行编译和执行 Java 程序。最后去看了 javac、java 命令的文档才把这个问题弄明白，不由得发出『久在樊笼里，复得返自然』的感慨。","text":"今天本来是在学习 Builder 模式，联想到之前使用过的 lombok 工具包，其中有一个 @Builder 注解，于是就想看看 lombok 是怎么实现 Builder 模式的。尴尬的是，由于一直以来都依赖 IDE，以至于忘了怎么在命令行编译和执行 Java 程序。最后去看了 javac、java 命令的文档才把这个问题弄明白，不由得发出『久在樊笼里，复得返自然』的感慨。 项目结构假设我们的项目的目录结构如下 bin 开始是一个空目录，用来保存编译生成的 .class 文件。 lib 包含项目引用到的第三方 jar 包。 src 项目源码。 编译大家知道，想要运行一个 Java 程序，首先需要将 .java 源文件编译成 JVM 能识别的 .class 文件。这里我们可以使用由 JDK 提供的 javac 命令。 直接在命令行敲出 javac 或 javac -help ，系统就会给出相关的提示。 项目代码结构 在命令行执行如下代码即可编译该项目 1javac -d bin -cp lib/lombok.jar src/com/user/*.java src/com/application/Main.java -d 指定编译后的 .class 文件所存放的目录。这里指定为 bin 目录。 -cp 指定编译时用户的 classpath，会覆盖用户之前在环境变量 CLASSPATH 中配置的路径。如果既没有指定 classpath，也没有配置 CLASSPATH，则默认为当前目录。这里指定为存放 jar 包的 lib 目录。 src/com/user/*.java src/com/application/Main.java 指定待编译的源码目录。 最终编译生成如下的 .class 文件结果如下。 运行运行 Java 程序需要用到 java 命令。而且指定的类或 jar 包需要包含如下所示的 Main 方法。1public static void main(String args[]) &#123;...&#125; 在命令行执行如下代码即可运行该项目1java -cp bin com.application.Main -cp bin 指定存放 .class 文件的 bin 目录为用户的 classpath。 com.application.Main 指定类的全称。注意不要带 .java 后缀。 运行结果如下 代码github 地址 引用 How to Compile and Run Java Code from a Command Line javac java","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"Java","slug":"Java","permalink":"//huminxi.netlify.com/tags/Java/"},{"name":"命令行","slug":"命令行","permalink":"//huminxi.netlify.com/tags/命令行/"}]},{"title":"Adapter","slug":"Adapter","date":"2018-12-10T08:24:54.000Z","updated":"2018-12-24T08:38:33.016Z","comments":true,"path":"2018/12/10/Adapter/","link":"","permalink":"//huminxi.netlify.com/2018/12/10/Adapter/","excerpt":"如果想让额定工作电压是直流 12 伏特的笔记本电脑在交流 220 伏特的 AC(Alternating Current) 电源下工作，应该怎么做呢？通常，我们会使用 AC 适配器，将家庭用的交流 220 伏特电压转换成我们所需要的直流 12 伏特电压。这就是适配器的工作，它位于实际情况与需求之间，填补两者之间的差异。","text":"如果想让额定工作电压是直流 12 伏特的笔记本电脑在交流 220 伏特的 AC(Alternating Current) 电源下工作，应该怎么做呢？通常，我们会使用 AC 适配器，将家庭用的交流 220 伏特电压转换成我们所需要的直流 12 伏特电压。这就是适配器的工作，它位于实际情况与需求之间，填补两者之间的差异。 接口适配器 电源适配器 适配器的角色在程序世界中，经常会存在现有的程序无法直接使用，需要做适当的变换之后才能使用的情况。这种用于填补『现有的程序』和『所需的程序』之间差异的设计模式就是 Adapter 模式。在 Java 中，adapter 模式有如下两种实现。 使用继承的适配器 使用委托的适配器 示例程序电源的比喻与示例程序的关系 电源的比喻 示例程序 实际情况 交流 220 伏特 AlternateCurrent 类(use220V) 转换装置 适配器 AlternateToDirect 类 需求 直流 12 伏特 DirectCurrent 类(use12V) 实际情况不管是继承适配器还是委托适配器，实际情况都是不变的。 12345678910public class AlternateCurrent &#123; private int voltage; public AlternateCurrent(int voltage) &#123; this.voltage = voltage; &#125; public void use220V() &#123; System.out.println(\"From \" + voltage + \" V\"); &#125;&#125; Main 类123456public class Main &#123; public static void main(String[] args) &#123; DirectCurrent p = new AlternateToDirect(220); p.use12V(); &#125;&#125; 继承适配器需求是一个接口。 需求123public interface DirectCurrent &#123; public abstract void use12V();&#125; 转换装置123456789public class AlternateToDirect extends AlternateCurrent implements DirectCurrent &#123; public AlternateToDirect(int v) &#123; super(v); &#125; @Override public void use12V() &#123; use220V(); &#125;&#125; 类图继承适配器 委托适配器需求是一个类。 需求123public abstract class DirectCurrent &#123; public abstract void use12V();&#125; 转换装置1234567891011public class AlternateToDirect extends DirectCurrent &#123; private AlternateCurrent ac; public AlternateToDirect(int v) &#123; this.ac = new AlternateCurrent(v); &#125; @Override public void use12V() &#123; ac.use220V(); &#125;&#125; 类图委托适配器 总结Adapter 模式用于填补具有不同 API 的两个类之间的缝隙。 什么时候用 Adapter 模式如果某个方法就是我们所需要的方法，那么直接在程序中使用不就可以了吗，为什么还要考虑使用 Adapter 模式呢？那么，究竟应当在什么时候使用 Adapter 模式呢？ 很多时候，我们并非从零开始编程，经常会用到现有的类。 特别是当现有的类已经被充分测试过了，Bug 很少，而且已经被用于其他软件之中时，我们更愿意将这些类作为组件重复利用。 版本升级与兼容性。 软件的生命周期总是伴随着版本的升级，而在版本升级的时候经常会出现『与旧版本的兼容性问题』。如果能够完全抛弃旧版本，那么软件的维护工作将会轻松得多，但是现实中往往无法这样做。这时，可以使用 Adapter 模式使新旧版本兼容，帮助我们轻松地同时维护新版本和旧版本。 功能完全不同的类当然，当『需求』角色和『实际情况』角色的功能完全不同时，Adapter 模式是无法使用的。就如同我们无法用交流 220 伏特电压让自来水管出水一样。 拓展习题在 java.util.Properties 类中，可以像下面这样管理键值对（属性）。 123year=2018month=12day=10 java.util.Properties 类提供了以下方法，可以帮助我们方便地从流中取出属性或写入。 123456789//从 InputStream 中取出属性集合。public void load(InputStream inStream) throws IOException &#123;...&#125;//向 OutputStream 写入属性集合。header 是注释文字。public void store(OutputStream out, String header) throws IOException &#123;...&#125; 请使用 Adapter 模式编写一个将属性集合保存至文件的 FileProperties 类。 这里，我们假设在下面代码中的 FileIO 接口中声明了将属性集合保存至文件的方法，并假设 FileProperties 类会实现这个 FileIO 接口。 FileIO123456public interface FileIO &#123; public void readFromFile(String fileName) throws IOException; public void writeToFile(String fileName) throws IOException; public void setValue(String key, String value); public String getValue(String key);&#125; Main1234567891011121314151617181920/** * 实际情况=Properties * 需求=FileIO * 转换装置=FileProperties * */public class Main &#123; public static void main(String[] args) &#123; FileIO f = new FileProperties(); try &#123; f.readFromFile(\"./resource/adapter.txt\"); f.setValue(\"year\", \"2018\"); f.setValue(\"month\", \"12\"); f.setValue(\"day\", \"10\"); f.writeToFile(\"./resource/newAdapter.txt\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输入文件(adapter.txt)1year=1999 输出文件(newAdapter.txt)12345#written by FileProperties#Mon Dec 10 18:33:18 CST 2018day=10year=2018month=12 代码github 地址 引用 图解设计模式","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.netlify.com/categories/设计模式/"}],"tags":[{"name":"Adapter","slug":"Adapter","permalink":"//huminxi.netlify.com/tags/Adapter/"},{"name":"适配器模式","slug":"适配器模式","permalink":"//huminxi.netlify.com/tags/适配器模式/"}]},{"title":"Iterator","slug":"Iterator","date":"2018-12-07T06:37:50.000Z","updated":"2018-12-24T08:38:33.013Z","comments":true,"path":"2018/12/07/Iterator/","link":"","permalink":"//huminxi.netlify.com/2018/12/07/Iterator/","excerpt":"可在 容器 上遍访的接口，调用人员无需关心容器的实现细节。","text":"可在 容器 上遍访的接口，调用人员无需关心容器的实现细节。 for 和 Iterator我们可以用下面这样的 for 循环语句来遍历数组 arr 中的元素。 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; for 循环中的 i++ 的作用是让 i 的值在每次循环之后自增 1，这样就可以访问数组中的下一个元素，下下一个元素，下下下一个元素，从而实现了从头至尾遍历数组元素的功能。 将上面循环变量 i 的作用抽象化之后形成的模式，称为 Iterator 模式。下面让我们来看一段实现了 Iterator 模式的示例程序。这段程序的作用是将 Book 放置到 BookShelf 中，并将 Book 的名字按顺序打印出来。 示例程序类图iterator 的类图 AggregateAggregate 接口中只声明了一个 iterator 方法，该方法会生成一个用来遍历集合的迭代器。 123public interface Aggregate &#123; public abstract Iterator iterator();&#125; IteratorIterator 接口用于遍历集合中的元素，其作用相当于循环语句中的循环变量。 1234public interface Iterator &#123; public abstract boolean hasNext(); public abstract Object next();&#125; 在这里我们声明了两个方法，即： hasNext 方法判断下一个元素是否存在。 该方法返回值是 boolean 型的。其原因很简单，当集合中存在下一个元素时，返回 true；当集合中不存在下一个元素时，返回 false。hasNext 主要用作循环终止条件。 next 方法获取下一个元素。 该方法的返回值类型是 Object，表示该方法能返回任意类型的元素。但 next 方法的作用却不止如此。为了能在下次调用 next 方法时正确地返回下一个元素，该方法中还隐含着将迭代器移动至下一个元素的处理逻辑。 BookBook 是表示书的类。这个类的作用有限，只有通过 getName 方法获取书名这一个作用。12345678910public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; BookShelfBookShelf 是表示书架的类。由于需要将该类作为集合处理，所以它实现了 Aggregate 接口。因此，它 @Override 接口中的 iterator 方法。 12345678910111213141516171819202122public class BookShelf implements Aggregate &#123; private Book[] books; private int last = 0; public BookShelf(int initialSize) &#123; this.books = new Book[initialSize]; &#125; public Book getBookAt(int index) &#123; return (Book) books[index]; &#125; public void appendBook(Book book) &#123; books[last] = book; last++; &#125; public int getLength() &#123; return last; &#125; @Override public Iterator iterator() &#123; return new BookShelfIterator(this); &#125;&#125; 这个书架中定义了 books 字段，它是 Book 类型的数组。该数组的大小(initialSize)在生成 BookShelf 实例的时候就被指定了。 之所以将 books 字段的可见性设置为 private，是为了防止外部不小心改变了该字段的值。 BookShelfIterator因为 BookShelfIterator 类需要发挥 Iterator 的作用，所以它实现了 Iterator 接口。 12345678910111213141516171819public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; return index &lt; bookShelf.getLength(); &#125; @Override public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; bookShelf 字段表示迭代器将要遍历的书架。index 字段表示迭代器当前所指向的书的下标。 构造函数会将传入的 BookShelf 实例保存在 bookShelf 字段中，并将 index 初始化为 0。 hasNext 方法是 Iterator 接口中声明的方法。该方法会判断书架中还有没有下一本书，如果有就返回 true，如果没有就返回 false。而要知道书架中有没有下一本书，可以通过比较 index 和书架中书的总册数(bookShelf.getLength() 的返回值)来判断。 next 方法会返回迭代器当前所指向的书(Book 的实例)，并让迭代器指向下一本书。如果与前面的 for 循环相比，这里的 index++ 的相当于其中的 i++，它让循环变量指向下一个元素。 Main至此，遍历书架的准备工作就完成了。接下来我们利用 Main 类来制作一个小书架。12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; BookShelf bookShelf = new BookShelf(4); bookShelf.appendBook(new Book(\"Around the World in 80 Days\")); bookShelf.appendBook(new Book(\"Bible\")); bookShelf.appendBook(new Book(\"Cinderella\")); bookShelf.appendBook(new Book(\"Daddy Long Legs\")); Iterator it = new BookShelfIterator(bookShelf); while (it.hasNext()) &#123; Book book = (Book) it.next(); System.out.println(book.getName()); &#125; &#125;&#125; 这段程序首先设计了一个能容纳 4 本书的书架，然后按照书名顺序一次向书架中放入了下面这 4 本书。 Around the World in 80 Days Bible Cinderella Daddy Long Legs 通过 bookShelf.iterator() 得到了遍历书架的 it 实例。while 的条件自然就是 it.hasNext()。只要书架上有书，while 循环就不会终止。然后，程序会通过 it.next() 一本一本地遍历书架中的书。 运行结果 总结不管实现(BookShelf)如何变化，都可以使用 Iterator为什么要引入 Iterator 这种复杂的设计模式呢？如果是数组，直接 for 循环语句进行遍历不就行了吗？为什么要在集合之外引入 Iterator 这个角色呢？一个重要的理由是，引入 Iterator 后可以将遍历与实现分离开来。请看如下代码。 1234while(it.hasNext()) &#123; Book book = (Book) it.next(); System.out.println(book.getName());&#125; 这里只使用了 Iterator 的 hasNext 方法和 next 方法，并没有调用 BookShelf 的方法。也就是说，这里的 while 循环并不依赖与 BookShelf 的实现。如果编写 BookShelf 的开发人员决定放弃用数组来管理书本，而是用 java.util.ArrayList 取而代之，会怎样呢？ 其实不管 BookShelf 如何变化，只要 BookShelf 的 iterator 方法能正确地返回 Iterator 的实例（换句话说，hasNext 和 next 方法都可以正常工作），即使不对上面的 while 循环做任何修改，代码都可以正常工作。这对于 BookShelf 的调用者来说真是太方便了。 设计模式的作用就是帮助我们编写可复用的类。 所谓『可复用』就是指将类实现为『组件』。当一个组件发生改变时，不需要对其它的组件进行修改或是只需要很小的修改即可应对。 容易弄错『下一个』在 Iterator 模式的实现中，很容易在 next 方法上出错。该方法的返回值到底是应该指向当前元素还是当前元素的下一个元素呢？更详细地讲，next 方法的名字应该是这样的——returnCurrentElementAndAdvanceToNextPosition。 也就是说，next 方法是『返回当前的元素，并指向下一个元素』。 还容易弄错『最后一个』在 Iterator 模式中，不仅容易弄错『下一个』，还容易弄错『最后一个』。hasNext 方法在返回最后一个元素前会返回 true，当返回了最后一个元素后则返回 false。 迭代器的种类多种多样在示例程序中展示的 Iterator 类只是很简单地从前向后遍历集合。其实，遍历的方法是多种多样的。 从最后开始向前遍历。 既可以从前向后遍历，也可以从后向前遍历（既有 next 方法也有 previous 方法)。 指定下标进行『跳跃式』遍历。 具体实现依照需求而定。 拓展习题在示例程序的 BookShelf 类中，当书的数量超过最初指定的书架容量时，就无法继续向书架中添加书本了。请大家不使用数组，而是用 java.util.ArrayList 修改程序，确保当书的数量超过最初指定的书架容量时也能继续向书架中添加书本。 答案github 地址 引用 图解设计模式","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.netlify.com/categories/设计模式/"}],"tags":[{"name":"Iterator","slug":"Iterator","permalink":"//huminxi.netlify.com/tags/Iterator/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"//huminxi.netlify.com/tags/迭代器模式/"}]},{"title":"直接继承 Thread 类和实现 Runnable 接口来创建线程有和异同","slug":"直接继承 Thread 类和实现 Runnable 接口来创建线程有和异同","date":"2018-11-15T13:02:14.000Z","updated":"2019-04-22T07:21:16.860Z","comments":true,"path":"2018/11/15/直接继承 Thread 类和实现 Runnable 接口来创建线程有和异同/","link":"","permalink":"//huminxi.netlify.com/2018/11/15/直接继承 Thread 类和实现 Runnable 接口来创建线程有和异同/","excerpt":"在 Java 中，常用的创建线程方式有两种，一种是继承 Thread 类；另一种是直接实现 Runnable 接口，然后 @Override 其中的 run 方法。今天我们就来探究一下这两种方式的异同点吧。","text":"在 Java 中，常用的创建线程方式有两种，一种是继承 Thread 类；另一种是直接实现 Runnable 接口，然后 @Override 其中的 run 方法。今天我们就来探究一下这两种方式的异同点吧。 Runnable 和 Thread 的关系说穿了，Thread 类就是 Java 官方给我们提供的一种 Runnable 接口的实现。 Runnable 是一个接口Runnable 源码1234public interface Runnable &#123; // Runnable 接口中只定义了一个 run 抽象方法。 public abstract void run();&#125; Thread 是一个实现了 Runnable 接口的类Thread 部分源码123456789public class Thread implements Runnable &#123; // 看 Thread 类定义可以很清楚的看到它是实现了 Runnable 接口的，而且也 @Override 了 run 方法。 @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125;&#125; 所以这两种创建线程的方式的异同就变成了继承类和实现接口之间的区别。一般来说，当 Java 开发中遇到多线程的情况，建议以实现 Runnable 接口为主，因为实现 Runnable 接口相比继承 Thread 类有如下优势： 可以避免由于 Java 的单继承特性而带来的局限； 适合多个线程去处理同一资源的情况； 举个例子下面以经典的卖票程序为例，来说明二者的区别。 继承 Thread 类实现1234567891011121314151617181920212223package com.thread;/** * 继承 Thread 类 * */public class ThreadDemo extends Thread &#123; private int ticket = 10; private String name; public ThreadDemo(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (this.ticket &gt; 0) &#123; System.out.println(name + \" 剩余票数:\" + ticket--); &#125; &#125; &#125;&#125; 测试程序123456789101112131415161718192021222324252627package com.thread;/** * 探究继承 Thread 类和实现 Runnable 接口这两种方法有什么不同的地方。 * */public class MyThread &#123; public static void main(String[] args) &#123; ThreadDemo t1 = new ThreadDemo(\"ThreadDemo 一号窗口\"); ThreadDemo t2 = new ThreadDemo(\"ThreadDemo 二号窗口\"); ThreadDemo t3 = new ThreadDemo(\"ThreadDemo 三号窗口\"); t1.start(); t2.start(); t3.start();// RunnableDemo rd = new RunnableDemo();// Thread t1 = new Thread(rd, \"RunnableDemo 一号窗口\");// Thread t2 = new Thread(rd, \"RunnableDemo 二号窗口\");// Thread t3 = new Thread(rd, \"RunnableDemo 三号窗口\");// t1.start();// t2.start();// t3.start(); &#125;&#125; 运行结果 很明显，这里虽然启用了三个线程，但三个线程各自完成了 10 次的卖票任务，并没有发挥多线程处理任务速度快的优势。下面我们看看 Runnable 接口实现。 实现 Runnable 接口实现123456789101112131415161718package com.thread;/** * 实现 Runnable 接口 * */public class RunnableDemo implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" 剩余票数:\" + ticket--); &#125; &#125; &#125;&#125; 测试程序123456789101112131415161718192021222324252627package com.thread;/** * 探究继承 Thread 类和实现 Runnable 接口这两种方法有什么不同的地方。 * */public class MyThread &#123; public static void main(String[] args) &#123;// ThreadDemo t1 = new ThreadDemo(\"ThreadDemo 一号窗口\");// ThreadDemo t2 = new ThreadDemo(\"ThreadDemo 二号窗口\");// ThreadDemo t3 = new ThreadDemo(\"ThreadDemo 三号窗口\");// t1.start();// t2.start();// t3.start(); RunnableDemo rd = new RunnableDemo(); Thread t1 = new Thread(rd, \"RunnableDemo 一号窗口\"); Thread t2 = new Thread(rd, \"RunnableDemo 二号窗口\"); Thread t3 = new Thread(rd, \"RunnableDemo 三号窗口\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果 如此，便发挥出了多线程的优势。 引用 【Java并发编程】之六：Runnable和Thread实现多线程的区别","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"//huminxi.netlify.com/tags/多线程/"},{"name":"Thread","slug":"Thread","permalink":"//huminxi.netlify.com/tags/Thread/"},{"name":"Runnable","slug":"Runnable","permalink":"//huminxi.netlify.com/tags/Runnable/"}]},{"title":"计算机概论","slug":"计算机概论","date":"2018-08-11T06:11:52.000Z","updated":"2019-04-22T07:12:20.375Z","comments":true,"path":"2018/08/11/计算机概论/","link":"","permalink":"//huminxi.netlify.com/2018/08/11/计算机概论/","excerpt":"21 世纪已经过去了 1/5，还没有接触过计算机的朋友应该很少了吧。但是，你真的了解你每天都在使用的计算机吗？计算机由哪些部件组成？内存和硬盘有什么区别？在 Windows 上能运行的软件为什么在 Mac OS 上就不能运行了？","text":"21 世纪已经过去了 1/5，还没有接触过计算机的朋友应该很少了吧。但是，你真的了解你每天都在使用的计算机吗？计算机由哪些部件组成？内存和硬盘有什么区别？在 Windows 上能运行的软件为什么在 Mac OS 上就不能运行了？ 计算机的结构计算机的定义生活中常见的如台式电脑、笔记本电脑、平板电脑、智能手机等，这些东西都是计算机。 生活中常见的计算机 这些东西有什么共性呢，它们都是『接受使用者输入的信息，经由 CPU 处理，然后产生有用的资讯』。因此，只要有输入设备(键盘)及输出设备(显示屏)，并且能将你的输入信息转换成有用资讯，就算是一部计算机了。 计算机的定义 计算机的五大硬件单元现代的大部分计算机都属于 冯·诺伊曼 结构，这是一种将程序指令存储器和数据存储器合并在一起的计算机结构。 控制单元 负责从存储单元中取出指令，并对指令进行 译码。根据指令的要求，负责向其它各部件发出控制信号，保证各部件协调一致地工作。控制器主要由寄存器、译码器、程序计数器等组成。 运算单元 运算单元又称算术逻辑单元(Arithmetic Logic Unit, ALU)。它是计算机对数据进行加工处理的部件，包括算术运算（加、减、乘、除等）和逻辑运算（与、或、非、异或、比较等）。 存储单元 存储单元是计算机存储数据的部件。计算机中的全部信息，包括原始的输入信息、经过初步加工的中间数据以及最后处理完成的有效资讯都存放在存储单元中。而且，指挥计算机运行的各种程序也都存放在存储单元中。存储单元可分为内存储器（内存）和外存储器（硬盘、U 盘等）两种。 输入单元 输入单元是给计算机输入信息的设备。它是重要的人机交互接口，负责将输入的信息转换成计算机能识别的二进制码，送入存储单元中保存。 输出单元 输出单元是输出计算机处理结果的设备。在大多数情况下，它将这些结果转换成人类可读的形式。 计算机的五大硬件单元 上面图示中的『系统单元』其实指的就是主机壳内的硬件，重点在于 CPU 与内存。特别要注意的是实线部分代表的数据传输方向，基本上数据都是流经内存再转出去的，至于数据会流进/流出内存则是由 CPU 所控制的。 而 CPU 实际要处理的数据则完全来自于内存！ 这是个很重要的概念喔！这也是为什么当你的内存不足时，系统的性能就很糟糕(这也是电脑厂商拼命宣扬自己的电脑内存空间大的原因)。 CPU 的种类其实 CPU 内部已经含有一些微指令，我们所使用的软件都要经过 CPU 内部的微指令集来完成才行。而这些指令集的设计主要分为两种设计理念，这就是目前世界上常见的两种主要 CPU 架构，分别是： 精简指令集 和 复杂指令集。 精简指令集(Reduced Instruction Set Computing, RISC) 这种 CPU 的设计中，微指令较为精简，每个指令执行的时间都很短，完成的操作也很单纯，指令的执行性能较佳；但是要做复杂的事情，就要由多个指令来完成。 复杂指令集(Complex Instruction Set Computing, CISC) 与 RISC 不同，在 CISC 的微指令集中，每个指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂，所以每条指令花费的时间较长，但每条指令可以处理的工作较为丰富。 操作系统是什么机器程序与编译程序我们知道计算机只认识 0 和 1，且计算机最重要的运算与逻辑判断都在 CPU 内执行，而 CPU 又有着自己独特的指令集。因此，当我们需要 CPU 帮忙工作时，就得要参考微指令集的内容，然后编写让 CPU 读得懂的指令码给 CPU 执行，这样就能够让 CPU 运行了。理论上这样是行的通的(纸带打孔编程)，但利用这种方式编程存在以下几个难点： 需要了解机器语言 机器只认识 0 和 1，因此你必须要学习直接写给机器看的语言。这个相当有挑战！ 需要了解所有硬件的功能函数 因为你的程序要写给机器看，你就必须要参考机器本身的功能，然后针对该功能去编写程序。例如，你要让 DVD 影片能够放映，那就得要参考 DVD 光碟机的硬件信息才行。万一你的系统有比较冷门的硬件，光是参考技术手册就可能会晕倒。 程序不具有可移植性 每个 CPU 都有独特的微指令集，同样，每个硬件都有其独特的功能函数。因此，你为 A 计算机编写的程序，理论上是没有办法在 B 计算机上面运行的。 程序不可复用 因为这样的程序必须要针对硬件功能函数来编写，如果已经开发了一个浏览器程序，想要再开发文件管理程序时，还是得重头再参考一遍硬件的功能函数来编写，每天都在挑战『硬件』。 编译器的角色 针对上述的种种问题，计算机界的前辈们想到了一种解决思路：人为什么要直接去理解计算机语言呢？我们可以设计出一种便于人类理解的语言，用它来编程，然后再通过一个编译程序，将写好的代码翻译成机器能识别的机器码就行了。如此一来，我们编写与修改程序就变得容易多了！这种语言我们称之为高级语言，常见的如 C、C++、Java、Python、Lisp 等。 操作系统如同前面提到的，在早期想要让电脑执行程序就得要参考一堆硬件功能函数，并且学习机器语言才能够编写程序。同时每次安装程序时都必须要重新改写，因为硬件与软件功能不见得都一致。那么我如果能够将所有的硬件都驱动，并且提供一个开发软件的参考接口来给工程师使用的话，那开发软件不就变的非常简单了？这就是操作系统啦！ 操作系统内核(Kernel) 操作系统(Operating System, OS)其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件。 系统调用(System Call) 既然我的硬件都是由内核管理，那么如果我想要开发软件的话，自然就得去参考这个内核的相关功能。如此一来不是从原本的参考硬件函数变成参考内核功能，换汤没换药啊！ 为了解决这个问题，操作系统通常会提供一整组的开发接口来给工程师开发软件。工程师只需要遵守该开发接口那就很容易开发软件了。 操作系统角色 应用程序应用程序是参考操作系统提供的开发接口所开发出来的软件，这些软件会利用计算机的一些硬件功能，来达到用户的目的。 举例来说，Office 软件主要是用来让用户办公用的；影像处理软件主要是让用户用来处理影音资料的；浏览器软件主要是让用户用来上网浏览网页用的等等。 需要注意的是，应用程序是与操作系统有关系的，参照上图。因此，如果你想要购买新的软件，请务必查看软件上面的说明，看看该软件是否能够支持你的操作系统。 举例来说，如果你想要购买线上游戏光碟，务必参考一下该光碟是否支持你的操作系统，例如是否支持 Windows XP/Windows 98/Mac/Linux 等等。不要购买了之后才发现该软件无法安装在你的操作系统上！ 引用 《鸟哥的 Linux 私房菜》 精简指令集 精简指令集和复杂指令集的区别 编程语言的世界：被历史埋没的先驱 译码器 冯·诺伊曼结构 哈佛架构","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"//huminxi.netlify.com/tags/计算机/"},{"name":"概论","slug":"概论","permalink":"//huminxi.netlify.com/tags/概论/"}]},{"title":"Web 页面的请求历程","slug":"Web 页面的请求历程","date":"2018-07-03T10:58:25.000Z","updated":"2018-12-18T10:29:08.072Z","comments":true,"path":"2018/07/03/Web 页面的请求历程/","link":"","permalink":"//huminxi.netlify.com/2018/07/03/Web 页面的请求历程/","excerpt":"大家回顾一下每天的上网流程。第一步 打开 Web 浏览器。第二步 在地址栏键入一个 URL 地址(如 www.google.com)。第三步 等待谷歌的 Web 服务器给你返回一个 HTML 页面。如下图所示。\n\n为了满足这个看起来简单的请求，背后隐藏了许多细节。今天，我们就来聊一聊这些细节吧。","text":"大家回顾一下每天的上网流程。第一步 打开 Web 浏览器。第二步 在地址栏键入一个 URL 地址(如 www.google.com)。第三步 等待谷歌的 Web 服务器给你返回一个 HTML 页面。如下图所示。 为了满足这个看起来简单的请求，背后隐藏了许多细节。今天，我们就来聊一聊这些细节吧。 举个例子学生 Bob 将他的便携机(笔记本电脑)与学校的以太网交换机相连，下载一个 Web 页面（比如说 www.google.com 主页）。 图 5-32 Web 页面请求的网络环境和动作 准备: DHCP、UDP、IP 和以太网我们假定 Bob 启动他的便携机，然后将其用一根以太网电缆连接到学校的以太网交换机，交换机又与学校的路由器相连，如图 5-32 所示。学校的这台路由器与一个 ISP 连接，本例中 ISP 为 comcast.net。在本例中，comcast.net 为学校提供了 DNS 服务；所以，DNS 服务器驻留在 Comcast 网络中而不是学校网络中(即学校没有在局域网中设置一个默认的 DNS 服务器)。我们将假设 DHCP 服务器运行在路由器中(网关路由器通常也被设置成 DHCP 服务器)。 当 Bob 将其便携机与网络连接时，还没有 IP 地址的他不能做任何事情（例如，下载一个 Web 网页）。所以，Bob 的便携机所采取的一个网络相关的动作是运行 DHCP 协议，以从本地 DHCP 服务器获得一个 IP 地址以及其它相关信息。 (1) Bob 便携机上的操作系统生成一个 DHCP 请求消息，并将这个消息放入具有目的地端口 67 (DHCP 服务器）和源端口 68 (DHCP 客户端）的 UDP 报文段。该 UDP 报文段则被放置在一个目的 IP 地址 255.255.255.255(广播 IP 地址) 和源 IP 地址 0.0.0.0 的 IP 数据报中，因为 Bob 的便携机还没有一个 IP 地址。 (2) 包含 DHCP 请求消息的 IP 数据报则被放置在以太网帧中。该以太网帧具有目的 MAC 地址 FF:FF:FF:FF:FF:FF，该帧将广播到与交换机连接的所有设备（自然也包括 DHCP 服务器）。该帧的源 MAC 地址是 Bob 便携机的 MAC 地址 00:16:D3:23:68:8A 。 (3) 包含 DHCP 请求的广播以太网帧是第一个由 Bob 便携机发送到以太网交换机的帧。该交换机在所有的出端口广播该帧，包括连接到路由器的端口。 (4) 路由器在它的具有 MAC 地址 00:22:68:45:1F 的接口接收到该广播以太网帧，并且从该以太网帧中抽取出 IP 数据报。该数据报的广播 IP 目的地址指示了这个 IP 数据报应当由在该结点的高层协议处理，因此该数据报的有效载荷(一个 UDP 报文段)被分解，向上交付给 UDP 协议处理。DHCP 请求消息从该 UDP 报文段中抽取出来。此时，DHCP 服务器接收到 DHCP 请求报文。 (5) 我们假设运行在路由器中的 DHCP 服务器能够以 CIDR 块 68.85.2.0/24 分配 IP 地址。所以本例中，在学校内使用的所有 IP 地址都在 Comcast 的地址块中。我们假设 DHCP 服务器分配地址 68.85.2.101 给 Bob 的便携机。DHCP 服务器生成包含这个 IP 地址以及 DNS 服务器的 IP 地址(68.87.71.226)、默认网关路由器的 IP 地址(68.85.2.1)和子网块(68.85.2.0/24)的一个 DHCP ACK 消息。该 DHCP 消息被放入一个 UDP 报文段中，UDP 报文段被放入一个 IP 数据报中，IP 数据报再被放入一个以太网帧中。这个以太网帧的源 MAC 地址是路由器连到归属网络接口的 MAC 地址(00:22:6B:45:1F:1B)，目的 MAC 地址是 Bob 便携机的 MAC 地址(00:16:03:23:68:8A)。 (6) 包含 DHCP ACK 的以太网帧由路由器发送给交换机。因为交换机是自学习的，并且先前从 Bob 便携机收到(包含 DHCP 消息的)以太网帧，所以该交换机知道目的地为 00:16:D3:23:68:8A 的帧仅从通向 Bob 便携机的输出端口转发即可。 (7) Bob 便携机接收到包含 DHCP ACK 的以太网帧，从该以太网帧中抽取 IP 数据报，从 IP 数据报中抽取 UDP 报文段，从 UDP 报文段抽取 DHCP ACK 消息。Bob 的 DHCP 客户端则记录下它的 IP 地址和它的 DNS 服务器的 IP 地址。它还在其 IP 转发表中添加默认网关的地址。Bob 便携机向该默认网关发送目的地址为其子网 68.85.2.0/24 以外的所有数据报。此时，Bob 便携机已经初始化好它的网络组件，并准备开始发送 Web 网页请求。 仍在准备: DNS 和 ARP当 Bob 将 www.google.com 的 URL 键入其 Web 浏览器时，他开启了一长串事件，这将导致谷歌主页最终显示在其 Web 浏览器上。Bob 的 Web 浏览器通过生成一个 TCP socket 开始了该过程，socket 用于向 www.google.com 发送 HTTP 请求。为了生成该 socket，Bob 便携机将需要知道 www.google.com 的 IP 地址。我们在先前的博客 《DNS》 中学到，DNS 协议提供这种从域名到 IP 地址的转换服务。 (8) Bob 便携机上的操作系统因此生成一个 DNS 查询消息，将字符串 www.google.com 放入该查询消息中。该 DNS 消息则放置在一个具有 53 (DNS 服务器)目的端口的 UDP 报文段中。该 UDP 报文段则被放入具有 IP 目的地址 68.87.71.226(第 (5) 步中 DHCP ACK 返回了 DNS 服务器地址)和源 IP 地址 68.85.2.101 的 IP 数据报中。 (9) Bob 便携机将包含 DNS 查询消息的数据报放入一个以太网帧中，该帧将在链路层寻址到学校网络中的网关路由器。然而，即使 Bob 便携机经过上述第 (5) 步中的 DHCP ACK 消息知道了学校网关路由器的 IP 地址(68.85.2.1)，但仍不知道该网关路由器的 MAC 地址。为了获得该网关路由器的 MAC 地址，Bob 便携机需要使用 ARP 协议。 (10) Bob 便携机生成一个具有目的 IP 地址 68.85.2.1 的 ARP 查询消息，将该 ARP 消息放置在一个具有广播目的地址(FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器。 (11) 网关路由器在通往学校网络的接口上接收到包含该 ARP 查询消息的帧，发现 ARP 消息中目标 IP 地址 68.85.2.1 就是关联该接口的 IP 地址。网关路由器因此准备一个 ARP 回答，指示它的 MAC 地址 00:22:68:45:1F:1B 对应着 IP 地址 68.85.2.1。它将 ARP 回答放在一个以太网帧中，其目的地址为 00:16:D3:23:68:8A(Bob 便携机)，并向交换机发送该帧，再由交换机将帧交付给 Bob 便携机。 (12) Bob 便携机接收包含 ARP 回答消息的帧，并从 ARP 回答消息中抽取网关路由器的 MAC 地址。 (13) Bob 便携机现在(终于！)能够使包含 DNS 查询的以太网帧寻址到网关路由器的 MAC 地址。注意，在该帧中的 IP 数据报的 IP 目的地址为 68.87.71.226(DNS 服务器)，MAC 目的地址为 00:22:6B:45:1F:1B(网关路由器)。Bob 便携机向交换机发送该帧，交换机将该帧交付给网关路由器。 仍在准备: 域内路由选择到 DNS 服务器 (14) 网关路由器接收该帧并抽取包含 DNS 查询的 IP 数据报。路由器查找该数据报的目的地址(68.87.71.226)。并根据其转发表决定该数据报应当发送到 图 5-32 的 Comcast 网络中最左边的路由器。将 IP 数据报封装进以太网帧，并在适合连接学校路由器和最左边的 Comcast 路由器的链路中发送。 (15) 在 Comcast 网络中最左边的路由器接收到该帧，抽取 IP 数据报，检查该数据报的目的地址(68.87.71.226)，并根据其转发表确定输出接口，经过该接口朝着 DNS 服务器转发数据报，而转发表已根据 Comcast 的 域内协议 以及因特网的域间协议 BGP 所填写。 (16) 最终包含 DNS 查询的 IP 数据报到达了 DNS 服务器。DNS 服务器抽取出 DNS 查询消息，在它的 DNS 数据库中查找域名 www.google.com 。找到包含对应 www.google.com 的 IP 地址(64.233.169.105)的 DNS 记录，(假设它缓存在 DNS 服务器中)《DNS》 中讲过这种缓存数据源于 google.com 的权威 DNS 服务器。该 DNS 服务器形成了一个包含这种主机名到 IP 地址映射的 DNS 回答消息，将该 DNS 回答消息放入 UDP 报文段中，该报文段放入寻址到 Bob 便携机(68.85.2.101)的 IP 数据报中。该数据报将通过 Comcast 网络转发到学校路由器，再经以太网交换机转发到 Bob 便携机。 (17) Bob 便携机从 DNS 消息抽取出服务器 www.google.com 的 IP 地址。最终，在大量工作后，Bob 便携机此时准备接触 www.google.com 服务器！ Web 客户端－服务器交互: TCP 和 HTTP (18) 既然 Bob 便携机有了 www.google.com 的 IP 地址，它现在能生成 TCP socket，该 socket 将用于向 www.google.com 发送 HTTP GET 消息。当 Bob 生成 TCP socket 时，在 Bob 便携机中的 TCP 必须先与 www.google.com 中的 TCP 执行三次握手。Bob 便携机因此需要生成一个具有目的端口 80(针对 HTTP 协议)的 TCP SYN 报文段，将该 TCP 报文段放置在具有目的 IP 地址 64.233.169.105(www.google.com)的 IP 数据报中，将该数据报放置在 MAC 地址为 00:22:6B:45:1F:1B(网关路由器)的帧中，并向交换机发送该帧。 (19) 在学校网络、Comcast 网络和谷歌网络中的路由器朝着 www.google.com 转发包含 TCP SYN 的数据报(根据每台路由器中的转发表进行转发)。 (20) 最终，包含 TCP SYN 的数据报到达 www.google.com 。从数据报抽取出 TCP SYN 报文段并分解到与端口 80 相关联的 welcome socket，并对谷歌 HTTP 服务器和 Bob 便携机之间的 TCP 连接生成一个 connection socket。产生一个 TCP SYN ACK 报文段，将其放入向 Bob 便携机寻址的一个数据报中。 (21) 包含 TCP SYN ACK 报文段的数据报通过谷歌、Comcast 和学校网络，最终到达 Bob 便携机的以太网卡。数据报在操作系统中分解到步骤 (18) 生成的 TCP socket，从而进入连接状态。 (22) 借助于 Bob 便携机上的 socket，现在准备向 www.google.com 发送字节了，Bob 的浏览器生成包含要获取的 URL 的 HTTP GET 消息。HTTP GET 消息将被写入 socket，GET 消息成为一个 TCP 报文段的有效载荷。同时该 TCP 报文段将被放置进一个数据报中，并交付到 www.google.com 。如前面步骤 (18) - (20) 所述。 (23) 在 www.google.com 的 HTTP 服务器从 TCP socket 读取 HTTP GET 消息，并创建一个 HTTP response，进而将 GET 消息请求的 Web 页面内容放入 HTTP response 中，再将 HTTP response 发送进 TCP socket 中。 (24) 包含 HTTP response 的数据报通过谷歌、Comcast 和学校网络转发，到达 Bob 便携机。Bob 的 Web 浏览器程序从 socket 读取 HTTP response， 从 HTTP response 中抽取 Web 网页的 HTML，并终于显示了 Web 网页。 上面的场景已经涉及许多网络基础！如果你已经理解上面步骤中的大多数或全部，那么恭喜你——你也已经涵盖了许多基础知识。 引用 《计算机网络:自定向下方法》 CIDR TCP/UDP端口列表","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"Web","slug":"Web","permalink":"//huminxi.netlify.com/tags/Web/"},{"name":"页面请求","slug":"页面请求","permalink":"//huminxi.netlify.com/tags/页面请求/"}]},{"title":"Linear Regression","slug":"Linear Regression","date":"2018-06-10T08:27:51.000Z","updated":"2019-04-22T07:19:17.659Z","comments":true,"path":"2018/06/10/Linear Regression/","link":"","permalink":"//huminxi.netlify.com/2018/06/10/Linear Regression/","excerpt":"\n\n\n事情的发生是有规律性的，这样我们才能预测天气、发射火箭、制造原子弹、将来甚至进行星际旅行。那么这些规律又是如何发现的呢？以前靠人，例如牛顿、爱因斯坦。那么以后会不会由机器来发掘呢？","text":"事情的发生是有规律性的，这样我们才能预测天气、发射火箭、制造原子弹、将来甚至进行星际旅行。那么这些规律又是如何发现的呢？以前靠人，例如牛顿、爱因斯坦。那么以后会不会由机器来发掘呢？ Linear Regression场景1 假设你是房地产销售人员，而且你手里有一些已经有一些已经成功售出的历史数据，如 表 1-1 所示。你想根据房屋面积来预测房子的售价，这个时候你应该怎么办？ 表 1-1 历史数据 房屋面积(m²) 售价(万) 42 88 55 108 64 130 75 158 82 180 90 192 108 210 123 258 图 1-1 数据分布图 假想函数观察数据分布图，我们容易发现它很像初中就接触过的线性函数——y=ax+b。这里我们就假设售价与房屋面积的关系为线性函数。即 假想函数(Hypothesis Function) 是 $$ h(x) = θ_0+θ_1x $$ 有了假想函数，下一步需要做的事情就是确定假想函数中的各个参数的值，或者叫特征值(Features)，这里我们有 \\( θ_0 , θ_1 \\) 这两个特征值。 我们分别做如下假设，图 1-2 中表示了各个假想函数的拟合结果: \\(θ_0=150,θ_1=0 \\)，得到 假想函数 \\( h(x) = 150 \\) \\(θ_0=0,θ_1=1 \\)，得到 假想函数 \\( h(x) = x \\) \\(θ_0=0,θ_1=2 \\)，得到 假想函数 \\( h(x) = 2x \\) 图 1-2 各个假想函数的拟合结果 代价函数从 图 1-2 中我们很明显的可以看到，\\( θ_0=0,θ_1=2 \\) 时拟合的结果最好。 提问1 除了用经验来判断拟合结果的好坏，有没有能量化比较的方法呢? 答案是肯定的，这就是代价函数(Cost Function)。 $$J(θ_0,θ_1) = \\frac 1 {2m} \\sum_{i=0}^{m} (h_θ(x_i)-y_i)^2 $$ 1注:有的公式符号前面需要加转义字符 \\，例如 _，应该写成 \\_ \\( (h_θ(x_i)-y_i)^2 \\)。表示假想函数求出来的值减去实际值的平方 \\( \\sum_{i=0}^{n} \\)。表示从 i=0 累加到 i=n 随着 \\( θ_0,θ_1 \\) 的取值不同，代价函数 \\( J(θ_0,θ_1) \\) 的结果值如 图 1-3 所示 图 1-3 代价函数的结果 代价函数表示的是假想函数的拟合程度，代价函数求出来的值越小，说明拟合的越成功。现在的问题已经变成了如何求代价函数的最小值。 梯度下降梯度下降(Gradient Descent)定义如下: $$ θ_j=θ_j-α \\frac δ {δθ_j} J(θ_0,θ_1) $$ 图 1-4 梯度下降的几何含义 需要注意的是:在每次迭代中，应该同时更新参数。在这里需要同时更新 \\( θ_0,θ_1\\) \\( temp0:=θ_0-α \\frac δ {δθ_0} J(θ_0,θ_1) \\) \\( temp1:=θ_1-α \\frac δ {δθ_0} J(θ_0,θ_1) \\) \\( θ_0=temp0 \\) \\( θ_1=temp1 \\) 图 1-5 α 取值的影响 实际操作中，我们需要及时调整参数 α，以确保梯度下降算法在合理的时间内收敛。未能收敛或取得最小值的时间太多意味着我们的步长是错误的。 octave 代码实现图 1-6 J(θ)求偏导 执行结果如下: X-y-theta iterator-result Cost Function1234567891011121314151617181920212223242526function J = computeCost(X, y, theta)%COMPUTECOST Compute cost for linear regression% J = COMPUTECOST(X, y, theta) computes the cost of using theta as the% parameter for linear regression to fit the data points in X and y% Initialize some useful valuesm = length(y); % number of training examples% You need to return the following variables correctlyJ = 0;% ====================== YOUR CODE HERE ======================% Instructions: Compute the cost of a particular choice of theta% You should set J to the cost.m = size(X,1);predictions = X*theta;sqrErrors = (predictions-y).^2;J = 1/(2*m)*sum(sqrErrors);% =========================================================================end Gradient Descent12345678910111213141516171819202122232425262728293031323334353637function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)%GRADIENTDESCENT Performs gradient descent to learn theta% theta = GRADIENTDESCENT(X, y, theta, alpha, num_iters) updates theta by% taking num_iters gradient steps with learning rate alpha% Initialize some useful valuesm = length(y); % number of training examplesJ_history = zeros(num_iters, 1);for iter = 1:num_iters % ====================== YOUR CODE HERE ====================== % Instructions: Perform a single gradient step on the parameter vector % theta. % % Hint: While debugging, it can be useful to print out the values % of the cost function (computeCost) and gradient here. % x1 = X(:,2); h = theta(1) + (theta(2)*x1); theta_zero = theta(1) - alpha * (1/m) * sum(h-y); theta_one = theta(2) - alpha * (1/m) * sum((h-y) .* x1); theta = [theta_zero; theta_one]; % ============================================================ % Save the cost J in every iteration J_history(iter) = computeCost(X, y, theta); disp(J_history(iter));end disp(min(J_history));end 引用 machine-learning 机器学习-线性回归算法 偏导数的几何意义","raw":null,"content":null,"categories":[{"name":"数学","slug":"数学","permalink":"//huminxi.netlify.com/categories/数学/"}],"tags":[{"name":"linear regression","slug":"linear-regression","permalink":"//huminxi.netlify.com/tags/linear-regression/"},{"name":"线性回归","slug":"线性回归","permalink":"//huminxi.netlify.com/tags/线性回归/"}]},{"title":"IPv4 和 IPv6","slug":"IPv4 和 IPv6","date":"2018-06-03T04:35:42.000Z","updated":"2019-03-28T02:35:36.604Z","comments":true,"path":"2018/06/03/IPv4 和 IPv6/","link":"","permalink":"//huminxi.netlify.com/2018/06/03/IPv4 和 IPv6/","excerpt":"相信接触过网络编程的人都会听到这样一种说法：IPv4 的地址马上就不够用了，大家快去使用 IPv6 吧，因为它的地址有 2¹²⁸ 个，不会面临 IP 地址短缺的情况。真的就这么简单吗？","text":"相信接触过网络编程的人都会听到这样一种说法：IPv4 的地址马上就不够用了，大家快去使用 IPv6 吧，因为它的地址有 2¹²⁸ 个，不会面临 IP 地址短缺的情况。真的就这么简单吗？ IP 协议简介现行的网络层 IP 协议存在两个版本，IPv4(Internet Protocol version 4)和 IPv6。IPv4 是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4 是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为 IPv6，直到 2011 年，IANA IPv4 地址完全用尽时，IPv6 仍处在部署的初期。 IPv6 的设计目的是取代 IPv4，然而长期以来 IPv4 在互联网流量中仍占据主要地位，IPv6 的使用增长缓慢。在 2017 年 7 月，通过 IPv6 使用 Google 服务的用户百分率首次超过 20%。 IPv4下图表示了 IPv4 数据报组成格式。 IPv4 数据报 IPv4 数据数据报中的关键字段如下: Version 版本号。这 4 bit 规定了数据报的 IP 协议版本，IPv4=0100。通过查看版本号，路由器能够确定如何解释 IP 数据报的剩余部分(不同的 IP 版本使用不同的数据报格式)。 Header length 首部长度。包括了 Options 的长度，但不包括 Data 长度。这个字段占 4 个 bit，其中每一个 bit 表示 4 个字节（units of 32 bits），这个字段最大值是 0xFFFF (15)，所以 Header 最长占 60 个字节，去掉 Header 中固定的 20 个字节，剩下有 40 个字节留给 Options。 Type of service TOS。该字段用来区分 IP 数据报的类型。例如，将实时流量（如用于 IP 电话应用）与非实时流量（如 FTP)区分开。 Datagram length(bytes) 数据报长度。这是 IP 数据报的总长度（Header+Data），以字节计。因为该字段长为 16 bit，所以 IP 数据报的理论最大长度为 65535 字节。然而，数据报很少有超过 1500 字节的。 16-bit Identifier、Flags、13-bit Fragmentation offset 标识、标志、片偏移。这三个字段与 IP 分组分片有关。有趣的是，新版本的 IPv6 不允许在路由器上对分组分片。 Time-to-live TTL。该字段用来确保数据报不会永远（如路由选择存在环路时）在网络中循环。每当数据报由一台路由器处理时，该字段的值减 1。若 TTL 字段减为 0，则该数据报必须丢弃。 Upper-layer protocol 上层协议。该字段仅在 IP 数据报到达其最终目的地才会有用。该字段值指示了 IP 数据报的数据部分应交给哪个特定的运输层协议。例如，值为 6 表明数据部分要交给 TCP，而值为 17 表明数据要交给 UDP，详细参见 Protocol Numbers。值得注意的是——协议号在 IP 数据报中所起的作用，类似于端口号字段在运输层报文段中所起的作用。协议号是将网络层与运输层绑定到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。 Header checksum 首部校验和。首部检验和用于帮助路由器检测收到的 IP 数据报中的比特差错。首部校验和的计算可以参考 《比特差错检测和纠正技术》这篇博客。路由器要对每个收到的 IP 数据报计算其首部检验和，如果数据报首部中携带的检验和与计算得到的检验和不一致，则检测出比特差错。路由器一般会丢弃检测出错误的数据报。注意到在每台路由器上必须重新计算检验和并再次放到原处，因为 TTL 字段以及 Options(if any) 字段会改变。 32-bit Source/Destination IP address 源和目的 IP 地址。源主机可以通过 DNS 解析来查找目的地址。 Options(if any) 选项。选项字段允许 IP 首部被扩展。然而，选项的存在的确是件复杂的事，因为数据报头长度可变，故不能预先确定数据字段从何处开始。而且还因为有些数据报要求处理选项，而有些数据报则不要求，故导致一台路由器处理一个 IP 数据报所需的时间变化很大。这些考虑对于高性能路由器和主机上的 IP 处理来说特别重要。由于这样或那样的原因，在 IPv6 首部中已去掉了该字段。 Data 有效载荷。这是最后的也是最重要的字段，这是数据报存在的首要理由！在大多数情况下 IP 数据报中的数据字段包含要交付给目的地的运输层报文段(TCP 或 UDP)。然而，该数据字段也可承载其他类型的数据，如 ICMP 报文。 注意到一个 IP 数据报有总长为 20 字节的首部（假设无选项）。 IPv6下图表示了 IPv6 数据报组成格式。 IPv6 数据报 IPv6 数据数据报中的关键字段如下: Version 版本号。IPv6=0110。 Traffic class 流量类型。该 8 bit 字段与我们在 IPv4 中看到的 TOS 字段的含义相似。 Flow label 流标签。它被用来提醒路由器来重复使用之前的接力路径。这样 IP 包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。Flow label 的进一步使用还在开发中。 Payload length 有效载荷长度。该 16 bit 值作为一个无符号整数，给出了 IPv6 数据报中 Data 部分的长度。 Next header 下一个首部。该字段标识数据报中的数据字段需要交付给哪个协议（如 TCP 或 UDP)。该字段使用与 IPv4 首部中 Upper-layer protocol 字段相同的值。 Hop limit 跳限制。转发数据报的每台路由器将对该字段的内容减 1。如果跳限制计数到达 0 时，则该数据报将被丢弃。 Source/Destination address 源和目的地址。 Data 有效载荷。 注意到一个 IP 数据报有定长为 40 字节的首部。 对比下面是 IPv4 与 IPv6 数据报首部字段对比图。 IPv4 与 IPv6 首部字段对比图 引用 《计算机网络:自定向下方法》 IPv4 header checksum IPv4 Protocol Numbers IPv4 与 IPv6 头部的对比 IPv4 header 分析","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"IPv4","slug":"IPv4","permalink":"//huminxi.netlify.com/tags/IPv4/"},{"name":"IPv6","slug":"IPv6","permalink":"//huminxi.netlify.com/tags/IPv6/"},{"name":"Datagram","slug":"Datagram","permalink":"//huminxi.netlify.com/tags/Datagram/"}]},{"title":"比特差错检测和纠正技术","slug":"比特差错检测和纠正技术","date":"2018-05-19T02:41:14.000Z","updated":"2018-12-18T10:29:08.083Z","comments":true,"path":"2018/05/19/比特差错检测和纠正技术/","link":"","permalink":"//huminxi.netlify.com/2018/05/19/比特差错检测和纠正技术/","excerpt":"数据在链路层传输时，比特差错是一个无法忽视的问题。那么，当比特差错发生了之后我们如何检测和纠正比特差错呢？本文主要给大家介绍检测比特差错的基本思想和三种具体的实现技术，它们分别是：奇偶校验(用来描述差错检测和纠正背后的基本思想)、校验和(应用于运输层)、循环冗余检测(应用于链路层)。","text":"数据在链路层传输时，比特差错是一个无法忽视的问题。那么，当比特差错发生了之后我们如何检测和纠正比特差错呢？本文主要给大家介绍检测比特差错的基本思想和三种具体的实现技术，它们分别是：奇偶校验(用来描述差错检测和纠正背后的基本思想)、校验和(应用于运输层)、循环冗余检测(应用于链路层)。 如何发现比特差错图 5-3 说明了我们研究的场景。左侧的发送结点，为了保护比特免受差错，使用差错检测和纠正比特(Error-Detection and-Correction, EDC)来增强数据 D。通常，要保护的数据不仅包括从网络层传递下来的数据报(Datagram)，而且包括链路帧(Frame)首部中的 MAC 地址信息、以太类型和其他字段。链路级帧中的 D 和 EDC 都被发送到接收结点。右侧的接收结点，接收到比特序列 D’和 EDC’。值得注意的是，由于传输中可能会发生比特翻转(由 0 变成 1 或 由 1 变成 0)，所以 D’ 和 EDC’ 可能与初始的 D 和 EDC 不同。 图 5-3 错误检测与纠正场景 接收方的挑战是在它只收到 D’ 和 EDC’ 的情况下，确定 D’ 是否和初始的 D 相同。在 图 5-3 中的接收方判定的准确措词应该是——我们是否检测到一个差错，而非是否出现了差错！差错检测和纠正技术使接收方有时但并非总是检测出已经出现的比特差错。即使采用差错检测比特，也还是可能有未检出的比特差错(undetected bit error)。也就是说，接收方可能无法知道接收的信息中包含着比特差错。因此，接收方可能向网络层交付一个损伤的数据报，或者不知道该帧首部的某个其他字段的内容已经损伤。 因此，我们要选择一个差错检测方案，使得这种事件发生的概率很小。一般而言，差错检测和纠错技术越复杂，概率就越小，但同时导致的开销就越大，这就意味着需要更多的计算及更多的差错检测和纠正比特。 奇偶校验(Parity Checks)检测也许差错检测最简单的方式就是用单个奇偶校验位(parity bit)。假设在 图 5-4 中要发送的信息 D 有 d 个比特。在偶校验方案中，发送方只需要包含一个附加的比特，选择它的值，使得这 d+1 个比特中有偶数个 1。对于奇校验方案，选择校验比特值使得有奇数个 1。 图 5-4 描述了一个偶校验的方案，单个校验比特被存放在一个单独的字段中。 图 5-4 一比特位的偶校验 采用单个奇偶校验位方式，接收方的操作也很简单。接收方只需要数一数接收的 d+1 比特中 1 的数目即可。如果在采用偶校验方案中发现了奇数个值为 1 的比特，接收方知道至少出现了一个比特差错。更精确的说法是，出现了奇数个比特差错。 未检测出的比特差错如果出现了偶数个比特差错，那会发生什么现象呢？你应该意识到这将导致一个未检出的差错。如果比特差错的概率小，而且比特之间的差错可以被看作是独立发生的，在一个分组中多个比特同时出错的概率将是极小的。在这种情况下，单个奇偶校验位可能是足够了。但是，现实场景中差错经常以『突发』方式聚集在一起，而不是独立的发生。在突发差错的情况下，使用单比特奇偶校验保护的一帧中未检测出差错的概率是 50%。显然，我们需要一个更加健壮的差错检测方案。 纠错那么在检测出存在比特差错之后应该如何纠错呢？我们以单比特奇偶校验方案为例，这将使我们深入地理解纠错技术。图 5-5 显示了单比特奇偶校验方案的二维实现。这里 D 中的 d 个比特被划分为 i 行 j 列。对每行和每列计算奇偶值。产生的 i+j+1 奇偶比特构成了链路层帧的差错检测比特。 图 5-5 二维偶校验 现在假设在初始 d 比特信息中出现了单个比特差错。使用这种二维奇偶校验(two-dimensional parity)方案，包含比特值改变的行和列的校验值都会出现差错。因此接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用行和列的索引来定位出现差错的比特并纠正它! 接收方检测和纠正差错的能力被称为前向纠错(Forward Error Correction, FEC)。这些技术通常用于如音频 CD 这样的音频存储和回放设备中。FEC 技术很有价值，因为它们可以减少发送方重发的次数。更为重要的是，它们允许在接收方立即纠正差错。FEC 避免了不得不等待的往返时延，而这些时延是发送方收到 NAK 分组并向接收方重传分组时所花费的，这对于实时网络应用或者具有长传播时延的链路可能是一种非常重要的优点。 校验和方法(Checksum)因特网校验和在检验和技术中， 图 5-4 中的 d 比特数据被作为一个 k 比特整数的序列处理。一个简单检验和方法就是将这 k 比特整数加起来，并且用得到的和作为差错检测比特。因特网检验和(Internet checksum) 就基于这种方法，将每 2 字节的数据视作 16 比特的整数对待并求和。这个和的反码就是携带在报文段首部的因特网检验和。接收方通过对接收的数据（包括检验和）的和取反，并且检测其结果是否为全 0 来检测检验和。如果这些比特中有任何比特是 1，就可以指示出现差错。RFC1071 详细地讨论因特网检验和算法和它的实现。在 TCP 和 UDP 协议中， 对所有字段（包括首部和数据字段）都计算因特网检验和。 下图 IPv4 数据报的首部中就存在着一个 16 bit 的校验和字段 举个例子发送方假设一个 20 字节的 IPv4 首部数据如下(采用 16 进制)所示。加粗的为校验和字段。 4500 0073 0000 4000 4011 b861 c0a8 0001 c0a8 00c7 (1) 跳过校验和字段，我们计算首部中每个 16 位值的总和。4500 + 0073 + 0000 + 4000 + 4011 + c0a8 + 0001 + c0a8 + 00c7 = 2479c (相当于十进制的 149404) (2) 接下来，我们将值 2479c 转换为二进制：0010 0100 0111 1001 1100 (3) 前 4 位是进位，我们将其加到最低位：(0010) + (0100 0111 1001 1100) = 0100 0111 1001 1110 (4) 在这个例子中，加完进位之后不产生新的进位。如果有的话，重复第 3 步。 (5) 接下来，我们将该值中的每一位取反，以获得校验和：0100 0111 1001 1110 变为：1011 1000 0110 0001用十六进制来表示即为 b861，如前面的加粗部分所示。 接收方在验证校验和时，使用与上述相同的过程，只是原始校验和字段不被跳过。 (1) 4500 + 0073 + 0000 + 4000 + 4011 + b861 + c0a8 + 0001 + c0a8 + 00c7 = 2fffd (2) 加上进位：fffd + 2 = ffff (3) 翻转每一位得到 0000，这表明没有检测到错误。注意，IP 首部校验和无法检测首部内的 16 位值的正确顺序。 应用场景检验和方法需要相对小的分组开销。例如，TCP 和 UDP 中的检验和只用了 16 比特。然而，与后面要讨论的常用于链路层的 CRC 相比，它们提供相对弱的差错保护。这时，一个很自然的问题是：为什么运输层使用检验和而链路层使用 CRC 呢？前面讲过运输层通常是在主机中作为用户操作系统的一部分，通常是用软件来实现的。因为运输层差错检测用软件实现，更适合采用简单而快速(如检验和这样)的差错检测方案。在另一方面，链路层的差错检测在适配器中用专用的硬件实现，它能够快速执行更复杂的 CRC 运算。 循环冗余检测(Cyclic Redundancy Check)多项式编码现今的计算机网络中广泛应用的差错检测技术基于循环冗余检测(Cyclic Redundancy Check, CRC)编码。CRC 编码也称为多项式编码(polynomial code), 因为该编码将要发送的比特串看作是系数为 0 和 1 的一个多项式，对比特串的操作被解释为多项式运算。CRC 编码操作如下。考虑 d 比特的数据 D，发送结点要将它发送给接收结点。发送方和接收方首先必须协商一个 r+1 比特模式，称为生成多项式(generator)，我们将其表示为 G。同时规定 G 的最高有效位的比特是 1。 CRC 编码的关键思想如 图 5-6 所示。对于一个给定的数据段 D，发送方要选择 r 个附加比特 R，并将它们附加到 D 上，使得到的 d+r 比特数据（被解释为一个二进制数）用模 2 算术恰好能被 G 整除（即余数为 0）。 图 5-6 crc 接收方用 CRC 进行差错检测的过程很简单：直接用 G 去除接收到的 d+r 比特。如果余数为非零，接收方知道出现了差错；否则认为数据正确而被接收。 所有 CRC 计算采用模 2 算术来做(即在加法中不进位，在减法中不借位)。这意味着加法和减法是相同的，而且这两种操作等价于操作数的按位异或(XOR)。 举个例子图 5-7 一个例子 最终求出来的 R 将会被补充到要发送数据 D 的后面。即发送方实际要发送的是 D+R,即 101110011。 引用 《计算机网络:自定向下方法》 IPv4 header checksum 最通俗的 CRC 校验原理剖析 循环冗余校验","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"bit","slug":"bit","permalink":"//huminxi.netlify.com/tags/bit/"},{"name":"差错检测","slug":"差错检测","permalink":"//huminxi.netlify.com/tags/差错检测/"},{"name":"差错纠正","slug":"差错纠正","permalink":"//huminxi.netlify.com/tags/差错纠正/"}]},{"title":"统计学与生活","slug":"统计学与生活","date":"2018-05-04T14:52:36.000Z","updated":"2019-04-22T07:19:17.661Z","comments":true,"path":"2018/05/04/统计学与生活/","link":"","permalink":"//huminxi.netlify.com/2018/05/04/统计学与生活/","excerpt":"\n\n\n一提起统计学，大家脑海中浮现的第一印象是什么？就我而言，我第一时间想到的就是那个著名的 抛硬币 实验。最近看了一本书，叫 《赤裸裸的统计学》，在里面发现了几个有趣的小故事，想与大家分享一下。","text":"一提起统计学，大家脑海中浮现的第一印象是什么？就我而言，我第一时间想到的就是那个著名的 抛硬币 实验。最近看了一本书，叫 《赤裸裸的统计学》，在里面发现了几个有趣的小故事，想与大家分享一下。 什么是概率概率描述的是事件发生的可能性。 先来做两道判断题: 天气预报说，明天有 99% 的概率会下雨，所以明天一定下雨。对吗？ 中国的 LOL 战队在 S8 赛季有 1% 的概率会夺冠，所以中国队在 S8 赛季不可能夺冠。对吗？ 小结: 再大概率的事件也有可能不发生 再小概率的事件也有可能发生 蒙提霍尔问题Q 在上个世纪的美国，有一个电视节目叫 “Let’s Make a Deal”，由当时极受欢迎的蒙提霍尔主持。在每天节目快要结束时，胜出的选手和蒙提霍尔都会站在 3 扇大门的前面。蒙提霍尔或告诉观众和选手，在其中一扇大门的门后会有一项大奖，如一辆小轿车，而另外两扇门的后面则各站着一头山羊。玩法很简单：选手选择一扇门，然后就会得到这扇门后面的奖品。 当选手和蒙提霍尔站在这 3 扇门的前面时，这位选手中大奖的概率为 1/3。但是，这档节目却有其微妙之处。当参赛者选定了一扇门，但未去开启它的时候，知道门后情形的蒙提霍尔会开启剩下两扇门的其中一扇，露出其中一只山羊。主持人随后会问参赛者要不要更换为另一扇关着的门？ 这就是蒙提霍尔问题，如果换成是你，你又会怎么选呢？ A 答案是：当参赛者转向另一扇门而不是继续维持原先的选择时，赢得汽车的机会将会加倍! 三门问题 三门问题是多门问题里最难的情况。如果把三门变成千门，参赛者第一次就选中的概率就是 1/1000，参赛者就会清楚自己是在猜，而不是如同三门的时候 1/3 的概率认为自己是对的。这样，当主持人打开剩下 999 扇门中的 998 扇时，该如何选择，认真思考就会比三门的时候清晰很多。 施利茨啤酒广告 1981 年，美国约瑟夫·施利茨酿酒公司斥 170 万美元巨资为该公司旗下的旗舰品牌——施利茨啤酒开展了一场大胆而冒险的市场营销活动。当美国橄榄球超级杯大赛(即『超级碗』)的中场休息时间一到，施利茨公司就会当着全球亿万电视观众的面，现场直播一场别开生面的啤酒品鉴会，而挑选的对手不是别人，正是施利茨的死对头——米切罗啤酒。更让人大跌眼镜的是，参加品鉴会的不是别人，正是 100 名米切罗啤酒的忠实用户。这样的广告从始至终出现在季后赛的每一场比赛当中。类似的电视直播啤酒品鉴会总共有 5 场，每场都会邀请 100 名某品牌啤酒的『拥趸』，包括百威、米勒、米切罗等，让这些啤酒爱好者在自己最钟爱的啤酒和施利茨啤酒之间进行『盲品』。 广告噱头很明确：即使是那些自认为喜欢另一种品牌的啤酒爱好者，在盲品时也会发现自己更偏爱施利茨啤酒。啤酒公司甚至还请了一位橄榄球职业联赛的前裁判来监督整个活动过程。考虑到在数量众多的电视观众面前举办这样一场充满风险的啤酒品鉴会，你肯定会觉得施利茨啤酒的口感一定特别好，否则哪会有勇气搞这样的宣传，是吗？ 让我们假设，要让施利茨公司满意，100 位盲品者中至少要有 40 位选择施利茨啤酒。这是一个非常可观的数字，因为所有参加盲品直播的人都曾信誓旦旦地声明自己是米切罗的忠实用户。而要达到这样的效果，其实一点儿都不难。施利茨只需要保证以下两点，那么他的计谋很大概率上就能成功： 施利茨生产出的啤酒与其它品牌的啤酒在盲品时没有明显区别 每场盲品的用户数量较多 这样一来，盲品结果就如抛硬币实验的结果一样，运用概率学的基本知识，就能得出至少有 40 人选择施利茨的概率为 98%，至少有 45 人选择施利茨的概率为 86%。从理论上来看，这场电视营销活动其实并没有很大的风险。 那么这 98% 和 86% 的概率是怎么计算出来的呢？不要着急，我们接着往下看。 相关事件和独立事件我们在生活中时常会遇到随机事件。抛硬币、掷骰子、刮奖彩票等都是随机事件。你要学会区分哪些随机事件是属于独立事件，哪些随机事件是属于相关事件。 相关事件，上一个事件会影响到下一个事件 例，从布袋里不放回地拿玻璃球。每拿走一颗玻璃球，袋子里就少一颗玻璃球，概率也随之改变。 独立事件，不受过去事件的影响 例，抛硬币。硬币不知道它曾经是正面向上还是反面向上。所以每一次抛掷硬币的结果都是独立事件。 赌徒谬误我们先来看一下抛硬币的例子。抛掷一枚硬币，出现正面和反面的概率各 0.5，抛掷第 1 次，结果为正面的概率为 0.5。那么抛掷第 2 次和抛掷第 3 次，结果为正面的概率是多少呢？还是 0.5。 有些人可能想：『已经三次正面了，这一次应该轮到反面了吧』。其实不然，下一次抛掷为正面的概率依然是 0.5。 独立事件的概率两个或多个独立事件同时发生的概率是每个事件概率的乘积。 掷 1 次可能出现的结果有 2 个，正、反。因为 p=0.5，所以每个结果出现的概率是 0.5，那么正面出现 1 次、0 次的概率为 0.5、0.5。 掷 2 次可能出现的结果有 4 个，正正、正反、反正、反反。每个结果出现的概率是 0.5×0.5=0.25，那正面出现 2 次、1 次、0 次的概率分别是 0.25、0.5、0.25。 掷 3 次可能出现的结果有 8 个，正正正、正正反、正反正、正反反、反正正、反正反、反反正、反反反。每个结果出现的概率是 0.5×0.5×0.5=0.125，那正面出现 3 次、2 次、1 次、0 次的概率分别是 0.125、0.375、0.375、0.125。 但如果我们抛了 100 次硬币，这个时候又该如何计算每个结果出现的概率呢，难道要一一列举出来吗。结果的概率计算有规律吗?有的。 假设 p 是我们预期事件发生的概率(正面向上) k 是我们预期事件发生的次数(0≤k≤n) 总共进行了 n 次实验 所以，每个结果出现的概率就是 $$ p^k(1-p)^{n-k} $$ 排列与组合 排列，对选出来元素的顺序有要求 例，从 3 到 9 共计 7 个号码球，从中选三个号码球用来组成一个三位数，请问可以组成多少个三位数？百位数有 7 种可能，十位数有 (7-1) 种可能，个位数有 (7-1-1) 种可能，共计有 210=7*6*5 种排列。即 $$ A_7^3 = \\frac{7!}{(7-3)!} $$ 组合，对选出来元素的顺序无要求 例，从 3 到 9 共计 7 个号码球，从中选三个号码球用来炸金花，请问有多少种组合？假设你扎金花的时候拿到了三张牌 345，那么无论你排成 345 354 435 453 534 543，大家都会认为它是同一个顺子。所以这里计算的话需要多一个去重的步骤。共计有 35=7*6*5/3*2*1 种组合。即 $$ C_7^3 = \\frac{7!}{(7-3)!3!} $$ 二项分布什么是二项分布 每次试验是独立事件 每次试验只有两个可能的结果 每次试验中成功的概率是不变的 二项分布的概率计算公式 $$P(n取k)=\\frac{n!}{(n-k)!k!}p^k(1-p)^{n-k}$$ 举个例子 求抛掷 3 次硬币时，只有两个正面向上的硬币的概率为多大？ 将 n=3，p=0.5，k=2，带入得到每个结果的发生的概率为 $$p=0.5^2(1-0.5)^{3-2}=0.125$$ 那么该结果出现的次数是 $$ C_3^2=\\frac{3!}{(3-2)!2!}=3$$ 所以，P(3取2)=3×0.125=0.375 再回到我们的施利茨啤酒广告，$$P(至少要有40位选择施利茨啤酒)=P(40)+P(41)+…+P(100)\\approx 0.982$$ $$P(至少要有45位选择施利茨啤酒)=P(45)+P(41)+…+P(100)\\approx 0.864$$ P(x&gt;=40) P(x&gt;=45) 生活中还有哪些与统计学相关的有趣故事呢？欢迎大家在下方留言。 附 计算 P(x) 的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package statistics;import java.math.BigDecimal;/** * 二项分布 * &lt;p&gt; * 这里计算的是 p=0.5 的情况。 */public class BinomialDistribution &#123; /** * 在 n 次实验中，预期的结果次数 = x 次的概率 * * @param n * @param x * @return */ public static BigDecimal equals(int n, int x) &#123; //n! BigDecimal nFactorial = new BigDecimal(1); //(n-x)! BigDecimal nSubxFactorial = new BigDecimal(1); //临时值 BigDecimal temp = BigDecimal.ZERO; //结果值 BigDecimal result = BigDecimal.ZERO; for (int i = n; i &gt; x; i--) &#123; nFactorial = nFactorial.multiply(new BigDecimal(i)); &#125; for (int i = (n - x); i &gt; 0; i--) &#123; nSubxFactorial = nSubxFactorial.multiply(new BigDecimal(i)); &#125; temp = nFactorial.divide(nSubxFactorial); //这里计算的是 p 的概率为 1/2 的二项分布 for (int i = n; i &gt; 0; i--) &#123; temp = temp.divide(new BigDecimal(2)); &#125; result = temp; return result; &#125; /** * 在 n 次实验中，预期的结果次数 &lt; x 次的概率 * * @param n * @param x * @return */ public static BigDecimal lessThan(int n, int x) &#123; BigDecimal result = BigDecimal.ZERO; for (int i = (x - 1); i &gt; 0; i--) &#123; result = result.add(equals(n, i)); &#125; return result; &#125; /** * 在 n 次实验中，预期的结果次数 &gt;= x 次的概率 * * @param n * @param x * @return */ public static BigDecimal moreThan(int n, int x) &#123; BigDecimal result = BigDecimal.ZERO; for (int i = x; i &lt; n; i++) &#123; result = result.add(equals(n, i)); &#125; return result; &#125; public static void main(String[] args) &#123; int n = 100;//总的实验次数 int x = 40;//预期的结果次数 System.out.println(\"P(x=\" + x + \") = \" + equals(n, x)); System.out.println(\"P(x&lt;\" + x + \") = \" + lessThan(n, x)); System.out.println(\"P(x&gt;=\" + x + \") = \" + moreThan(n, x)); &#125;&#125; 引用 《赤裸裸的统计学》 蒙提霍尔问题 赌徒谬误 概率：独立事件 二项分布 数学和算法之—排列组合 统计基础篇之十：怎么理解二项分布 从零开始 LaTeX 快速入门 MathJax 入门指南","raw":null,"content":null,"categories":[{"name":"数学","slug":"数学","permalink":"//huminxi.netlify.com/categories/数学/"}],"tags":[{"name":"统计学","slug":"统计学","permalink":"//huminxi.netlify.com/tags/统计学/"},{"name":"生活","slug":"生活","permalink":"//huminxi.netlify.com/tags/生活/"}]},{"title":"用 Java 怎么导出 CSV 格式的文件","slug":"用 Java 怎么导出 CSV 格式的文件","date":"2018-04-22T10:25:43.000Z","updated":"2019-04-22T07:21:16.863Z","comments":true,"path":"2018/04/22/用 Java 怎么导出 CSV 格式的文件/","link":"","permalink":"//huminxi.netlify.com/2018/04/22/用 Java 怎么导出 CSV 格式的文件/","excerpt":"大家在做 web 开发时常碰到的一个需求就是：将网页上某个列表页的数据导出。有的要求导出成 excel 格式的文件，有的要求导出成 csv 格式的文件。今天就来给大家介绍怎么利用 java 导出 csv 格式的文件。","text":"大家在做 web 开发时常碰到的一个需求就是：将网页上某个列表页的数据导出。有的要求导出成 excel 格式的文件，有的要求导出成 csv 格式的文件。今天就来给大家介绍怎么利用 java 导出 csv 格式的文件。 什么是 CSV 格式的文件逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符不一定是逗号），其文件以纯文本形式存储表格数据。纯文本意味着该文件是一个字符序列，即二进制编码的数据都可以被解读成人类可读的形式。CSV 文件由任意数目的记录组成，记录之间以 某种换行符 分隔；每条记录由字段组成，字段之间的分隔符是特定的字符或字符串，最常见的是逗号或制表符。通常，所有记录都拥有完全相同的字段。 下面就是一个符合 csv 格式的示例文件 12345nama,age,gender张三,18,男李四,20,男小红,12,女小明,12,男 导出需要注意的点 可以通过重写数据模型的 toString 方法来提高生成 csv 文件的速度 返回文件的具体编码格式根据需求来定，这里用的是 UTF-8 编码 根据业务要求和服务器性能设定一个单次导出上限值 具体实现这里是后端直接提供 HTTP 导出接口。 定义一个数据模型根据要导出的字段来定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.nongfenqi.transport.export;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.math.BigDecimal;/** * 导出物流列表的数据模型 */@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class LogisticsExport implements Serializable &#123; //物流单编号 private String logisticsInfoId; //发货单编号 private String deliveryOrderId; //厂家名称 private String supplierName; //仓库名称 private String warehouseName; //品牌名称 private String goodsBrandName; //商品名称 private String goodsName; //包装数 单位:袋 private BigDecimal goodsPackageNumber; //重量 单位:吨 private BigDecimal goodsNumber; //收货人姓名 private String customerName; //收货人手机号 private String customerPhone; //收货地址 private String receiptAddress; //紧急联系人1 private String firstEmergencyContacter; //紧急联系人1手机号 private String firstEmergencyContacterPhone; //紧急联系人2 private String secondEmergencyContacter; //紧急联系人2手机号 private String secondEmergencyContacterPhone; //这里重写 toString 方法，是为了方便导出 CSV 文件。 @Override public String toString() &#123; return logisticsInfoId + \",\" + deliveryOrderId + \",\" + supplierName + \",\" + warehouseName + \",\" + goodsBrandName + \",\" + goodsName + \",\" + goodsPackageNumber + \",\" + goodsNumber + \",\" + customerName + \",\" + receiptAddress + \",\" + firstEmergencyContacter + \",\" + firstEmergencyContacterPhone + \",\" + secondEmergencyContacter + \",\" + secondEmergencyContacterPhone; &#125;&#125; 写一个工具类工具类中包含了两个方法：一个是将数据模型转换成临时的 csv 文件；另一个是将临时 csv 文件写入到 HttpServletResponse 中返回给浏览器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.nongfenqi.transport.common;import com.nongfenqi.transport.export.LogisticsExport;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;import java.text.DateFormat;import java.util.List;/** * 导出工具类 */@Service@Slf4jpublic class ExportUtil &#123; // csv 文件的标题行 private static String TITLE_LINE = \"物流单编号\" + \",\" + \"发货单编号\" + \",\" + \"厂家名称\" + \",\" + \"发货基地\" + \",\" + \"品牌名称\" + \",\" + \"商品名称\" + \",\" + \"包装数 单位:袋\" + \",\" + \"重量 单位:吨\" + \",\" + \"收货人姓名\" + \",\" + \"收货地址\" + \",\" + \"紧急联系人1\" + \",\" + \"紧急联系人1手机号\" + \",\" + \"紧急联系人2\" + \",\" + \"紧急联系人2手机号\" + \",\"; /** * 创建一个 CSV 格式的临时文件 * * @param logisticsExports * @return * @throws IOException */ public static File createLogisticsCVSFile(List&lt;LogisticsExport&gt; logisticsExports) throws IOException &#123; File tempFile = File.createTempFile(DateFormat.getDateTimeInstance().toString(), \".csv\"); OutputStream out = new FileOutputStream(tempFile); BufferedWriter bw = new BufferedWriter(new FileWriter(tempFile, true)); bw.write(TITLE_LINE); bw.newLine(); for (LogisticsExport logistics : logisticsExports) &#123; bw.write(logistics.toString()); bw.newLine(); &#125; bw.close(); return tempFile; &#125; /** * 导出 CSV 文件 * * @param response * @param file * @param fileName * @throws IOException */ public static void exportCSVFile(HttpServletResponse response, File file, String fileName) throws IOException &#123; response.setContentType(\"application/csv;charset=UTF-8\"); response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + URLEncoder.encode(fileName, \"UTF-8\")); InputStream in = null; try &#123; in = new FileInputStream(file); int len = 0; byte[] buffer = new byte[1024]; response.setCharacterEncoding(\"UTF-8\"); OutputStream out = response.getOutputStream(); while ((len = in.read(buffer)) &gt; 0) &#123; out.write(new byte[]&#123;(byte) 0xEF, (byte) 0xBB, (byte) 0xBF&#125;); out.write(buffer, 0, len); &#125; &#125; catch (FileNotFoundException e) &#123; log.warn(e.getMessage()); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125;&#125; 写一个 HTTP 接口利用 Spring 框架，写一个 RestController 接口给前端或者浏览器端调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.nongfenqi.transport.controller;import com.nongfenqi.transport.PageQueryReq;import com.nongfenqi.transport.QuerySortReq;import com.nongfenqi.transport.common.ExportUtil;import com.nongfenqi.transport.export.LogisticsExport;import com.nongfenqi.transport.logistics.LogisticsQuery;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.Collections;import java.util.List;/** * 物流公司业务接口 */@RestController@RequestMapping(\"/logistics\")public class TempLogisticsController &#123; @RequestMapping(value = \"export\", method = RequestMethod.GET) public void exportLogisticsList( @ModelAttribute PageQueryReq pageQuery, @ModelAttribute QuerySortReq querySortReq, @ModelAttribute LogisticsQuery logisticsQuery, HttpServletResponse response ) throws IOException &#123; // 根据条件筛选出具体需要导出的数据列表 LogisticsExport logisticsExport = LogisticsExport.builder() .logisticsInfoId(\"1\") .deliveryOrderId(\"2\") .build(); List&lt;LogisticsExport&gt; logisticsExports = Collections.singletonList(logisticsExport); // 创建一个 CSV 格式的临时文件 File logisticsCVSFile = ExportUtil.createLogisticsCVSFile(logisticsExports); // 将 CSV 文件写入到 HttpServletResponse 当中，返回给浏览器 ExportUtil.exportCSVFile(response, logisticsCVSFile, \"logistics.csv\"); &#125;&#125; 引用 逗号分隔值 Java 流(Stream)、文件(File)和 IO 回车和换行","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"java","slug":"java","permalink":"//huminxi.netlify.com/tags/java/"},{"name":"CSV","slug":"CSV","permalink":"//huminxi.netlify.com/tags/CSV/"}]},{"title":"初识 Maven","slug":"初识 Maven","date":"2018-04-01T12:55:30.000Z","updated":"2019-04-22T07:21:16.865Z","comments":true,"path":"2018/04/01/初识 Maven/","link":"","permalink":"//huminxi.netlify.com/2018/04/01/初识 Maven/","excerpt":"相信从事 Java 开发的小伙伴们对 Maven 这个词都不陌生。目前来说，只要存在外部依赖的 Java 项目基本上都是 Maven 项目，而每个 Maven 项目都有一个明显的特征——pom.xml 文件。\n\n今天，我们就一起来学习一下什么是 Maven 项目。","text":"相信从事 Java 开发的小伙伴们对 Maven 这个词都不陌生。目前来说，只要存在外部依赖的 Java 项目基本上都是 Maven 项目，而每个 Maven 项目都有一个明显的特征——pom.xml 文件。 今天，我们就一起来学习一下什么是 Maven 项目。 新建一个 Maven 项目安装 JDKMaven 是一个 Java 工具，因此必须先 安装 Java 开发环境 之后才能继续。 安装 Maven首先，下载 Maven 并按照 安装说明 进行操作。之后，在终端输入以下命令: 1mvn -v 它会打印出你刚才安装的 Maven 版本，如下图所示: Maven 版本 创建一个项目新建一个空目录 maven，然后执行下列命令创建一个新的 Maven 项目 1mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=Maven-archetype-quickstart -DinteractiveMode=false creating a project 如果是刚刚安装了 Maven，则第一次运行可能需要一段时间。这是因为 Maven 正在将插件的 jar 包以及其它的文件下载到本地存储库中。 total time 再次查看该目录，多了一个 my-app 目录。进入 my-app 目录，并查看其目录结构，发现它果然也包含了 pom.xml 文件。 my-app 目录结构接下来用你惯用的 IDE 打开 my-app 项目，这里使用的是 IDEA。 利用 IDEA 打开 my-app 项目 目录结构如下 src/main/java 项目源码 src/test/java 测试代码 pom.xml 项目对象模型(Project Object Model) POM 文件pom.xml 文件是 Maven 项目配置的核心。它是一个单独的配置文件，其中包含以您想要的方式构建项目所需的大部分信息。my-app 项目的 pom.xml 如下: 123456789101112131415161718192021&lt;project xmlns=\"http://Maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://Maven.apache.org/POM/4.0.0 http://Maven.apache.org/Maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://Maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 打包执行下列命令 1mvn package 打包成功后，其结果输出到 target 目录中。 package success 在 IDEA 中查看 target 目录 校验可以使用下面的命令来测试新打的 jar 包: 1java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App 在命令行执行 Java 程序 到这里，我们已经知道该如何新建一个 Maven 项目了。那么，为什么现在大多数的 Java 项目都是 Maven 项目呢？我们下期再聊。 引用 Maven in 5 Minutes java -cp 用法介绍","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"//huminxi.netlify.com/tags/Maven/"}]},{"title":"可靠数据传输服务续","slug":"可靠数据传输服务续","date":"2018-03-23T14:55:06.000Z","updated":"2018-12-18T10:29:08.079Z","comments":true,"path":"2018/03/23/可靠数据传输服务续/","link":"","permalink":"//huminxi.netlify.com/2018/03/23/可靠数据传输服务续/","excerpt":"\n\n\n经过 前文 的介绍，我们现在已经有了一个可以在『存在比特差错的丢包信道』上进行可靠数据传输(reliable data transfer)的协议——rdt3.0。但同时我们也发现了 rdt3.0 其实并不完善，因为它是一个停等(stop-and-wait)协议，所以还存在性能方面的问题待优化。今天我们就一起来看看具体是怎么优化的吧！","text":"经过 前文 的介绍，我们现在已经有了一个可以在『存在比特差错的丢包信道』上进行可靠数据传输(reliable data transfer)的协议——rdt3.0。但同时我们也发现了 rdt3.0 其实并不完善，因为它是一个停等(stop-and-wait)协议，所以还存在性能方面的问题待优化。今天我们就一起来看看具体是怎么优化的吧！ 由停等到流水线 为了评价该停等行为对性能的影响，可考虑一种具有两台主机的理想化场合，一台主机位于美国西海岸，另一台位于美国东海岸，如图 3-17 所示。在这两个端系统之间的光速往返传播时延 RTT 大约为 30 毫秒。假定彼此通过一条发送速率 R 为 1Gbps (每秒 10⁹ 比特）的信道相连。包括首部字段和数据的分组长 L 为 1000 字节(8000 比特），发送一个分组进入 1Gbps 链路实际所需时间是: $$T𝗍𝗋𝖺𝗇𝗌=\\frac{L}{R}=\\frac{8000 bit}{10⁹ bit/s}=8µs$$ 图 3-17 停等协议与流水线协议 图 3-18a 显示了对于该停等协议，如果发送方在 t=0 时刻开始发送分组，则在 t=L/R=8µs 后，最后 1 比特数据进入了发送端信道。该分组经过 15ms 后到达接收端，该分组的最后 1 比特在时刻 T=RTT/2 + L/R= 15.008ms 时到达接收方。为了简化起见，假设 ACK 分组很小（以便我们可以忽略其发送时间），接收方一旦收到一个数据分组的最后 1 比特后立即发送 ACK，ACK 在时刻 t = RTT + L/R =30.008ms 时在发送方出现。此时，发送方可以发送下一个报文。因此，在 30.008ms 内，发送方的发送只用了 0.008ms。如果我们定义发送方（或信道）的利用率 (utilization) 为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比，图 3-18a 中的分析表明了停等协议有着非常低的发送方利用率 U𝗌𝚎𝗇𝚍𝚎𝚛: $$U𝗌𝚎𝚗𝚍𝚎𝚛=\\frac{L/R}{RTT+L/R}=\\frac{0.008 ms}{30.008 ms}=0.00027$$ 图 3-18 停等和流水线发送 这就是说，发送方只有万分之 2.7 的时间是忙的。 从其他角度来看，发送方在 30.008m 内只能发送 1000 字节，有效的吞吐量仅为 267kbps，即使有 1Gbps 的链路可用！想象一个不幸的网络经理购买了一条千兆比特率的链路，但他仅能得到 267kbps 吞吐量的情况！这是一个形象的网络协议限制底层网络硬件所提供的能力的示例。而且，我们还忽略了在发送方和接收方的底层协议处理时间，以及可能出现在发送方与接收方之间的任何中间路由器上的处理与排队时延。考虑到这些因素，将进一步增加时延，使其性能更糟糕。 解决这种特殊的性能问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认，如在图 3-17b 图示的那样。图 3-18b 显示了如果发送方可以在等待确认之前发送 3 个报文，其利用率也基本上提高 3 倍。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为流水线(pipelining)。流水线技术对可靠数据传输协议可能带来如下影响: 必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。 协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓存那些已发送但没有确认的分组。如下面讨论的那样，接收方或许也需要缓存那些已正确接收的分组。 所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：回退 N 步(Go-Back-N，GBN)和选择重传(Selective Repeat，SR)。 Go-Back-N滑动窗口协议 在回退 N 步(GBN)协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。 图 3-19 显示了发送方看到的 GBN 协议的序号范围。如果我们将基序号(base)定义为最早的未确认分组的序号，将下一个序号(nextseqnum)定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割成 4 段。在 [0, base-1] 段内的序号对应于已经发送而且被确认的分组。[base, nextseqnum - 1] 段内对应已经发送但未被确认的分组。[nextseqnum, base + N - 1] 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。最后，大于或等于 base + N 的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为 base 的分组）已得到确认为止。 图 3-19 在 GBN 中发送方看到的序号 如图 3-19 所示的那样，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为窗口长度(window size)，GBN 协议也常被称为滑动窗口协议 (sliding-window protocol)。 你也许想知道，我们为什么要限制这些被发送的、未被确认的分组的数目为 N 呢？为什么不允许这些分组为无限制的数目呢？流量控制是对发送方施加限制的原因之一。当然还有其它的原因在里面，我们这里不展开讨论。 在实践中，一个分组的序号是放在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是 k，则该序号范围是 [0, 2ᵏ - 1] 。在一个有限的序号范围内，所有涉及序号的运算必须使用模 2ᵏ 运算(可将序号空间看作是一个长度为 2ᵏ 的环，其中序号 2ᵏ - 1 紧挨着序号 0)。前面讲过，rdt3.0 有一个比特的序号，其序号范围是 [0, 1] (而 TCP 的序号字段有 32 比特)。 发送方 FSM图 3-20 GBN 发送方的扩展 FSM 描述 GBN 发送方必须响应三种类型的事件: 上层的调用。当上层调用 rdt_send() 时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过会儿再试。在实际实现上，发送方更可能缓存（并不立刻发送）这些数据，或者使用同步机制(如一个信号量或标志)允许上层在仅当窗口不满时才调用 rdt_send()。 收到一个 ACK。在 GBN 协议中，对序号为 n 的分组的确认采取累积确认(cumulative acknowledgment)的方式，表明接收方已正确接收到序号为 n 的之前且包括 n 在内的所有分组。稍后讨论 GBN 接收方时，我们将再次研究这个主题。 超时事件。协议的名字『回退 N 步』来源于出现丢失和时延过长的分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，发送方重传所有已发送但还未被确认过的分组。图 3-20 中的发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个 ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已经发送但未被确认的分组，该定时器被终止。 接收方 FSM图 3-21 GBN 接收方的扩展 FSM 描述 在 GBN 中，接收方的动作也很简单。如果一个序号为 n 的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为 n-1 的分组），则接收方为分组 n 发送一个 ACK，并将该分组中的数据交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK。注意到因为一次交付给上层一个分组，如果分组 k 已接收并交付，则所有比 k 小的分组也已经交付。因此，使用累积确认是 GBN 的一个自然选择。 在 GBN 协议中，接收方丢弃所有失序分组。尽管丢弃一个正确接收(但失序)的分组有点愚蠢和浪费，但这样做是有理由的。前面讲过，接收方必须按序将数据交付给上层。假定现在期望接收分组 n，而分组 n+1 却到了。因为数据必须按序交付，接收方可能缓存分组 n+1，然后，在它收到并交付分组 n 后，再将该分组交付到上层。然而，如果分组 n 丢失，则该分组及分组 n+1 最终将在发送方根据 GBN 重传规则而被重传。因此，接收方只需丢弃分组 n+1 即可。 这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及 nextseqnum 在该窗口中的位置，但是接收方只需要维护下一个按序接收的分组的序号即可。该值保存在 expectedseqnum 变量中，如图 3-21 中接收方 FSM 所示。当然，丢弃一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此可能需要更多的重传。 运行中的 GBN 图 3-22 给出了窗口长度为 4 个分组的 GBN 协议的运行情况。因为该窗口长度的限制，发送方发送分组 0-3，然后在继续发送之前，必须等待直到一个或多个分组被确认。当接收到每一个连续的 ACK(例如 ACK 0 和 ACK 1)时，该窗口便向前滑动，发送方就可以发送新的分组(分别是分组 4 和分组 5)。在接收方，分组 2 丢失，因此分组 3、4 和 5 被发现是失序分组并被丢弃。 图 3-22 运行中的 GBN Selective RepeatGBN 大批量重传的问题 在图 3-17 中，GBN 协议潜在地允许发送方用多个分组『填充流水线』，因此缓解了停等协议中所提到的信道利用率问题。然而，GBN 本身也有一些情况存在着性能问题。尤其是当窗口长度和带宽时延的乘积很大时，在流水线(分组更多)中更为严重。单个分组的差错就能够引起 GBN 重传大批分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。想象一下，在我们口述消息的例子中，如果每次有一个单词含糊不清，其前后 1000 个单词(假设窗口长度为 1000 个单词)不得不被重传的情况。此次口述将会由于这些反复述说的单词而变慢。 顾名思义，选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方出错(即丢失或受损)的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度 N 来限制流水线中未完成、未被确认的分组数。然而，与 GBN 不同的是，发送方已经收到了对窗口中某些分组的 ACK。图 3-23 显示了 SR 发送方和接收方看到的序号空间。 图 3-23 SR 发送方与接收方的序号空间 SR senderSR 发送方的事件与动作 从上层收到数据。当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将数据缓存，要么将其返回给上层以便以后传输。 超时。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。 收到 ACK。如果收到 ACK，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于 send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。 SR receiverSR 接收方的事件与动作 序号在 [rcv_base, rcv_base + N - 1] 内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（图 3-23 中的 rcv_base)，则将该分组以及以前缓存的序号连续的(起始于 rcv_base 的)分组交付给上层。然后，接收窗口按向前移动分组的编号依次向上交付这些分组。举例子来说，考虑一下图 3-26。当收到一个序号为 rcv_base = 2 的分组时，该分组及分组 3、4 、5 可一起交付给上层。 序号在 [rev_base - N, rev_base - 1] 内的分组被正确收到。在此情况下，必须产生一个 ACK，即使该分组是接收方以前已确认过的分组。 其它情况。忽略该分组。 图 3-26 SR 操作 SR 窗口不一致的问题 注意到 SR receiver 中的第二步很重要，接收方重新确认(而不是忽略)已收到过的那些序号小于当前窗口基序号的分组。你应该理解这种重新确认确实是需要的。例如，给定在图 3-23 中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK 没有从接收方传播回发送方，则发送方最终将重传分组 send_base，即使接收方已经收到了该分组。如果接收方不确认该分组，则发送方窗口将永远不能向前滑动！这个例子说明了 SR 协议的一个重要方面。对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果。对 SR 协议而言，这就意味着发送方和接收方的窗口并不总是一致。 当我们面对有限序号范围的情况时，发送方和接收方窗口间缺乏同步会产生严重的后果。考虑下面例子中可能发生的情况，例子中有包括 4 个分组序号 0、1、2、3 的有限序号范围且窗口长度为 3。假定发送了分组 0 至 2，并在接收方被正确接收且确认了。此时，接收方窗口落在第 4、5、6 个分组上，其序号分别为 3、0、1。现在考虑两种情况: 在第一种情况下，如图 3-27a 所示，对前 3 个分组的 ACK 丢失，因此发送方重传这些分组。因此，接收方下一步要接收序号为 0 的分组，即第一个发送分组的副本。 在第二种情况下，如图 3-27b 所示，对前 3 个分组的 ACK 都被正确交付。因此发送方向前移动窗口并发送第 4、5、6 个分组，其序号分别为 3、0、1。序号为 3 的分组丢失，但序号为 0 的分组到达(一个包含新数据的分组)。 图 3-27 SR 接收方窗口太大的困境：是一个新分组还是一次重传 现在考虑一下图 3-27 中接收方的观点，在发送方和接收方之间有一副假想的帘子，因为接收方不能『看见』发送方采取的动作。接收方所能观察到的是它从信道中收到的以及它向信道中发出报文序列。就其所关注的而言，图 3-27 中的两种情况是等同的。没有办法区分是第 1 个分组的重传还是第 5 个分组的初次传输。显然，窗口长度比序号空间小 1 时协议无法工作。 但窗口必须多小呢？窗口长度比须小于或等于序号空间大小的一半。 总结可靠数据传输机制及其用途 机制 用途和说明 校验和 用于检测在一个传输分组中的比特错误 定时器 用于超时/重传一个分组，可能因为该分组(或其 ACK)在信道中丢失了。由于当一个分组延时但未丢失(过早超时)，或当一个分组已被接收方收到但从接收方到发送方的 ACK 丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本 序号 用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本 肯定确认 接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议 否定确认 接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号 窗口、流水线 发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。 信道重排序分组的问题 我们通过考虑在底层信道模型中的一个遗留假设来结束对可靠数据传输协议的讨论。前面讲过，我们曾假定分组在发送方与接收方之间的信道中没有被重新排序。这在发送方与接收方由单段物理线路相连的情况下，通常是一个合理的假设。 然而，当连接两端的『信道』是一个网络时，分组重新排序是可能会发生的。分组重新排序的一个表现就是，一个具有序号或确认号 x 的分组的旧副本可能会出现，即使发送方或接收方的窗口中都没有包含 x。对于分组重新排序，信道可被看成基本上是在缓存分组，并在将来任意时刻自然地释放出这些分组。由于序号可以被重新使用，那么必须小心，以免出现这样的冗余分组。 实际应用中采用的方法是，序号 x 能否被重新使用，需要发送方『确信』任何先前发送的序号为 x 的分组都不再在网络中为止。通过假定一个分组在网络中的『存活』时间不会超过某个固定最大时间量来做到这一点。在高速的 TCP 扩展中，最长的的分组寿命被假定为大约 3 分钟。 引用 《计算机网络:自定向下方法》 Markdown 中插入数学公式的方法 LATEX 数学公式基本语法 比特率","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"数据传输","slug":"数据传输","permalink":"//huminxi.netlify.com/tags/数据传输/"},{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/tags/网络/"}]},{"title":"可靠数据传输服务","slug":"可靠数据传输服务","date":"2018-03-18T04:19:26.000Z","updated":"2018-12-18T10:29:08.076Z","comments":true,"path":"2018/03/18/可靠数据传输服务/","link":"","permalink":"//huminxi.netlify.com/2018/03/18/可靠数据传输服务/","excerpt":"我们知道，传输层有两个协议，分别是 UDP 和 TCP。其中 UDP 提供的是无连接的、不可靠的数据传输服务。而 TCP 则提供面向连接、带拥塞控制的可靠数据传输服务。今天，我们就来聊一聊该怎么实现可靠数据传输服务(reliable data transmission service)。","text":"我们知道，传输层有两个协议，分别是 UDP 和 TCP。其中 UDP 提供的是无连接的、不可靠的数据传输服务。而 TCP 则提供面向连接、带拥塞控制的可靠数据传输服务。今天，我们就来聊一聊该怎么实现可靠数据传输服务(reliable data transmission service)。 我们的目标先来看一张图。 图 3-8 可靠数据传输服务的模型与实现 名词解释: Application Layer 应用层 Transport Layer 传输层 Network Layer 网络层 Sending process 发送进程 Receiver process 接收进程 Reliable channel 可靠信道 Unreliable channel 不可靠信道 Data 数据 Packet 分组 rdt reliable data transfer 可靠数据传输 udt unreliable data transfer 不可靠数据传输 图 3-8 描述的是可靠数据传输框架的模型与实现。图中，为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏（由 0 变为 1，或者由 1 变为 0）或丢失，而且所有数据都是按照其发送顺序进行交付。这恰好就是 TCP 向调用它的因特网应用所提供的服务模型。 图 3-8b 说明了用于数据传输协议的接口。通过调用 rdt_send() 函数，可以调用数据传输协议的发送方。它将要发送的数据交付给位于接收方的较高层(这里 rdt 表示可靠数据传输协议，_send 指示 rdt 的发送端正在被调用)。在接收端，当分组从信道的接收端到达时，将调用 rdt_rcv()。当 rdt 协议想要向较高层交付数据时，将通过调用 deliver_data() 来完成。 怎么实现 我们现在一步步地研究一系列协议，它们一个比一个更为复杂，最后得到一个无错、可靠的数据传输协议。 rdt 1.0经完全可靠信道的可靠数据传输协议 有限状态机(finite-state-machine) 首先，我们考虑最简单的情况，即底层信道是完全可靠的。我们称该协议为 rdt1.0，该协议本身是简单的。图 3-9 显示了 rdt1.0 发送方和接收方的有限状态机(Finite-State-Machine, FSM)的定义。 图 3-9 rdt1.0 用于完全可靠信道的协议 图 3-9a 中的 FSM 定义了发送方的操作，图 3-9b 中的 FSM 定义了接收方的操作。注意到下列问题是重要的 发送方和接收方有各自的 FSM 。图 3-9 中发送方和接收方的 FSM 每个都只有一个状态。 FSM 描述图中的箭头指示了协议从一个状态变迁到另一个状态。（因为 图 3-9 中的每个 FSM 都只有一个状态，因此变迁必定是从一个状态返回到自身。） 引起变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有事件就发生了动作，我们将在横线下方或上方使用符号 𐌡，以明确地表示缺少动作或事件。 FSM 的初始状态用虚线表示。尽管图 3-9 中的 FSM 只有一个状态但马上我们就将看到多状态的 FSM，因此标识每个 FSM 的初始状态是非常重要的。 发送端 rdt 的发送端只通过 rdt_send(data) 事件接受来自较高层的数据，产生一个包含该数据的分组（经由 make_pkt(data) 动作），并将分组发送到信道中。 实际上，rdt_send(data) 事件是由较高层应用的过程调用产生的 （例如，rdt_send()）。 接收端 在接收端，rdt 通过 rdt_rcv(packet) 事件从底层信道接收一个分组，从分组中取出数据（经由 extract(packet, data) 动作），并将数据上传给较高层（通过 deliver_data(data) 动作）。实际上，rdt_rcv(packet) 事件是由较低层协议的过程调用产生的（例如，rdt_rcv())。 小结 在这个简单的协议中，一个 data 和一个 packet 在内容上没有任何差别。而且，所有分组是从发送方流向接收方。有了完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，因为不必担心出现差错！注意到我们也已经假定了接收方接收数据的速率能够与发送方发送数据的速率一样快。因此，接收方没有必要请求发送方慢一点！ rdt 2.0经具有比特差错信道的可靠数据传输协议 停等协议(stop-and-wait) 底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。我们眼下还将继续假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收。 在开始研究能通过这种信道进行可靠通信的协议之前，首先考虑一下人们会怎样处理这类情形。考虑一下你自己是怎样通过电话口述一条长消息的(如电话号码)。在通常情况下，报文接收者在听到、理解并记下每句话后可能会说『OK』。如果报文接收者听到一句含糊不清的话时，他可能要求你重复刚才那句话。这种口述报文协议使用了肯定确认(positive acknowledgement)『OK』与否定确认(negative acknowledgment) 『请重复一遍』。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求(Automatic Repeat reQuest, ARQ)协议。 基本上，ARQ 协议中需要包括下列三种功能来处理存在比特差错的情况 差错检测。首先，需要一种机制以使接收方检测到何时出现了比特差错。实现这个机制的技术要求有额外的比特（非原始数据中的比特）从发送方发送到接收方。这些比特将存在于 rdt2.0 数据分组的分组检验和字段当中。 接收方反馈。因为发送方和接收方通常在不同端系统上执行，可能相隔数千英里，发送方要了解接收方情况（这里为分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。在口述报文情况下回答的『肯定确认』(ACK)和『否定确认』(NAK)就是这种反馈的例子。类似地，我们的 rdt2.0 协议将从接收方向发送方回送 ACK 与 NAK 分组。理论上，这些分组只需要一个比特长，如用 0 表示 NAK，用 1 表示 ACK。 重传。接收方收到有差错的分组时，发送方将重传该分组。 图 3-10 说明了表示 rdt2.0 的 FSM，该数据传输协议采用了差错检测、肯定确认与否定确认。 图 3-10 rdt2.0 用于具有比特差错信道的协议 注意到下列事实很重要：当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据。这就是说，rdt_send() 事件不可能出现，仅当接收到 ACK 并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0 这样的协议被称为停等(stop-and-wait)协议。 ACK/NAK 受损 rdt2.0 协议看起来似乎可以运行了，但遗憾的是，它存在一个致命的缺陷。我们没有考虑到 ACK 或 NAK 分组受损的可能性！（在继续研究之前，你应该考虑怎样解决该问题。）遗憾的是，我们细小的疏忽并非像它看起来那么无关紧要。至少，我们需要在 ACK/NAK 分组中添加检验和比特以检测这样的差错。更难的问题是协议应该怎样纠正这样的差错。这里的难点在于，如果一个 ACK/NAK 分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据。 我们考虑处理受损 ACK 和 NAK 的 3 种可能情况: 第一种，在口述报文情况下人们通常的做法。如果说话者不理解来自接收方回答的『OK』或『请重复一遍』，说话者将可能问 『你说什么？』（这样就在我们的协议中引入了一种新的发送方到接收方的分组类型），接收方则将复述其回答。但是如果说话者的『你说什么？』产生了差错，情况又会怎样呢？由于接收者不明白那句混淆的话是口述内容的一部分还是一个要求重复上次回答的请求，很可能也回一句『你说什么？』。于是，越回答越乱。显然，我们走上了一条困难重重之路。 第二种，增加足够长度的检验和比特，使收到受损 ACK/NAK 的发送方不仅可以检测出差错，还可恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。 第三种，当发送方收到含糊不清的 ACK/NAK 分组时，只需重传当前数据分组即可。然而，这种方法在发送方到接收方的信道中引人了冗余分组(duplicate packet)。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK/NAK 是否被发送方正确地收到，这就导致它无法确认这一次接收到的分组是新的还是一次重传！ 解决这个新问题的一个简单方法（几乎所有现有的数据传输协议中，包括 TCP，都采用了这种方法）是在数据分组中添加一新字段，让发送方对其数据分组进行编号，将数据分组的序号(sequence number)放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否来自重传。对于停等协议这种简单情况，1 比特序号就足够了，因为它可让接收方知道发送方是否正在重传前一个发送分组（接收到的分组序号与最近收到的分组序号相同），或是一个新分组（序号变化了）。因为目前我们假定信道不丢失分组。ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。发送方知道所接收到的 ACK 和 NAK 分组（无论是否是含糊不清的）是为响应其最近发送的数据分组而生成的。 图 3-11 和图 3-12 给出了对 rdt2.1 的 FSM 描述，这是 rdt2.0 的修订版。rdt2.1 的发送方和接收方 FSM 的状态数都是以前的两倍。这是因为协议状态此时必须反映出目前（由发送方）正发送的分组或（在接收方）希望接收的分组的序号是 0 还是 1。值得注意的是，发送或期望接收 0 号分组的状态中的动作与发送或期望接收 1 号分组的状态中的动作是相似的；唯一的不同是序号处理的方法不同。 图 3-11 rdt2.1 发送方 图 3-12 rdt2.1 接收方 去掉 NAK 协议 rdt2.1 使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认。如果收到受损的分组，则接收方将发送一个否定确认。如果不发送 NAK，而是对上次正确接收的分组发送一个 ACK，我们也能实现与 NAK 一样的效果。发送方接收到对同一个分组的两个 ACK (即接收冗余 ACK (duplicate ACK))后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。rdt2.2 是在有比特差错信道上实现的一个无 NAK 的可靠数据传输协议，如图 3-13 和图 3-14 所示。rdt2.1 和 rdt2.2 之间的细微变化在于，接收方此时必须包括由一个 ACK 报文所确认的分组序号（这可以通过在接收方 FSM 中，在 make_pkt() 中包括参数 ACK 0 或 ACK 1 来实现），发送方此时必须检查接收到的 ACK 报文中被确认的分组序号（这可通过在发送方 FSM 中， 在 isACK() 中包括参数 0 或 1 来实现）。 图 3-13 rdt2.2 发送方 图 3-14 rdt2.2 接收方 rdt 3.0经具有比特差错的丢包信道的可靠数据传输协议 丢包检测和恢复 现在假定除了比特受损外，底层信道还会丢包，这在今天的计算机网络（包括因特网）中很常见。协议现在必须解决另外两个关注的问题：怎样检测丢包以及发生丢包后该做些什么。在 rdt2.2 中已经研发的技术，如使用检验和、序号、ACK 分组和重传等，使我们能给出后一个问题的答案。为解决第一个的问题，还需增加一种新的协议机制。 有很多可能的方法用于解决丢包问题，在这里，我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对该分组的 ACK 发生了丢失。在这两种情况下，发送方都收不到来自接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已经丢失，则它只需重传该数据分组即可。 但是发送方需要等待多久才能确定已丢失了某些东西呢？很明显发送方至少需要等待这样长的时间：即发送方与接收方之间的一个往返时延（可能会包括在中间路由器的缓冲时延）加上接收方处理一个分组所需的时间。在很多网络中，最坏情况下的最大时延是很难估算的，确定的因素非常少。此外，理想的协议应该能尽快地从丢包中恢复出来。等待一个最坏情况的时延可能意味着要等待一段较长的时间，直到启动差错恢复为止。因此实践中采取的方法是发送方『明智』地选择一个时间值，以判定可能发生了丢包（尽管不能确保）。如果在这个时间内没有收到 ACK，则重传该分组(注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其 ACK 都没有丢失)。这就在发送方到接收方的信道中引入了冗余数据分组(duplicate data packet)的可能性。幸运的是，rdt2.2 协议已经有足够的功能（即序号）来处理冗余分组的情况。 定时重传 从发送方的观点来看，重传是一种万能灵药(重启也是!)。发送方不知道是一个数据分组丢失，还是一个 ACK 丢失，或者只是该分组或 ACK 过度延时。在所有这些情况下，动作是同样的：重传。为了实现基于时间的重传机制，需要一个倒计时器(countdown timer)，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到: 每次发送一个分组(包括新分组和重传分组)时，便启动一个定时器 响应定时器中断(采取适当的动作) 终止定时器 图 3-15 给出了 rdt3.0 的发送方 FSM，这是一个在可能出错和丢包的信道上可靠传输数据的协议。 图 3-15 rdt3.0 发送方 rdt3.0 接收方因为它和 rdt2.2 一样，没有 ACK 和 NCK 的区别，而且传输的数据分组也标了序号(0 和 1)，所以它不受超时重传的影响。因此 rtd3.0 和 rtd2.2 的接受方是一样的 FSM 图。 图 3-16 rdt3.0 接收方 现在我们归纳一下数据传输协议的要点。在检验和、序号、定时器、肯定和否定确认分组这些技术中，每种机制都在协议的运行中起到了必不可少的作用。至此，我们得到了一个可靠的数据传输协议！ rdt3.0 的性能问题rdt3.0 是一个功能正确的协议，但并非人人都对它的性能满意，特别是在今天的高速网络中更是如此。rdt3.0 性能问题的核心在于它是一个停等协议！ 预知后事如何，且听 下回分解。 引用 《计算机网络:自定向下方法》","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"数据传输","slug":"数据传输","permalink":"//huminxi.netlify.com/tags/数据传输/"},{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/tags/网络/"}]},{"title":"钉钉自定义机器人的一种用法","slug":"钉钉自定义机器人的一种用法","date":"2018-03-11T05:24:04.000Z","updated":"2019-01-04T08:51:57.287Z","comments":true,"path":"2018/03/11/钉钉自定义机器人的一种用法/","link":"","permalink":"//huminxi.netlify.com/2018/03/11/钉钉自定义机器人的一种用法/","excerpt":"文章的主要内容是介绍怎么利用钉钉的自定义机器人来自动通知技术部的今日分享。目的是想给大家提供一种『利用钉钉的「自定义机器人」实现「定时」通知「固定格式消息」的实现思路』。","text":"文章的主要内容是介绍怎么利用钉钉的自定义机器人来自动通知技术部的今日分享。目的是想给大家提供一种『利用钉钉的「自定义机器人」实现「定时」通知「固定格式消息」的实现思路』。 需求来源背景 公司使用钉钉作为聊天软件 钉钉存在对外开放的接口，例如『自定义机器人』 技术部一直有分享的氛围 起因 有分享者自然也要有听众，这样分享者才有动力。那么分享者采用什么方式通知到听众今天要分享的内容呢？目前我们都是提前把分享内容告知给郭大侠，然后由郭大侠统一在分享开始之前，『手动』在技术部的钉钉群里通知即将要分享的相关内容。但这样做存在两个问题: 当你提前告知郭大侠分享内容之后，必须再一次通知郭大侠才能修改之前定的分享日期，不能实现自主修改 郭大侠有时候会忘记在群里发通知 由于通过『郭大侠手动通知分享内容』的现行方式存在以上两个问题，于是就有了想写一个程序来实现自动通知分享内容的想法。Let’s do it. 实现思路 先写一个 python 脚本。将公司内部专门用来记录分享内容的 wiki 页面 爬下来，然后进行解析，得到分享内容。然后利用钉钉提供的 自定义机器人 将分享内容通知到技术部聊天群 再写一个定时任务。用来每天定时跑上面写好的 python 脚本 先写一个 python 脚本 工欲善其事，必先利其器。 下面介绍几个能节省几周工作时间的 python 类库。 BeautifulSoup Beautiful Soup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能够通过你喜欢的转换器实现惯用的文档导航、查找、修改文档的方式。Beautiful Soup 会帮你节省数小时甚至数天的工作时间。 Requests Requests is the only Non-GMO HTTP library for Python, safe for human consumption. 代码注意，代码采用 python3 实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/env python3import re #正则包 import requests #封装了 http 请求的包from bs4 import BeautifulSoup #html 解析包from datetime import datetime #时间包#1. 将 wiki 上记录分享的网页下载下来，并进行解析#注意点 1: 这里需要换成你自己想要解析的相应网页的 url(更换的网页地址之后记得重新定义网页的解析规则，即第 2、3、4 步的代码)doc_url='你要解析的网页 url'html_doc = requests.get(doc_url)soup = BeautifulSoup(html_doc.content, 'html.parser')#2. 利用正则找出所有的分享日期，并判断今日有无分享date_list=soup.find_all(string=re.compile(\"分享日期\"))today = datetime.now().strftime(\"%Y-%m-%d\")#这里需要初始化一个不存在的分享日期，例如 1995-02-14#todo 这里有一个 bug，就是如果同一天有多个分享，只会查出排在前面的那条记录。2018-03-11 21:16next_share_date='1995-02-14'for ele in date_list: ele=ele[5:] if ele==today: next_share_date=ele break#3. 利用 BeautifulSoup 找出所有的分享内容share_record=soup.find_all(string=re.compile(\"分享日期\\s.*|分享时长\\s.*|分享地点\\s.*|分享简介\\s.*|分享范围\\s.*|分享人\\s.*|《.*》\"))#4. 因为分享记录的格式固定，所以从分享日期开始往后的 7 个元素就包括了一次分享的所有记录next_share_content=[]for index in range(len(share_record)): if next_share_date in share_record[index]: for i in range(7): next_share_content.append(share_record[index]) index+=1 else: continue#5. if 今日无分享，do nothing；else 通过钉钉的自定义机器人推送消息if next_share_content == []: print('next_share_content is null')else: print('next_share_content ',next_share_content) date='' time='' place='' title='' summary='' scope='' author='' href='' for index in range(len(next_share_content)): if '分享日期' in next_share_content[index]: date=next_share_content[index] if '分享时长' in next_share_content[index]: time=next_share_content[index] if '分享地点' in next_share_content[index]: place=next_share_content[index] if '《' in next_share_content[index]: title=next_share_content[index] #将 '分享主题' 四个字替换成 '' 空串,这样就能去除重复的 '分享主题'四个字。 p = re.compile('分享主题') title=p.sub('',title) #取出分享主题的链接 href_list=soup.find_all('a') for i in range(len(href_list)): if title in href_list[i]: href=href_list[i].get('href') break if '分享简介' in next_share_content[index]: summary=next_share_content[index] if '分享范围' in next_share_content[index]: scope=next_share_content[index] if '分享人' in next_share_content[index]: author=next_share_content[index] #如果分享主题没有链接，则正常发主题；否则，把链接也加上。 if href=='': str_list=['&#123;\"msgtype\":\"markdown\",\"markdown\":&#123;\"title\":\"今日分享\",\"text\":\"### **分享主题** **',title,'** \\n','###### **',summary[2:],'** \\n','##### **',date[2:],'** \\n','##### **',time[2:],'** \\n','##### **',place[2:],'** \\n','##### **',scope[2:],'** \\n','##### ',author,' \"','&#125;',',\"at\":&#123;\"atMobiles\":[],\"isAtAll\":true&#125;','&#125;'] else: str_list=['&#123;\"msgtype\":\"markdown\",\"markdown\":&#123;\"title\":\"今日分享\",\"text\":\"### **分享主题** [',title,'](',href,')', '\\n','###### **',summary[2:],'** \\n','##### **',date[2:],'** \\n','##### **',time[2:],'** \\n','##### **',place[2:],'** \\n','##### **',scope[2:],'** \\n','##### ',author,' \"','&#125;',',\"at\":&#123;\"atMobiles\":[],\"isAtAll\":true&#125;','&#125;'] message=''.join(str_list) print('message', message) #注意点 2:dingding_url 需要替换成你自己钉钉机器人的 webhook 地址 dingding_url='webhook 地址' headers=&#123;\"Content-Type\": \"application/json\"&#125; r = requests.post(dingding_url, data=message.encode('utf-8'), headers=headers) 复用上面这段代码需要注意两点: doc_url 需要替换成自己要解析的网页地址 dingding_url 需要替换成自己的钉钉机器人的 webhook 地址 再写一个定时任务linux 机器有一个 crontab 命令，这个是 linux 系统提供的实现自定义系统计划的命令。 编辑系统计划crontab -e 查看系统计划crontab -l 自定义一个系统计划crontab 格式说明 crontab 命令示例40 8 * * * /home/hufei/parse-all.py &gt;&gt; /home/hufei/out-all.file 2&gt;&amp;1 40 8 * * * 每天的 8 点 40 分 &gt; 表示覆盖 &gt;&gt; 表示追加 1 表示 stdout 标准输出，系统默认值是 1 2 表示 stderr 标准错误 &amp; 表示等同于的意思 2&gt;&amp;1 表示 2 的输出重定向等同于 1 实现效果分享内容的格式 钉钉通知消息的格式 引用 钉钉自定义机器人 Requests BeautifulSoup python 入门教程 每天一个 linux 命令：crontab 命令 linux 往文件末追加行","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"钉钉","slug":"钉钉","permalink":"//huminxi.netlify.com/tags/钉钉/"},{"name":"dingtalk","slug":"dingtalk","permalink":"//huminxi.netlify.com/tags/dingtalk/"}]},{"title":"DNS","slug":"DNS","date":"2018-03-03T02:19:27.000Z","updated":"2019-05-17T15:39:21.052Z","comments":true,"path":"2018/03/03/DNS/","link":"","permalink":"//huminxi.netlify.com/2018/03/03/DNS/","excerpt":"我们知道，身份证号码可以唯一标识一个人。但我们在相互介绍时通常不会使用身份证号码，而是报上姓名。因特网上的主机也和人类一样，有一个可以唯一标识的 IP 地址，同时，它们也有一个主机名(hostname)，如 www.google.com www.wikipedia.org 等。由于计算机只认识 IP 地址，所以我们需要一种能将主机名转换到 IP 地址的 目录服务，这就是 DNS(Domain Name System)，也称域名系统。","text":"我们知道，身份证号码可以唯一标识一个人。但我们在相互介绍时通常不会使用身份证号码，而是报上姓名。因特网上的主机也和人类一样，有一个可以唯一标识的 IP 地址，同时，它们也有一个主机名(hostname)，如 www.google.com www.wikipedia.org 等。由于计算机只认识 IP 地址，所以我们需要一种能将主机名转换到 IP 地址的 目录服务，这就是 DNS(Domain Name System)，也称域名系统。 什么是 DNS概念 一个由分层的 DNS 服务器(DNS server)实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 DNS 服务器通常是运行 BIND(Berkeley Internet Name Domain) 软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用的端口号为 53。 使用场景DNS 经常被其它应用层协议所使用，包括 HTTP、SMTP 和 FTP，将用户提供的主机名解析为 IP 地址。举个例子，当某个用户主机上的一个浏览器(即一个 HTTP 客户端)请求 URL www.huminxi.com/index.html 页面时会发生什么动作。为了使用户的主机能够将一个 HTTP 请求报文发送到 Web 服务器 www.huminxi.com，该用户主机必须获得 www.huminxi.com 的 IP 地址。其做法如下 用户主机上启动 DNS 客户端。 浏览器从上述 URL 中抽取出主机名 www.huminxi.com 并将这台主机名传给 DNS 客户端。 DNS 客户端向 DNS 服务器发送一个包含主机名的查询报文。 DNS 客户端最终会收到一份回答报文，其中包含主机名对应的 IP 地址。 一旦浏览器得到 DNS 客户端解析出来的 IP 地址，它就能够向位于该 IP 地址 80 端口的 HTTP 服务器进程发起一个 TCP 连接。 从这个例子中，我们可以看到 DNS 给使用它的因特网带来了额外的时延(而且有时候还不低)。除了进行主机名到 IP 地址的转换之外，DNS 还提供了一些重要的服务 主机别名(host aliasing) 有着复杂主机名的主机能拥有一个或多个别名。例如，一台名为 relay1.west-coast.enterprise.com 的主机，可能还有两个别名为 enterprise.com 和 www.enterprise.com。 在这种情况下 relay1.west-coast.enterprise.com 也称为 规范主机名(canonical hostname)。别名比规范名更加容易记忆。应用程序可以调用 DNS 服务来获取主机别名对应的规范主机名以及主机的 IP 地址。 邮件服务器别名(mail server aliasing) 显而易见，人们也希望电子邮件地址好记忆。例如，如果 huminxi 在 Gmail 上有一个账户，那邮箱地址就像 huminxi@gmail.com 这样简单。然而，Gmail 邮件服务器的规范主机名可能十分复杂，不像 gmail.com 这样简单好记(电子邮箱地址格式为 user@server)。电子邮件应用程序可以调用 DNS 服务，对邮件服务器别名进行解析，以获得该主机的规范主机名及其 IP 地址。事实上，MX 记录允许一个公司的邮件服务器和 Web 服务器使用相同的主机别名。例如，一个公司的 Web 服务器和邮件服务器都叫做 enterprise.com。 负载分配(load distribution) DNS 可以用于冗余服务器之间的负载分配。繁忙的站点(如 cnn.com)被冗余分布在多台服务器上，每台服务器运行在不同的端系统上，每个都有着不同的 IP 地址。由于这些冗余 Web 服务器的存在，一个规范主机名可能与一个 IP 地址集合相关联。DNS 数据库中存储着这些 IP 地址集合。当客户发出一个 DNS 请求时，该 DNS 服务器会用 IP 地址的整个集合进行响应，但在每个回答中循环这些地址的次序(客户通常是向排在最前面的 IP 地址服务器发送 HTTP 请求报文)。 DNS 解析代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; char *ptr, **pptr; struct hostent *hptr; char str[32]; ptr = argv[1]; if((hptr = gethostbyname(ptr)) == NULL) &#123; printf(\" gethostbyname error for host:%s\\n\", ptr); return 0; &#125; printf(\"official hostname:%s\\n\",hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf(\" alias:%s\\n\",*pptr); switch(hptr-&gt;h_addrtype) &#123; case AF_INET: case AF_INET6: pptr=hptr-&gt;h_addr_list; for(; *pptr!=NULL; pptr++) printf(\" address:%s\\n\", inet_ntop(hptr-&gt;h_addrtype, *pptr, str, sizeof(str))); printf(\" first address: %s\\n\", inet_ntop(hptr-&gt;h_addrtype, hptr-&gt;h_addr, str, sizeof(str))); break; default: printf(\"unknown address type\\n\"); break; &#125; return 0;&#125; DNS 的原理DNS 工作过程概述假设运行在用户主机上的某些应用程序需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 客户端，并指明需要转换的主机名。用户主机上的 DNS 客户端被调用后向网络中发送一个 DNS 请求报文。所有的 DNS 请求和回答报文都使用 UDP 发送。经过若干毫秒的时延后，用户主机上的 DNS 客户端接收到包含映射结果的 DNS 回答报文，这个结果将通知到应用程序。 因此，在调用 DNS 服务的应用程序角度看来，DNS 服务只是一个提供主机名和 IP 地址转换的黑盒子。但事实上，这个黑盒子是非常复杂的，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与 DNS 客户端之间的通信方式的应用层协议组成。 DNS 的实现方式集中式DNS 的一种简单实现是在因特网上只使用一个 DNS 服务器，该服务器包含所有的映射。在这种集中式设计中，客户将所有查询发往单一的 DNS 服务器，同时该 DNS 服务器直接对所有的查询做出响应。尽管这种设计的简单性十分突出，但它不适用于当今的因特网，因为因特网有着数量巨大(并且持续增长)的主机。这种集中式设计的问题如下 单点故障(a single point of failure) 如果该 DNS 服务器崩溃，整个因特网随之瘫痪！ 通信容量(traffic volume) 单个 DNS 服务器必须要处理所有的 DNS 查询(用于数十亿台主机产生的 HTTP 报文和电子邮件报文等)。 远距离的集中式数据库(distant centralized database) 单个 DNS 服务器不可能『临近』所有查询客户。如果我们将单台 DNS 服务器放在纽约市，那么所有来自澳大利亚的查询必须传播到地球的另一边，中间也许还要经过低速和拥塞的链路，这将导致严重的时延。 维护(maintenance) 单个 DNS 服务器必须要为所有的因特网主机保留记录。这不仅将使这个中央数据库非常庞大，而且它需要频繁更新(每添加一台主机)。 总的来说，在单一 DNS 服务器上运行集中式数据库完全没有可扩展能力。因此，DNS 采用了分布式的设计方案。 分布式层次结构为了处理扩展性问题，DNS 使用了大量的 DNS 服务器，它们以层次方式组织，并且分布在全世界范围内。大致来说，有 3 种类型的 DNS 服务器：根服务器、顶级域(Top-Level Domain，TLD)服务器和权威服务器。这些服务器以下图所示的层次结构组织起来。 DNS 服务器的层次结构 为了理解这 3 种类型的 DNS 服务器交互的方式，我们来举个例子。假定一个 DNS 客户要查询主机名为 www.amazon.com 的 IP 地址。客户首先与根服务器之一联系，它将返回顶级域名 com 的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一联系，它将为 amazon.com 返回权威服务器的 IP 地址。最后，客户与 amazon.com 权威服务器之一联系，它返回主机名 www.amazon.com 的 IP 地址。 各种类型的 DNS 服务器介绍 根 DNS 服务器 在因特网上有 13 个根 DNS 服务器(标号为 a-m，主机名格式为 字母.root-servers.net)。13 个根域名服务器 IP 列表 顶级域 DNS 服务器 这些服务器负责顶级域名如 com、org、net、edu、gov 等，以及所有国家的顶级域名如 uk、fr、jp、cn 等。所有顶级域列表 权威 DNS 服务器 在因特网上具有公共可访问主机(如 Web 服务器和邮件服务器)的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构能够选择实现它自己的权威 DNS 服务器以保持这些记录；或者支付费用，让这些记录存储在某个服务提供商(如阿里)的一个权威 DNS 服务器中。多数大学和大公司实现和维护他们自己的权威 DNS 服务器。 验证根 DNS 服务器的 IP 地址 本地 DNS 服务器除了上述几种 DNS 服务器。还有另一类重要的 DNS 服务器，称为本地 DNS 服务器(local DNS server)。一个本地 DNS 服务器严格来说并不属于 DNS 服务器的层次结构，但它却极为重要。每个 ISP(Internet Service Provider，如一个大学、一个公司或一个居民区)都有一台本地 DNS 服务器(也叫默认 DNS 服务器)。 mac 上使用 cat /etc/resolv.conf 命令查看默认的 DNS 服务器地址 一般来说，主机的本地 DNS 服务器通常『临近』本主机。对于某个 IPS 而言，本地 DNS 服务器可能就与主机在同一个局域网中；对于某居民区 ISP 来说，本地 DNS 服务器通常与主机相隔不超过几台路由器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求发送到 DNS 服务器层次结构中。 怎么理解上述这段话，我们来看一个简单的例子。假设主机 cis.poly.edu 想知道主机 gaia.cs.umass.edu 的 IP 地址。同时假设 cis.poly.edu 的本地 DNS 服务器为 dns.poly.edu，gaia.cs.umass.edu 的权威 DNS 服务器为 dns.umass.edu。 图 2-21 各种 DNS 服务器之间的交互 如上图所示，主机 cis.poly.edu 首先向它的本地 DNS 服务器 dns.poly.edu 发送一个 DNS 查询报文，报文中含有待转换的主机名 gaia.cs.umass.edu。 本地 DNS 服务器将该报文转发到根 DNS 服务器。根 DNS 服务器注意到其 edu 前缀并向本地 DNS 服务器返回负责 edu 的 TLD 的 IP 地址列表。 本地 DNS 服务器再向这些 TLD 服务器之一发送查询报文。该 TLD 服务器注意到 umass.edu 前缀，并返回权威 DNS 服务器的 IP 地址列表。 最后，本地 DNS 服务器向 dns.umass.edu 重发查询报文， dns.umass.eud 用 gaia.cs.umass.edu 的 IP 地址进行响应。 注意，在本例中，为了获得一台主机名的映射，共发送了 8 份 DNS 报文：4 份查询报文和 4 份回答报文。 而且例子中的 TLD 服务器知道主机的权威 DNS 服务器的 IP 地址。一般而言，这种假设并不正确。相反，TLD 服务器只是知道中间的某个 DNS 服务器，该中间的 DNS 服务器依次才能知道用于该主机的权威 DNS 服务器。 所以正常情况下，我们发送的 DNS 报文将不止 8 份！ 图 2-21 所示的例子利用了递归查询(recursive query)和迭代查询(iterative query)。从 cis.poly.edu 到 dns.poly.edu 发出的查询是递归查询，而后继的 3 个查询是迭代查询。从理论上讲，任何 DNS 查询既可以是迭代的也可能是递归的。例如，图 2-22 显示了一条 DNS 查询链，其中的所有查询都是递归的。实际中，一般都是遵循图 2-21 中的模式。从请求主机到本地 DNS 服务器的查询是递归的，其余的查询是迭代的。 图 2-22 DNS 中的递归查询 DNS 缓存在图 2-21 的例子中，我们注意到，为了获得一台主机名的映射，我们共发送了 8 份报文，效率实在太低了！ 实际上，为了改善时延性能并减少因特网上到处传输的 DNS 报文数量， DNS 广泛使用了缓存技术。 DNS 缓存的原理十分简单。在一个请求链中，当某 DNS 服务器接收到一个 DNS 回答时(例如，包含主机名到 IP 地址的映射)，它能将该回答中的信息缓存在自己的存储器中。这样，下次再有相同的 DNS 请求时，可以直接将缓存的内容作为 DNS 回答发送过去，即使它不是该主机名的权威服务器。由于主机名与 IP 地址间的映射并不是永久的，DNS 服务器一般会给缓存设置一个超时时间(通常设置为两天)。这就是本地 DNS 服务器为什么如此重要的原因。 DNS 记录实现 DNS 分布式数据库的所有 DNS 服务器存储着资源记录(Resource Record，RR)，RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。资源记录是一个包含了下列字段的 4 元组: [Name, Value, Type, TTL] TTL 是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name 和 Value 的值取决于 Type: Type = A，Address Mapping record，则 Name 是个主机名，Value 是该主机名对应的 IP 地址。例如(relay1.bar.foo.com, 145.37.93.126, A)就是一条类型 A 记录。 Type = CNAME，Canonical Name record，则 Value 是别名为 Name 的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名。例如(foo.com, relay1.bar.foo.com, CNAME)就是一条 CNAME 类型的记录。 Type = MX，Mail exchanger record，则 Value 是别名为 Name 的邮件服务器的规范主机名。例如(foo.com, mail.bar.foo.com, MX)就是一条 MX 记录。… 阿里提供的 DNS 解析 现在，大家应该对 DNS 这三个字不陌生了吧。 扩展hosts 文件 和 DNS 之间是什么关系 hosts 文件（域名解析文件）是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名称映射到相应的 IP 地址。hosts 文件通常用于补充或取代网络中 DNS 的功能。和 DNS 不同的是，计算机的用户可以直接对 hosts 文件进行控制。 最初在 Internet 的前身 ARPANET 中，其成员 SRI International 手动维护并分享了一个名为 HOSTS.TXT 的文件，其中就包括主机名称和对应地址。1983 年 DNS 系统开始开发，1984 年得到了发展。在网络快速的发展过程中，DNS 可以自动提供动态的主机名解析。不过在现代操作系统，hosts 文件仍然是一个可以作为备用手段的名称解析机制。 查看 DNS 解析的具体过程1dig +trace www.huminxi.com 引用 《计算机网络:自定向下方法》 根域名服务器 gethostbyname() 函数说明 TYPES OF DNS RECORDS, DNS SERVERS AND DNS QUERY TYPES hosts 文件 主机名命名规范","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"//huminxi.netlify.com/tags/DNS/"},{"name":"协议","slug":"协议","permalink":"//huminxi.netlify.com/tags/协议/"}]},{"title":"我眼中的互联网","slug":"我眼中的互联网","date":"2018-02-17T03:37:35.000Z","updated":"2018-12-18T10:29:08.069Z","comments":true,"path":"2018/02/17/我眼中的互联网/","link":"","permalink":"//huminxi.netlify.com/2018/02/17/我眼中的互联网/","excerpt":"我们每天都在使用的互联网，你是否好奇，它是如何实现的？全世界接入互联网的终端设备有几十亿台，为什么你的电脑能从中准确的找到小伙伴的电脑，然后相互进行通信？如果让你从零开始设计能使全球的终端设备互联互通的计算机网络，你会怎么实现？","text":"我们每天都在使用的互联网，你是否好奇，它是如何实现的？全世界接入互联网的终端设备有几十亿台，为什么你的电脑能从中准确的找到小伙伴的电脑，然后相互进行通信？如果让你从零开始设计能使全球的终端设备互联互通的计算机网络，你会怎么实现？ 什么是互联网我们先来看一张图 互联网的组成 名词解释: Mobile Network 移动网络 National or Global ISP 国家或全球 ISP ISP Internet Service Provider 互联网服务供应商 Home Network 家庭网络 Local or Regional ISP 本地或区域 ISP Enterprise Network 公司网络 Host 主机 end system 端系统 Server 服务器 Mobile 移动设备 Router 路由器 Link-Layer switch 链路层交换机 Modem 调制解调器 Base station 基站 Smart phone 智能手机 Cell phone tower 蜂窝电话塔 互联网是指由若干个电子计算机网络相互连接而成的更大的网络，即网络的网络。 互联网的结构概述 互联网分为多层，每一层都有自己的功能。上层与下层之间的关系就像建筑物一样，上层需要来自下层的支持。 为了统一某一层的功能，大家在具体实现这一层的时候就需要遵守共同的规则，或者叫『协议』(protocol)。 越下面的层，越靠近硬件；越上面的层，越靠近用户。 网络分层 Physical Layer搭建一个网络，第一件事要干什么？ 当然是先把电脑们连接起来，可以用光缆、电缆、双绞线、无线电波等方式。 连接电脑 光缆 电缆 双绞线 无线电波 这就叫做『实体层』，它是把电脑连接起来的物理手段，主要作用是负责传送 0 和 1 的电信号。 Link Layer有了『实体层』，现在我们已经能互相传递 0 和 1 了。假设： 你传 0101010101010010101010101010010101010101001101010100110100100101001 给我，我回 1001000010101010101000010100011111110001010101010010101010101001010 给你。 但是，这一连串的 0 和 1 该怎么解读呢，是不是看的一脸懵逼？ 这是因为我们还缺一个将 0 和 1 分组的方式。 Frame早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做『以太网』(Ethernet)的协议，占据了主导地位。以太网规定，一组电信号构成的一个数据包，叫做『帧』(Frame)。每一帧分成两个部分：Head 和 Data。 Frame IEEE 802.3以太网帧结构 名词解释: Octet 八位元组 （像 11110000 就是一个 octet） Preamble 序文 (由 7 个 10101010 和 1 个 10101011 组成) SFD Start Frame Delimiter 帧首定界符 (1 个 octet 10101011) Destination MAC 目的 MAC 地址 MAC Media Access Control Address 以太网地址 Source MAC 源 MAC 地址 802.1Q Header 可选字段 EtherType 以太类型 Payload 有效载荷 (42-1500 个 octet) CRC Cyclic Redundancy Check 循环冗余校验 FCS Frame Check Sequence 帧检查序列 Inter Frame Gap 帧间间隔 MAC1990 年代的以太网网卡或叫 NIC（Network Interface Card，以太网适配器）。这张卡可以支持基于同轴电缆的 10BASE2 (BNC 连接器，左)和基于双绞线的 10BASE-T（RJ-45，右）。 以太网网卡 每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。前 6 位由 IEEE 决定如何分配，后 6 位由实际生产该网络设备的厂商自行指定。 MAC 地址 mac 上可以用 ifconfig 命令查看 MAC 地址 MAC 地址现在已经定义好了。 那么下一个问题来了：一块网卡怎么会知道另一块网卡的 MAC 地址？其实，在每台安装有 TCP/IP 协议的电脑或路由器里都有一个 ARP 缓存表，表里的 IP 地址与 MAC 地址是一一对应的。如下表所示： 主机名称 IP 地址 MAC 地址 A 192.168.38.10 00-AA-00-62-D2-02 B 192.168.38.11 00-BB-00-62-C2-02 C 192.168.38.12 00-CC-00-62-C2-02 … … … 以主机 A（192.168.38.10）向主机 B（192.168.38.11）发送数据为例。 当发送数据时，主机 A 会在自己的 ARP 缓存表中寻找是否有目标 IP 地址。 如果有，直接把目标 MAC 地址写入帧里面发送就行。 如果没有，主机 A 就会在网络上发送一个广播（ARP request）。 目标 MAC 地址是『FF.FF.FF.FF.FF.FF』，这表示向同一网段内的所有主机发出这样的询问：『192.168.38.11 的 MAC 地址是什么？』 网络上其他主机并不响应 ARP 询问，只有目标主机 B 接收到这个帧时，才向主机 A 做出这样的回应（ARP response）：『192.168.38.11 的 MAC 地址是 00-BB-00-62-C2-02』。 这样，主机 A 就知道主机 B 的 MAC 地址，它就可以向主机 B 发送信息。同时它还更新自己的 ARP 缓存表，下次再向主机 B 发送信息时，直接从 ARP 缓存表里查找就可。ARP 缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少 ARP 缓存表的长度，加快查询速度。 这就是『ARP协议』原理的简单描述。 mac 上可以用 arp -a 命令查看 ARP 缓存表 这就是『链接层』的功能，它在『实体层』的上方，确定了 0 和 1 的分组方式，它的数据包被称为 Frame。 Network Layer有了以太网协议，我们依靠 MAC 地址来发送数据。理论上，全世界的电脑互联互通已经可以实现了。还有什么不足吗？ 有的，这样做有一个重大的缺陷：如果两台计算机不在同一个子网络，广播是传不过去的！ 那为什么不设计一个超级大的子网络呢？因为以太网采用广播方式查询未知计算机的 MAC 地址，所有成员人手一帧。就算可以设计一个超级子网，那么互联网上每一台计算机都收到所有帧，这将会是一个灾难。 因此，必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络。如果是同一个子网络，就采用广播方式发送，否则就采用『路由』方式发送。（这里的『路由』指的是如何向不同的子网络分发数据包）遗憾的是，MAC 地址本身无法做到这一点——它只与厂商有关，与所处网络无关。 这就导致了『网络层』的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做『网络地址』，简称『网址』。 IP规定网络地址的协议，叫做 IP 协议。它所定义的地址，就被称为 IP 地址。目前，广泛采用的是 IP 协议第四版，简称 IPv4。这个版本规定，网络地址由 32 个二进制位组成。 IP 地址 习惯上，我们用分成四段的十进制数表示 IP 地址，从 0.0.0.0 一直到 255.255.255.255(一些特殊的 IP 地址)。互联网上的每一台计算机，都会分配到一个 IP 地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP 地址 172.16.254.1，这是一个 32 位的地址，假定它的网络部分是前 24 位（172.16.254），那么主机部分就是后 8 位（上图的 IP 地址的主机就是最后的那个 1）。 Subnet Mask那么问题来了：怎样才能从 IP 地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数『子网掩码』（subnet mask）。 所谓『子网掩码』，就是表示子网络的一个参数。它在形式上和 IP 地址类似。但它有个显著的特点（记下来，要考） 『它的网络部分全部为 1，主机部分全部为 0!』 比如，IP 地址 172.16.254.1，如果已知网络部分是前 24 位，主机部分是后 8 位，那么『子网掩码』就是 11111111.11111111.11111111.00000000，写成十进制就是 255.255.255.0。知道了『子网掩码』，我们就能判断，任意两个 IP 地址是否处在同一个子网络。方法是将两个 IP 地址与『子网掩码』分别按位进行 AND 运算（两个数都为 1，则运算结果为 1，否则为 0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 Q 已知 IP 地址 172.16.192.1 和 172.16.254.233 的子网掩码都是 255.255.192.0，请问它们是否在同一个子网络？ A 将两者分别与子网掩码进行 AND 运算，结果都是 172.16.192.0，因此它们在同一个子网络中。 DatagramIP 数据包也分为 Head 和 Data 两个部分。Head 部分主要包括协议版本、数据包长度、IP 地址等信息，Data 部分则是 IP 数据包的具体内容。 IP 数据包中一定包含了 IP 地址。但是前面说过，以太网数据包的 Head 里面只包含 MAC 地址，并没有 IP 地址的栏位。那么是否需要修改以太网数据包的 Head 定义，再添加一个栏位来存放 IP 地址信息呢？ 回答是不需要，我们可以把 IP 数据包直接放进以太网数据包的 Data 部分，因此完全不用修改以太网数据包的定义。这就是互联网分层结构的好处：『上层的变动完全不涉及下层的结构』。它放进以太网数据包后，以太网数据包就变成了下面这样。 Datagram IP 数据包的 Head 部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65535 字节。因此，理论上，一个 IP 数据包(Datagram) 的 Data 部分，最长为 65515 字节。前面说过，以太网数据包(Frame)的 Payload 部分，最长只有 1500 字节。因此，如果一个 IP 数据包超过了 1500 字节，它就需要分割成几个以太网数据包，分开发送了。 『网络层』在『链接层』的上层。它的作用主要有两个，一个是为每一台计算机分配一个网络地址；另一个是确定哪些网络地址在同一个子网络。它的数据包被称为 Datagram。 Transport Layer有了 MAC 地址和 IP 地址的情况下，我们已经可以在互联网上任意两台主机上建立通信。为什么还要传输层呢？ 这是因为在同一台主机上将会有许多程序都需要用到网络。比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，计算机怎么知道，它是表示网页的内容，还是表示在线聊天的内容？也就是说，我们还需要一个参数, 来表示这个数据包到底供哪个程序（进程）使用。 Port这个参数就叫做『端口』(port)，由 16 位二进制表示（0-65535），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 0-1023 号端口被称为 知名端口（well-known port）。这些知名端口号由 IANA 分配。用户只能选用 1024-65535 之间的一个端口号。不管是浏览网页还是在线聊天，应用程序随机选用一个端口，然后与服务器的相应端口联系。 UDP现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做 UDP(User Datagram Protocol) 协议，它的格式几乎就是在数据前面加上端口号。 UDP 数据包，也是由 Head 和 Data 两部分组成。Head 部分定义了发出端口和接收端口，Data 部分就是具体的内容。 整个 UDP 数据包放入 IP 数据包的 Data 部分，而前面说过，IP 数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： Segment UDP 数据包最长可为多少字节？ UDP 数据包非常简单，Head 部分一共只有 8 个字节，总长度不超过 65515 字节，正好放进一个 IP 数据包的 Data 部分。 TCP 在 TCP/IP 模型中，UDP 为网络层以上和应用层以下提供了一个简单的接口。UDP 只提供数据的不可靠传递，它一旦把应用程序包装给网络层的数据发送出去，就不保留数据备份（所以 UDP 有时候也被认为是不可靠的数据报协议）。UDP 在 IP 数据报的头部仅仅加入了复用和数据校验（字段）。 为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的 UDP 协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。TCP 数据包和 UDP 数据包一样，都是内嵌在 IP 数据包的 Data 部分。TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割。 Segment传输层的数据包，被称为 Segment。 『传输层』的功能，就是建立『端口到端口』的通信。相比之下，『网络层』的功能是建立『主机到主机』的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把 主机 + 端口，叫做『套接字』（socket）。有了它，我们就可以开发网络应用程序了。 Application Layer应用程序成千上万，而『应用层』的作用，就是规定应用程序的数据格式。常见的应用层协议如下: HTTP(HyperText Transfer Protocol) 缺省 TCP 80 端口，用于浏览器浏览网页。但网页内容为明文，易被篡改、易被劫持、网页内容易泄露 HTTPS(HyperText Transfer Protocol Secure) HTTPS 中的 S 代表 Security，缺省工作于 TCP 443 端口，原理是在 HTTP 与 TCP 层之间多了一个安全加密的夹层，称之为 SSL(Secure Socket Layer)，用于加密基于 HTTP 的网页内容，不易篡改、不易劫持、网页内容保密，目前广泛用于网上银行、网上支付等业务。但有安全漏洞，容易受中间人攻击 SMTP(Simple Mail Transfer Protocol) 用于发送邮件的基于 TCP 的应用层协议 POP3(Post Office Protocol - Version 3) 用于接受邮件的基于 TCP 的应用层协议 DNS(Domain Name System) 用于将域名解析成 IP 地址的基于 UDP/TCP 的应用层协议 DHCP(Dynamic Host Configuration Protocol) 用于主机动态获取 IP 地址、缺省网关、DNS 服务器等参数的基于 UDP 的应用层协议 NFS(Network File System) 用于 Unix/Linux 文件共享，基于 UDP/TCP 的应用层协议 NTP(Network Time Protocol) 用于时钟同步的基于 UDP 的应用层协议 RTP(Real Time Protocol) 用于 IP 多媒体电话的语音、文字、视频等流体的传输，基于 UDP 的应用层协议 Message 『应用层』是最高的一层，直接面对用户。它的数据包被称为 Message。 总结我们最后来看一张图 应用程序之间的消息传输过程 网络应用程序之间需要交换的 Message 由源终端的 Application Layer 开始，层层包装，最后形成一个个 Frame。Frame 经由若干个 Link-layer switch 和 Router 的传输，送达到目的终端。再由目的终端的 Physical Layer 开始，层层解析，最终把 Message 交付给目标应用程序。至此，网络应用程序之间就完成了一次 Message 的传输。 为什么要这样设计 为什么互联网要采用分层设计 网络层的作用是什么 如果重头开始设计互联网，你还会分这么多层吗 引用 互联网协议入门一 IEEE 802.1Q MAC 地址 NIC UDP 知乎提问：现在仍然活跃的应用层协议有哪些？ 直播相关 一些特殊的 IP 地址 ARP 地址解析协议原理及应用 IPv6","raw":null,"content":null,"categories":[{"name":"网络","slug":"网络","permalink":"//huminxi.netlify.com/categories/网络/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"//huminxi.netlify.com/tags/Internet/"},{"name":"互联网","slug":"互联网","permalink":"//huminxi.netlify.com/tags/互联网/"}]},{"title":"转载：学习一下德国人民的翻墙精神","slug":"转载：学习一下德国人民的翻墙精神","date":"2018-02-10T05:12:40.000Z","updated":"2018-12-10T10:49:00.204Z","comments":true,"path":"2018/02/10/转载：学习一下德国人民的翻墙精神/","link":"","permalink":"//huminxi.netlify.com/2018/02/10/转载：学习一下德国人民的翻墙精神/","excerpt":"最近常听到有人抱怨翻墙太麻烦，俺心里就嘀咕：你要是知道当年德国人民翻墙的艰辛和危险，或许就不会再抱怨翻 GFW 这堵墙的麻烦了。说到德国人的翻墙，比较关心政治的同学应该会联想到大名鼎鼎的 柏林墙。从某种意义上看，东德共党在 60 年代建造的柏林墙和中国共党在 21 世纪架设的 GFW 真是具有异曲同工之妙——两堵『墙』都是用来阻止本国人民对自由的追求。各位同学们目前的处境，和当年东德老百姓的处境也很类似——都在挖空心思琢磨 翻墙之术。","text":"最近常听到有人抱怨翻墙太麻烦，俺心里就嘀咕：你要是知道当年德国人民翻墙的艰辛和危险，或许就不会再抱怨翻 GFW 这堵墙的麻烦了。说到德国人的翻墙，比较关心政治的同学应该会联想到大名鼎鼎的 柏林墙。从某种意义上看，东德共党在 60 年代建造的柏林墙和中国共党在 21 世纪架设的 GFW 真是具有异曲同工之妙——两堵『墙』都是用来阻止本国人民对自由的追求。各位同学们目前的处境，和当年东德老百姓的处境也很类似——都在挖空心思琢磨 翻墙之术。 翻越柏林墙的故事 “自由有许多困难，民主亦非完美，然而我们从未建造一堵墙把我们的人民关在里面，不准他们离开。”——肯尼迪《柏林墙下的演说》，1963年6月25日于西德市政厅柏林墙前。 德国的柏林墙是东德于1961年在自己的领土上建立的围墙，目的是不让东德人逃入西柏林，在柏林墙建立之前，大约有250万东德人逃入西柏林，1990年柏林墙被拆除，随后东德加入了联邦德国，两德实现了统一。 肯尼迪曾评价柏林墙是“世界上第一堵不是用于抵御外敌，而是用来对付自家百姓的墙”。但是对于德国人来说，柏林墙所代表的不是肯尼迪，冷战这样的大字眼，而是数以万计小人物的故事，这些小人物在这堵墙边，用自己的生命，造就了人类历史上的一个传说，这个传说的名字，叫做“自由”。 仅在此记录自己了解到的一些故事。常觉得，我国和西方的历史，记录很不一样。在我国的历史记录里，少有这样详尽，乃至繁琐的小人物的记录。所以读西方的历史，经常觉得过于平淡，过于拘泥细节而不见大方向。然而，却自有一种力量在。柏林墙的故事，在西方的历史里，感觉不但不惊天动地，或者剑拔弩张，反而竟然多有幽默。当然，是黑色幽默。 又一个『中国长城』 万没有想到，在柏林墙纪念馆会读到我们中国的名字。柏林墙工程的代号，就是“中国长城第二”。 1961年8月，一个沉闷的夏天。对于大量东德人经柏林逃往西方已经忍无可忍的东德人和苏联人搞了一个漂亮的偷袭。8月12日凌晨1点，2万多军队突然开到东西柏林边境，立刻开始了修筑柏林墙的工程。应该说，这个以我国长城命名的工程，准备还是很充分的，绝对不是豆腐渣工程。仅仅到13日凌晨，第一期工程全部完工，整个东西柏林被铁丝网全部分割，再加路障。柏林墙正式树立了起来。 不过上帝实在会开玩笑，就在柏林墙的修筑过程中，东德人就开始了翻越柏林墙，逃亡西德的“柏林墙传说”。东德人的争分夺秒，只争朝夕的精神，给柏林墙的历史研究留下了千古之迷，到底是先有柏林墙，再有翻越行动，还是未等墙树起来，就已经开始了翻越，竟然永远无法得到一个答案了。 历史记载，柏林墙初步完成，即东西柏林正式分割，在13日中午12点37分，最后一个路口宣布封锁为标志。但就在13日，最早明白过来的东德人已经开始用生命搏击柏林墙，当天，一位技工跨过正在树立的铁丝网跳进了西柏林，有人跳进运河游到了西柏林。然而，天意弄人，谁也没想到记录他们踏上西德领土的时间。 13日上午，西德人涌向柏林墙，向墙那边的同胞投掷自己的通行证，身份证件。到苏联军队能够阻止这一举动前，数以千计的证件已经被扔到了东德同胞的手里。大批东德人借机混在返回西柏林的西德人中间偷渡逾越了柏林墙。 13日下午，柏林墙树立以后，第一个逾越柏林墙的人出现了。一个青年在光天化日之下，用百米冲刺的速度飞奔向铁丝网。但是，三名警察追上了他，将他打倒在地，谁也没有想到，被打倒的他竟奇迹般又站了起来，夺过警察的枪，一边与警察对峙一边继续向西柏林飞奔。警察是尽职的，他们不顾这个年轻人的枪，冲上去和他又一次扭打成一团，并且一刀刺进青年人的膝盖。这次这个年轻人失去了奔跑的能力，面对三个警察，结局已经注定。 然而，上天决心要给大家看一幕喜剧而不是悲剧。就在此刻，西柏林群众雷鸣般的怒吼惊醒了三名警察，他们已经越过了柏林墙，现在是在西德的土地上，他们不再是警察，而成了违法者。他们扔下青年跑回柏林墙的另一侧。这个青年拖著残废的腿，一边拼命呼救一边爬到了西柏林。 事后证明，这是一个大大的误会。事实上柏林墙并不是沿东德西德的边境修筑的，而是偏东德一侧，这是为了保证，即使你越过了柏林墙，你仍然在东德土地上，警察和军队仍然有权力和能力开枪将你击毙。当时那三位警察并没有越界，他们大可以合法将那个青年绑回东德。然而，面对这柏林墙上的第一次交锋，他们误会了，害怕了，那个青年简直是奇迹般的竟然这样逃脱了已经笼罩住了自己的厄运。这是第一个通过柏林墙的逃亡者。也许这第一个人就定下了逃亡柏林墙故事的基调。 在柏林墙传说里，有眼泪、有悲壮、有无奈；但同样也有幽默、滑稽和令人含泪微笑的故事。 最可爱的人 写可爱是容易的，面对冷酷的现实，人类用自己的信心，幽默来反抗，说起来即使是最大的冷酷，也压不下那希望和温暖。然而要写悲惨，实有些下不了笔。 柏林墙的逃亡者中，那些“功败垂成”者无疑是悲惨的。1961年，18岁的彼得·菲西特就是这么一个人。他已经爬到了柏林墙的顶部，只需要再加最后一把劲，就可以达成目标，就在这个时候，枪声响了……彼得滑落回柏林墙东侧。 悲剧还没有完，身中数弹的彼得倒在柏林墙下，血流如注，我不知道东德的警察是一时不敢承担责任，跑去请示上级，还是真的就已经下了杀心（我宁愿相信是前者）。彼得就这样在墙下躺了50分钟，没有一个东德警察前来管他。 彼得的呼喊声一点一点的低下去了，低下去了。西柏林的人群爆发出愤怒的抗议声。“你们是杀人犯！”“你们是法西斯！”上千群众怒吼著。西德的警察冒险跑到柏林墙边（前面已经说过，这是极其危险的，柏林墙西侧依然是东德的土地，警察已经“越界”，完全可能被枪击）把急救包扔向彼得。但是太晚了，彼得已经失去了自救的能力。彼得终于停止了呼吸。他的血已经流尽了，在他蓝眼睛里最后映出的，依然是东柏林。50分钟以后，东德警察抬走了他的尸体。 如果说彼得最大的不幸在于他最终没有成功，我不知道下面这个最后“成功”的例子，是不是算幸运。在柏林墙刚完成的那一年，由于墙还不是很坚固，有人就想出了办法，开重型车辆直接撞墙！直接冲开柏林墙进入西德。1961年，这类事件多达14起。 逃亡者要面对的绝不仅仅是坚固的高墙，还有来自军队和警察的密集射击。有军事常识的朋友都知道，对于穿透力极强的子弹，民用的车壁，车门根本就是nothing，香港电影里躲到小轿车后面就可以逃开对方射击的镜头完全是搞笑。所以，用这个办法冲击柏林墙的人，实际上等于完全不设防的穿行在枪林弹雨中，去争取一次严重交通事故的机会！ 这里的故事太多，最悲惨的，一是在离墙最后一米处熄火的那辆装有数十人的大客车。二就是布鲁希克的故事。 布鲁希克和他的同伙同样是利用大客车冲击柏林墙，但是他们的行动从一开始就被发现了。军队和警察从多个方向向客车密集射击，客车起火燃烧，弹痕累累！还好，客车质量过硬，不但没有熄火，还在布鲁希克良好的驾驶下奋勇加速，一声巨响，柏林墙被撞开了一个大缺口，整个客车冲进了西柏林！ 欢呼的人群拥上来迎接，却被眼前的景象震惊了，驾驶座上的布鲁希克身中19 弹，他是用生命的最后意志坚持加速，冲向柏林墙的。当客车冲进西柏林的那一刻，布鲁希克停止了呼吸。 柏林人展开了一场争论，布鲁希克究竟有没有看到他梦想看到的西柏林？最后是一个现场镜头宽慰了大家，从镜头上看，客车驾驶座位于西柏林之后，布鲁希克还有一个抬头的动作。是的，那时候他还活著！他的眼睛最后映出的，是他梦想中的迦南西柏林！他是一个成功者。 柏林墙在两德统一后完全拆毁，后来联邦政府作了很大努力说服人民同意在原址重建了一段70米的“柏林墙”作为警示，图中十字架是企图越墙者的墓碑，为纪念他们追求自由的勇气把他们葬在这里让人凭吊。在28年中，至少有239人在试图翻越柏林墙或潜渡施普雷河时被枪杀。 这个镜头我也看了，说实话，在那样的动荡，混乱，和快速行驶中，每个人都被颠簸得相当厉害，硬要说那个几乎无法注意到的动作是布鲁希克自己作出来的而不是别的原因，我感觉实在是勉强。但是，谁又愿意继续辩论下去呢？谁又不希望这个年轻人生命的最后时刻能够是快乐呢？德国人如此不严谨的结论很少，却少得可爱，少得美丽。 柏林墙倒塌以后，新建成的文化宫，专门采用了很特殊的设计。建筑之间均用伞状结构连接，整个原来的柏林墙东侧“死亡开阔地”被全部笼罩在保护伞下。成为了伞下的广场。 我的德国同学说，这是因为，在这个广场上，无数逃亡者因为没有任何隐蔽物，只好强行穿越在火力控制下的广场而失去生命。现在，德国终于可以为自己的公民提供隐蔽物了，尽管，已经太迟，太迟…… 我无话可说。 咱们德国人都是工程师 上面那篇太沉重了，来一点轻快的。 德国人的机械设计，制造能力举世闻名，在柏林墙逃亡中，那也是充份体现了德国人民的技术水平。要按现在流行的歌来唱，那就是：“咱们这嘎都是德国人，咱们这嘎特产工程师，咱们这嘎香肠配啤酒，咱们这嘎都是活本茨”（本茨，即奔驰汽车创始人，德国工程师）。 1968年，一位东德青年利用河流潜水到达西德。大家心目中的潜水是什么样的？潜水服？潜水镜？总之他一个人能有多大本事，还一切都必须自己造，最多是一点粗糙的个人潜水工具罢？ 非也，这位青年自己造的是——潜 - 水 - 艇！ 他用的是摩托车马达，配上自己组装的钢板，还有导航，压缩气体等系统。硬是在家造出了一个个人用的小潜水艇。质量如何？我看可以通过ISO9002国际认证。这潜水艇在水下航行了超过5个小时，才从西德那边冒出来，其中没有发生任何事故。有同学说了，5个小时是不是太长了一点？那是没办法的事情，你试试拿个小摩托的马达去潜水看看。 这小潜水艇当然是一个奇迹，该青年的逃亡过程使他立刻在西德找到了工作，各大机械公司竞相聘用该青年为设计师。听说后来他还真在机械设计上大有成就。 不过小潜水艇也就算了，后面来了个更狠的，逃亡中一不小心，楞搞了个吉尼斯记录出来。 1979年某夜晚，从东德一个家庭的后院升起了一个巨大的热气球。气球下面的吊篮里装著两个家庭——两对夫妇和他们的四个孩子。这个气球完全由这两个家庭手工制成，花了数年的时间。在此期间，两个家庭自学成才，从材料学，工程学，气体动力学，气象学……一直到建立家庭实验室，最后成功的在家庭的后院里制作完成了这个高达28米的热气球！ 经调查，此热气球是欧洲历史上最大的热气球，被记入吉尼斯世界记录！ 这个热气球在通过柏林墙的时候，被警察发现了。警察目瞪口呆之余，还算记得开枪射击。这一射击，该气球良好的工艺水准就发挥了出来。逃亡者操纵热气球一下升高到了2800米以上的高空，不但枪打不到，连探照灯都照不到！警察只好紧急呼叫空军支援：“长江长江，我是黄河，你们赶快出动，寻找一个热气球，把它打下来。对！没错！是热气球！重复一遍，热 - 气 - 球！” 苏联空军的“苏”、“米”战机立刻出动，但是热气球在28分钟的飞行以后，已经完成了使命，安全落地。 问题是，当气球被发现以后，两家人决定立刻降落，以避免被战机击落。这一“紧急降落”，就谁也摸不准方向了——降落的地点无法确定。到底是已经到了西德，还是被迫降在东德，谁也不知道。 估计在他们数年的学习中没有心理学的功课，面对未知的前景，8个人都失去了验证的勇气。他们根本不敢走出这个气球，就这样躲在吊篮里长达24小时之久。他们已经没有勇气亲自揭晓自己的命运了。他们唯一能做的，就是祈祷。降落整整24小时以后，军人来了，揭开了气球。他们对这8个逃亡者说出了他们盼望了多少年的话。——“你们自由了，这里是西德领土。” 还有一个地下逃亡的工程也是让人叹为观止。它是一条穿越柏林墙的地下隧道。这条隧道全长145米。距地面距离是12米。就是说，这隧道先如挖井一样，向地底直着往下挖12米深，然后在开始往柏林墙方向挖。隧道的进口，设在一所房子后院的厕所里，而出口是一个老点心面包店的地窖。隧道内部高度不足一米，确切地说，只有70公分。否则，在这种秘密状态下，太多的土将无法化解在屋子里。大量的土用小推车运送到地道口，再拉上井，分散在屋子里。一共有36个青年和一位23岁的女青年参加了这项秘密工程。他们由此营救出了他们的未婚妻和朋友，以及他们全然不认识的家庭。 值得一提的是，这个隧道不是从东柏林往西柏林挖，而是由西柏林往东柏林挖。之所以仍然要秘密地处理挖出来的土，大概是因为在救出所有要救的人之前，仍然需要小心谨慎，不走漏风声：谁知道西柏林是否有东柏林的间谍？ 但问题是，如果从东柏林往西柏林挖，出口可以不必忧虑，反正只要到了西柏林，那里都是自由的土地，都可以光明正大地走出来。但是从西柏林往东柏林挖，出口就必须事先设计好，必须正好是一个隐蔽的出口。 这些西柏林的营救们，是怎样使出口正好挖通在一个房子后院的厕所里的呢？他们又不能公然和秘密警察监视下的东柏林一方联系、讨论；就是秘密联系讨论也不可能公然测量距离、方向和位置；就是公然测量了，又怎样方位、距离分毫不爽地可可从人家后院的厕所里挖出？ 这应当是工于计算、思维精密、办事严谨的德国人逃亡到西柏林的又一个杰作。 这项秘密工程不声不响地进行了六个月。57位东柏林人成功地从这个隧道中出逃。从开始挖土，到逃亡者最后爬出隧道，在12米深的井口下坐着缆绳，始见西柏林的自由天日，人们为这一工程全过程拍下了珍贵的照片。这些照片除了传递当时的作业情况，还向后人传递着另一种信息：救助者们在挖下第一铲土时就知道他们一定会成功，而且只能成功，否则，这些照片随时可以成为治罪的证据。 世上无难事，只要肯钻研 下面这个故事，证明了这个世界上永远有些事情，你是连想象都想象不出来的。 如果让你把一个人藏在小汽车里偷越柏林墙，你会把他藏在哪里？后箱？底盘？座位下面？恐怕没有一个人会想象得出来，把人藏在汽车的引擎部份。不要说那里因为发动机的缘故温度高，废气多，人放那里多半不烫死也憋死，就算没这些问题，您随便掀开哪辆车的引擎盖看看，怎么可能放得下人？ 然而事实证明，那里可以放下一个人，而且这个人可以在引擎旁边至少呆2个小时以上，还保持清醒。9个从引擎中逃亡柏林墙的东德人可以作证。他们的故事甚至连金庸先生描写的什么“缩骨功”也相形见绌。 据资料显示，他们都是把自己扭曲成，成，很难说他们把自己扭曲成什么形状了。总之他们就好象没有骨头，可以随便变形的橡皮泥一样，把自己一点一点的塞进了引擎与盖子之间的缝隙里。然后就这样逾越了柏林墙。到达西柏林以后，他们要用1-2小时的时间，再一点一点把自己“还原”。先出来一条腿，再伸出一个头，逐渐的，一个人的形状硬是从引擎里升了起来。如果放一个快镜头，简直就是《终结者II》的翻版。 在录像上，一大群西德的热心人在旁边帮忙。但是很快，“不许帮忙”就成了规矩。因为逃亡者的姿势实在太古怪，只能由本人来逐渐恢复。没有经验的人只能是越帮越忙。 在香港电影里，警察或者匪徒，经常从人行天桥上一跃而下，正好落在驶过的汽车顶上。这对于我们来说是电影，对于柏林人却是生活的一部份。 凡靠近柏林墙的高楼，都成了东德人“跳楼”的场所。不必担心，这里的跳楼可不是求死，而是求生。只要你爬到楼上，表现出逃亡的意图，西柏林的同胞们就抬著床单蜂拥前来接应。鼓足勇气，一跃而下，只要把握了方向，就可以在空中逾越柏林墙，落到床单上。 当然，不是每个人都有这么高的运动天份的。曾经有一家三口一起跳楼。6岁的孩子成功了，父亲和母亲却摔到了地面，一个伤了内脏，一个伤了脊椎。在短短的跳楼时代，有4个人因跳楼而死亡。 年纪最大的跳楼者是一位77岁的老太太。她在跳下来之前，把自己吓得瘫倒在了地板上。无论大家怎么鼓励，怎么哀求也无法跳下来。就在西柏林人准备失望的散去的时候，一个意外发生了。东柏林的警察发现了情况，冲进了大楼。警察破门的声音给了老太太无穷的动力，她冲向窗口，果断的一跃而下…… 再后来，由于柏林墙西侧仍属于东德，接应的西德人算侵犯了东德领土，跳楼者又改用汽车接应。顶部预先布置的汽车突然冲向柏林墙，跳楼者就把握这一刹那裹著被子飞跃而下，直扑汽车顶部。汽车又马上退回西柏林内部。 直到东德下了决心，把柏林墙东德一侧的高楼全部推平，空出一片几百米的“恐怖区”以后，居然还有人延续了这个跳楼逃亡法。某位德国工程师设计了一个强力弹射装置，从东柏林市内的高楼起跳，“弹”了数百米到达西柏林，然后利用自己制造的降落伞缓缓落地。 柏林墙的倒掉 历史的进程到了1989年下半年，东德已经是强弩之末。由于东德政府70年代以来所实行的指令性经济、农业全面集体化、强力发展重工业、严厉打击国内反对声音的经济、政治政策，导致经济发展几乎停滞，210亿美元的外债债台高筑、东德马克内债累累，环境污染严重，人民生活贫穷压抑，严重的不满情绪早以深深埋伏在社会民心之中。 1989年11月9日，新东德政府开始计划放松对东德人民的旅游限制，但由于当时东德的中央政治局委员君特·沙博夫斯基对上级命令的误解，错误地宣布柏林墙即将开放，导致数以万计的市民走上街头。 这一天，就象上紧了发条的钟表，突然失去指针，滴滴答答的钟声尤在，却不知何始何终——柏林墙的两面人山人海，鸦雀无声。 面对这堵耸立了28年，阻绝两德人民，制造了无数悲欢离合、生死哭歌、惨重牺牲的血墙，人们无法判断的是：当制造它的独裁政府部门和官员辞职的辞职，改选的改选时，柏林墙辞职了吗？它是否仍然戒备森严？它还能随意射杀越墙的逃亡者吗？自动射击装置是否完全解除？密堡暗碉里的岗哨是否仍然轮流值班？带缰绳可以自由追踪100米的警犬是否正严阵以待？ 没有任何官方的媒体报道这些与人们生息密切相关的消息。柏林墙依然无声地矗立着。它两面成千上万被阻隔的人们遥遥相对，心中纵有万马奔腾，脚却不敢越雷池一步。 这是继两次世界大战之后，德国又一个历时转折的关头。而历史在这一瞬间干脆停下了脚步，为的是让人们记住它的沧桑。 不知道渴望自由的人们同这面血墙对视了多久，终于有一个东德的青年人，壮着胆子，往那禁区的空地，试探着，迈出一只脚…… 没有反应。让脚落地，移动身体重心，再迈出另一只脚…… 仍然没有发现任何警戒方面的反应。 小伙子双脚落在东柏林境内的禁区，人，暴露在自动枪击射程之内。 柏林墙两岸，无数双眼睛被这年轻的躯体所抓住，人们不约而同屏神静息等待着……要么枪声乍起，又一具尸体倒卧在血泊中；要么人民淹没、踏碎这围墙。 小伙子不急不徐，却一步千斤，载着两德的万众一心，牵着两德张开的手臂，在众目暌暌之下，从那片社会主义东德境内的边境开阔地，一寸一寸、一米一米走向资本主义西柏林境内。 这应当是德国历史上，街头上最安静最紧张的时刻了。 当小伙子在身前身后人山人海的无声的注视下，终于接近柏林墙，奋力攀上墙顶，预期的枪声仍然没有响起，紧张的人们却沉默得几乎要爆炸。 然后，西柏林一边向这位以命相抵、探试自由的青年人伸出了丛林般的手臂；然后，小伙子双脚结结实实踏上了西柏林自由的土地。 一瞬间，柏林墙两岸人声鼎沸，心旌摇荡，激动的情感潮流如洪水决堤。人们相互拥抱接吻，相互重复诉告着那个刚刚发现的不可思议的事实：柏林墙解放了！它的警卫事实上已然解除！它已经全然不过就是一堵墙而已了！ 两德人们相互拥入对方，成千上万的人们彻夜不眠地享受着亲友重逢的喜悦。两德人民拥满柏林墙墙上墙下墙东墙西，人们举杯相庆，奏乐狂欢，欢乐的自发的庆典持续数日，节日的气氛经久不消。 无论如何，柏林墙的故事已经结束了（而且，是喜剧性的结束）。人间的故事，如柏林墙这般悲惨的并不少，能够最终这样收场的，已经很不错了。 德国人毕竟是幸运的，柏林墙见证了德国人的痛苦，全世界分享了他们的痛苦。他们被关注着。然而，还有那么多的人，他们的痛苦竟然是完全默然的。 柏林墙倒下了，东德人终于获得了他们梦寐以求的自由。然而，类似的悲剧却并没有在这里地球上结束。我们看到在远隔德国万里重洋的另外一个国家，依旧有一堵用来对付自己的百姓的墙巍峨耸立着。 唯一的区别是：大多数人看不到甚至不知道这堵墙。 引用 原文(需翻墙) 科学上网的终极姿势","raw":null,"content":null,"categories":[{"name":"转载","slug":"转载","permalink":"//huminxi.netlify.com/categories/转载/"}],"tags":[{"name":"德国","slug":"德国","permalink":"//huminxi.netlify.com/tags/德国/"},{"name":"翻墙","slug":"翻墙","permalink":"//huminxi.netlify.com/tags/翻墙/"}]},{"title":"计算机的记忆","slug":"计算机的记忆","date":"2018-02-04T06:22:56.000Z","updated":"2019-04-22T07:13:16.165Z","comments":true,"path":"2018/02/04/计算机的记忆/","link":"","permalink":"//huminxi.netlify.com/2018/02/04/计算机的记忆/","excerpt":"人如果没有记忆，那么许多事情将变得很糟糕。例如：当你走出银行大门时，你已经忘记了你的银行卡密码；当你走进考场时，你已经忘记了熬夜刷过的题；当你早晨起床时，你已经忘记了枕边人的姓名。同样的道理，如果计算机失去了记忆。可能昨天刚运行过的代码，今天又需要你手动输入一遍。那么，怎样才能使计算机变得有记忆呢，或者说，怎么才能让计算机拥有存储能力呢？","text":"人如果没有记忆，那么许多事情将变得很糟糕。例如：当你走出银行大门时，你已经忘记了你的银行卡密码；当你走进考场时，你已经忘记了熬夜刷过的题；当你早晨起床时，你已经忘记了枕边人的姓名。同样的道理，如果计算机失去了记忆。可能昨天刚运行过的代码，今天又需要你手动输入一遍。那么，怎样才能使计算机变得有记忆呢，或者说，怎么才能让计算机拥有存储能力呢？ 反馈(feedback) 反馈（英语：Feedback，又称回授），在台湾称为『回馈』，是控制论的基本概念，指将系统的输出返回到输入端并以某种方式改变输入，它们之间存在因果关系的回路，进而影响系统功能的过程。在这种情况下，我们可以说系统『反馈到它自身』。在讨论反馈系统时，因果关系的概念应当特别仔细对待：『对于反馈系统，很难作出简单的推理归因，因为当系统A影响到系统B，系统B又影响到系统A，形成了循环。这使得基于因果关系的分析特别艰难，需要将系统作为一个整体来看待。』反馈可分为负反馈和正反馈。前者使输出起到与输入相反的作用，使系统输出与系统目标的误差减小，系统趋于稳定；后者使输出起到与输入相似的作用，使系统偏差不断增大，使系统振荡，可以放大控制作用。 触发器(flip-flop)电路图我们先来看一个电路图 图 7.14 两个或非门首尾相连形成两个反馈 这个电路上下对称，分别都是一个或门连着一个非门，特别之处在于，它们各自的输出又分别是对方的输入。换句话说，在这个电路里存在着两个反馈，如图 7.14 所示。在一个电路里搞出两个反馈来，你别说，发明它的人还真是挺有想法。 为了更好的分析图 7.14 电路的作用，我们不妨将开关和灯泡也加进这个电路 图 7.15 用来验证或非门反馈功能的完整电路 电路刚接好的时候，你要确保两个开关都是断开的。现在，准备好了吗？我们可要合上开关 R 了！ 我们知道，或门属于那种好好先生，不挑剔，只要有一个输入为 1，它就输出 1 。所以，如图 7.16 所示，闭合 R 就等于 R=1，于是不管 Q 以前是亮还是灭，它现在一定不会发光，即 Q=0。 图 7.16 当 R 闭合 S 断开时，Q 不亮而 Q&#39; 亮 这就完了吗？不会的。因为有反馈的存在，Q=0 紧接着被送到下面。同时，因为 S 也为 0，所以经过或门和非门后，灯泡 Q’ 因为被通上了电而兴奋得满面红光。也就是说，Q’=1。当然，Q’=1 又被反馈到上面。但是，因为 R 已经给或门提供了 1，所以 Q 的状态不会受到影响，整个电路就此处于稳定状态不再改变。 有意思吧？断开 S，合上 R，灯泡 Q 不亮，Q’ 亮着。要我说呢，这还不算什么，更神奇的是，这个时候，即使你断开 R，灯泡 Q 依然不亮，而灯泡 Q’ 依然亮着！再合上 R，再打开、再合上…不管你怎么折腾，Q 和 Q’ 还是那样。 原因很简单，还是那个 图 7.16，你看，因为 Q’=1 被反馈到上面，所以，即使 R 断开，或者再次合上，也不会改变或门的输出，整个电路的状态也不会发生改变。 现在，让我们把注意力转移到电路的下半部分。这一次，我们让 R 一直处于断开状态，将 S 合上。就在一瞬间，所有的事情都颠倒了，灯泡 Q 亮着，而 Q’ 却不亮了！如图 7.17 所示。 图 7.17 当 R 断开 S 闭合时，Q 亮而 Q&#39; 不亮 由于电路是对称的，上下两部分一模一样，所以这件事情也不难理解。一旦你合上开关 S 使得 Q=1 而 Q’=0，往后再怎么摆弄 S，是闭合还是断开，都不会再影响到电路的状态。换句话说，只有最开始那一下子是最重要的。 尽管我们是在讲科学，但它会让朋友们以为你具有特异功能。你可以叫你的朋友背着你合上一个开关，然后再把它拉开，这时候，你可以踱过去，观察一下哪个灯泡亮着，然后准确地说出他刚才动的是哪个开关。相信这一定会让你的朋友张大嘴巴，惊奇地看着你。 上面讲的这个电路，称为『触发器』。触发器在很多英文书中被称为『Flip Flop』，简称 『FF』，差不多类似于我们汉语里的象声词，大致的意思是『噼里啪啦』或者『噼噼啪啪』。当然，这不是过年放爆竹，而是一大堆继电器在工作的时候所发出的声音。 触发器的工作状态依赖于两个开关 S 和 R，闭合一个断开另一个，总是会得到两个相反的输出 Q 和 Q’；要是这两个开关都断开，那么，取决于 Q 和 Q’ 刚才处于什么状态，它们依然保持这种状态不变。这都是我们已经知道的。不过，你有没有想过，还有最后一种情况，要是 S 和 R 都闭合，会怎样呢？老实说，情况很不妙。如 图 7.18 所示，闭合两个开关，将直接导致上下两个或门的输出永久为 1，经过非门变换之后又都变成 0，于是两个灯泡都不亮。 图 7.18 当 R 和 S 都闭合时，Q 和 Q&#39; 都不亮 这是非常粗暴的做法，是暴力干涉。通常情况下，灯泡 Q 和 Q’ 是互补的，配合得挺好，互为依托，相互制约，一个亮起来，另一个就会熄灭，能自己达到合适的稳定状态。但是现在，虽然电路里依然存在反馈，但是不起作用，整个电路现在已经丧失了记忆力，差不多已经失去了理智，神经错乱了。 总结一下。这里讲的触发器，一共有 4 中工作状态，参见 表 7.1。 S R Q Q’ 0 0 不变 不变 0 1 0 1 1 0 1 0 1 1 0 0 表 7.1 触发器的输出与 S 和 R 的关系 符号 图 7.19 R-S 触发器的符号 这是最早的，也是最基本的一种触发器，我们一般称它为 R-S 触发器。在这里，S 和 R 不再代表开关，而 Q 的意思也和灯泡相去甚远。然而，无论是开关的通断还是灯泡的亮灭，代表的无非是电压或者电流的有无，两种不同的表示方法，它们背后的思想是一致的。Q 和 Q’ 总以相反的状态出现，Q=0 则 Q’=1；Q=1 则 Q’=0。 触发器有两个截然相反的输出，不过多数情况下我们只需要一个输出就已足够。因此，一直以来就把 Q 作为触发器的输出。结合 表 7.1 还可以看出，在触发器正常工作的前提下，Q 的输出和 S 的输入总是一致的，S=0 则 Q=0；S=1 则 Q=1。这意味着可以通过设置 S 的值，使得 Q 的输出和 S 保持一致，这就是『S』的由来（在英语里，S 是单词『Set』的第一个字母，这个单词的意思是『设置』）。不管 Q 以前是什么，比如 Q=0，我们可以通过让 S=1 来使 Q 变成 1。但是，当 R=1 的话，Q 又变回 0，这等于将 Q 打回原形，这称为『恢复』或者『复位』，『R』就是这么来的（R 取自英语单词『Reset』的第一个字母，该单词的意思是『复位』）。 可以保存一个比特的触发器 在埃克尔斯和乔丹的实验室里，触发器没有什么用途，它只是证明了电子管可以做成这么一样东西，就像经验丰富的厨师有一天突然想到可以用蒜苗和鸡蛋做出一样新菜肴。事实上，人类的很多发明就是这样产生的。好的东西总有用武之地，尤其是科学家和工程师们喜欢翻老底子，让那些现成的发明可以『为我所用』，触发器就是一个现成的例子。 为什么这样说呢？普通的电路，以及常规的逻辑门都有一个共性，那就是输出直接依赖于输入，当输入消失的时候，输出也跟着不存在了。触发器不同，当它触发的时候，输出会发生变化。但是，当输入撤销之后，输出依然能够维持。这就是说，触发器具有记忆能力。若干年后，当工程师们想在计算机中保存一个比特时，他们想到了触发器，这是一种职业嗅觉在起作用。不过，触发器有两个输出，保存一个比特不需要这么多。 如 图 8.1 所示，解决的办法是只留下一个输出 Q，而 Q’ 废弃不用（把它的引线剪掉）。这样，被保存的比特可以从 Q 端观察到，或者把它取走，引到别的地方使用。通过它，可以知道当前触发器保存的是什么，是 0 还是 1。 图 8.1 通常把 Q 作为 R-S 触发器的输出 我们的愿望是用触发器保存一个比特，一个比特只需要一根电线就可以传送，可是你瞧，它有两个输入端 S 和 R。而且，触发器要正常工作，离不开这两位仁兄的通力配合，少了谁都不成，要想使 Q=0，S 必须为 0，R 必须为 1；要想使 Q=1，必须使 S=1 而 R=0。 这可如何是好呢？难不成要保存一个比特，就必须得用两个输入吗？不要悲观，解决之道是拿一个非门，按照 图 8.2 所示的方法连接起来。 图 8.2 使用非门使 R 与 S 总是相反，解决用触发器保存 1 比特的问题 很显然，因为要想使触发器保存一个比特，就必须使 S 和 R 以相反的方式出现，所以非门的作用就是创造这样的条件。不是天才，怎么也想不出这个好办法。那么，这种做法到底有没有效果呢？不试试怎么知道！为了看看它能不能保存一个 0 或者一个 1，我们在它的左边接上开关，通过闭合或者断开开关，就能得到要保存的比特（0 或者 1）。同时，触发器的输出端接了一个灯泡，它的亮灭可以验证该比特是否已经被保存。如 图 8.3 所示，电路刚接好的时候，开关是断开的。断开的时候相当于要保存一个比特 0 。这个时候，如图所示，S=0，R=1，触发器动作，Q=0，所以不要指望灯泡会亮起来。 图 8.3 使用触发器保存比特&quot;0&quot;的过程 灯泡的冷漠表明目前触发器中保存的是 0。现在，用手摁一下开关，电路被接通，相当于输入为 1。如 图 8.4 所示，这个时候，S=1，R=0，触发器保存这个比特 1，于是灯泡亮了。 图 8.4 事实证明，仅仅增加一个非门，并不能使 R-S 触发器独立的保存并维持 1 个比特 这是个按键开关，当我们一撒手，它就会自动弹起来。嗯，这的确是一个性能优良的开关，不过我不是想说这个，眼下最要紧的，是当开关弹开后，被保存的比特能够独立存在而不受外部的影响。可现实呢，你会发现，一旦按键开关弹开，灯泡马上就会变脸——不亮了！ 傻眼了吧？这忘恩负义的东西，阳奉阴违，人刚走茶就凉了。原因很简单，开关弹开，相当于输入的比特是 0，于是触发器又忙不迭地把这个 0 存起来，灯泡自然就又不亮了。 这可是触发器呀，触发器是干什么的？连一个比特都存不住，那它和一根电线有什么区别？不要怪触发器，它只是一个电路，一些没有生命的零件，要怪只能怪我们没有把它设计好。为了把它设计好，我们给触发器安排两个门卫——如 图 8.5 所示，这是两个与门。这两个门卫都归同一个经理管辖，这就是控制端 CP。 图 8.5 经过改进的触发器，增加了 1 个控制端 我们这样来安排电路是有用意的，而且真的是很有效。如 图 8.6 所示，你看，通常情况下 CP=0，意思是现在不想保存数据。这时，因为与门的关系，不管 D 上是什么，S 和 R 都为 0，所以触发器保持原有的内容不变。 图 8.6 当控制端为 0 时，触发器不接收 D 端的比特 这就是说，CP=0 的另一层意思是希望触发器不被外面的数据干扰，继续保持原先保存的那个比特。在触发器前面放两个门卫（与门），不单单是保护原有的比特，它们还有更重要的任务。比如，如果 D=0，而且有经理陪同前来，即 CP=1，那么如 图 8.7 所示，S=0 而 R=1，于是 0 就会被保存到触发器里（Q=0）。 图 8.7 当控制端为 1 时，如果 D 端为 0，触发器的 Q 端为 0 再比如，同样是在有经理陪着的情况下（CP=1），要是 D=1，那么 S=1 而 R=0，于是 1 就被保存到触发器里（Q=1），如 图 8.8 所示。 图 8.8 当控制端为 1 时，如果 D 端为 1，触发器的 Q 端为 1 不管保存的是 0 还是 1，当它成功地进入触发器之后，日理万机的经理就打道回府了（CP=0），于是 S 和 R 都会一直为 0。换句话说，没有经理的陪同，负责保卫工作的人无法确定来者是不是危险分子，谁也别想再进入触发器，触发器将一直维持刚才保存的比特不变（参照 图 8.6）。最后，一个需要经理亲自护送才能保存比特的触发器称为 D 触发器，D 触发器的符号如 图 8.9 所示。 D 触发器 图 8.9 D 触发器符号 『D』取自英语单词『Data』的首字母，而『Data』的意思是『数据』、『数字』。所以，D 触发器的名字很恰当地表明了制造它的原始目的。 至此，我们终于可以保存一个比特了。 引用 《穿越计算机的迷雾》 反馈","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"//huminxi.netlify.com/tags/计算机/"},{"name":"记忆","slug":"记忆","permalink":"//huminxi.netlify.com/tags/记忆/"}]},{"title":"计算机的心率","slug":"计算机的心率","date":"2018-01-27T23:10:28.000Z","updated":"2019-04-22T07:12:20.379Z","comments":true,"path":"2018/01/28/计算机的心率/","link":"","permalink":"//huminxi.netlify.com/2018/01/28/计算机的心率/","excerpt":"心率是指心脏跳动的频率，即心脏每分钟跳动的次数。人平静时平均每分钟 60 到 100 次，运动(恋爱)时心跳会加速，心肺功能越好的人心跳越慢。那么计算机有心率吗？如果有，计算机的心脏又是什么呢？","text":"心率是指心脏跳动的频率，即心脏每分钟跳动的次数。人平静时平均每分钟 60 到 100 次，运动(恋爱)时心跳会加速，心肺功能越好的人心跳越慢。那么计算机有心率吗？如果有，计算机的心脏又是什么呢？ 开始阅读前，假设你已经了解基本电路符号和电磁铁的工作原理。如果你不清楚这些的话，可以先阅读 这篇文章 中电磁铁与继电器的相关内容。 电子蜂鸣器(buzzer) 电可以让物体运动，这个道理人人都懂。只要稍微扫视一下我们的房间就会发现：很多电器中都装了电动机，比如钟表、电扇、吹风机、计算机。电同样可以使扩音器中的磁芯振动，正因如此我们的音响设备、电视机才能够产生声音，播放语音和音乐。有一类设备或许能很清晰地阐释电能驱使物体运动的最简单也最具代表性的方式，然而由于这类设备正在被能够实现同样功能的电子器件逐步取代，它们正在迅速地消失。在我看来，最令人赞叹的例子应该算是电子蜂鸣器和电铃了。将继电器、电池、开关按如下形式连接。 如果你认为这个系统看起来有点古怪，说明你还没有发挥出想象力。或许以前我们没见过采用这种连接方式的继电器，因为我们通常所见过的继电器，其输入和输出是在两个回路当中的，而这里却构成了一个回路。当开关闭合后，电路就连通了。连通的电路使得电磁铁把金属簧片拉了下来。 当金属簧片的位置变化时，电路不再连通，电磁铁不再具有磁性，金属簧片又弹回原位。 如此一来，电路又一次连通了。从整个过程来看：开关一旦闭合，金属簧片就会上下跳动——电路也会随之连通或断开——声音也就会随之发出。如果金属簧片发出了一种刺耳的声音，这套系统就成为了一个蜂鸣器。如果金属簧片前端是一把小锤子，旁边只要放上一个锣，就构成了一个电铃。大家可以自行脑补一下。 实在脑补不出来同学的可以参考下图: 振荡器(oscillator)其实上面的电路还有另一种接法，下面的示意图中包含了一个标准电压符号和一个接地符号。 看到这幅图你或许立刻想起了非门(或者称反向器)，因此电路可以简化为如下图所示。 反向器，顾名思义，当它的输入是 0 的时候，它的输出就为 1；而当其输入为 1 时，输出就为 0。电路中的开关一旦闭合，反向器中的继电器就会在连通与断开这两种状态之间反复交替。你也可以将电路中的开关省去，这样就可以使反向器连续地工作，如下所示。 这幅图似乎在表达着一种矛盾的逻辑，反向器的输出与其输入是相反的，但是在这里，输出同时又是输入！ 然而，我们要牢牢记住，反向器在本质上就是一个继电器，而继电器将状态取反以得到另一个状态是需要一点点时间的。所以，即使输入和输出是相同的，输出也会很快地改变，成为输入的相反状态（当然，输出随即也会很快改变输入，如此反复）。 这个电路的输出到底是什么呢？其实就是要么提供电压，要么不提供电压，在两者之间切换。我们也可以用这种方式来表达——输出结果要么是 0, 要么是 1。我们把这种电路称为振荡器(oscillator) , 它和我们先前学到的所有东西存在本质上的区别。在此之前我们讲过的所有的电路，其状态的改变都依靠人为的干预(拨动开关)。但是振荡器却在不需要人干涉的情况下，可以完全自发地工作。 当然，单独的一个振荡器用处并不大。但是，在与其他电路连接后所组成的自动控制系统中，振荡器有着举足轻重的作用。为了使不同组件同步工作，所有计算机都配备着某种振荡器。 频率(frequency) 当采用 0 和 1 的交替序列来表示振荡器的输出时，我们一般使用下面这样的图来形象地描述输出。 我们可以通过这幅图来充分地了解电路的输出，水平坐标代表时间，垂直坐标用来表示输出是 0 还是 1。 这幅图表示随着时间的推移，振荡器的输出在 0 和 1 之间按照固有的规律交替变化。正因为这一点，振荡器又经常被称为时钟(clock)——通过振荡进行计数也是一种计时方式。 振荡器运行速度究竟有多快呢？换句话说，金属簧片多久会振动一次？或者每秒钟振动多少次呢？这很大程度上依赖于继电器的内部构造。你容易想到，一个又大又重的继电器只能缓慢地上下摆动；而一个又小又轻的继电器却可以高速地跳动。振荡器从某个初始状态开始，经过一段时间又回到先前初始状态的这一段间隔定义为振荡器的一个循环(cycle)，或者称为一个周期，如下图所示。 一个循环所占用的时间就是该振荡器的周期(period)。假设我们使用的振荡器的周期恰好是 0.05s，任取一个时间点，将其设置为起始状态点，我们把它标注为零点，就可以在水平轴上标出相应的时间。 周期的倒数就是振荡器的频率(frequency)。在这个例子中振荡器的周期是 0.05s，那么其频率就是 1➗0.05s，即振荡器每秒钟产生 20 次循环，而相应的输出每秒钟也变化 20次。 每秒钟的循环次数与每小时穿越的公里数、每立方米水的重量、每份食物的卡路里数等概念一样都是很容易理解的，但这种描述方法已不常用。为了纪念发送和接收无线电波的第一人——亨利希·鲁道夫·赫兹(1857-1894), 后人使用『赫兹』这个词来表示这一概念。这种用法起源于 20 世纪 20 年代的德国，几十年之后逐渐被其他国家所广泛采纳。这样，上述振荡器的频率就是 20 赫兹，记做 20Hz。 计算机的心率现在你应该清楚电脑主频这个参数的作用了吧。那么问题来了，现代计算机的振荡器还是由继电器构成的吗？是不是主频越高就意味着电脑的处理速度就越快呢？ 引用 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 心率 反向器 电子振荡器 时钟频率","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"//huminxi.netlify.com/tags/计算机/"},{"name":"心率","slug":"心率","permalink":"//huminxi.netlify.com/tags/心率/"}]},{"title":"谈谈计算机中的四则运算","slug":"谈谈计算机中的四则运算","date":"2018-01-20T16:04:02.000Z","updated":"2019-04-22T07:14:05.933Z","comments":true,"path":"2018/01/21/谈谈计算机中的四则运算/","link":"","permalink":"//huminxi.netlify.com/2018/01/21/谈谈计算机中的四则运算/","excerpt":"经过前面 从零开始造一台自己的加法器 的学习，现在我们已经能造出一台简易的二进制加法器，可以利用它来做四位二进制的加法。那么减法、乘法和除法呢，难道我们也要一一构造减法器、乘法器和除法器吗？","text":"经过前面 从零开始造一台自己的加法器 的学习，现在我们已经能造出一台简易的二进制加法器，可以利用它来做四位二进制的加法。那么减法、乘法和除法呢，难道我们也要一一构造减法器、乘法器和除法器吗？ 加法和减法8 位二进制加法器四位二进制加法器 将两个四位二进制加法器串联起来，我们就能得到一个 8 位的二进制加法器。也就是说，我们想要相加的二进制数，其范围是从 0000 0000 到 1111 1111，即十进制的 0 到 255。两个 8 位二进制数的和最大可为 1 1111 1110，即 510。 减法与借位 当你确信继电器连接到一起真的可以实现二进制加法的时候，你可能会问:『那么如何实现减法呢？』提出这样的问题并不是说你在没事找事，而实际上这表明你是相当有观察力的。加法和减法在某些方面相互补充，但在机制方面这两个运算则是不同的。加法是始终从两个加数的最右列向最左列进行计算的。每一列的进位加到下一列中。在减法中没有进位，而是有借位——一种与加法存在本质区别的麻烦机制。 例如，我们来看一个典型的借位减法的题目： 253 -176 ---- ??? 结果等于多少呢？ 要想计算结果，首先从最右列着手。我们看到，6 是大于 3 的，因此从 5 借 1，再用 13 减去 6，得到结果为 7。由于我们已经在 5 上借了 1，因此，现在实际上那一位是 4，而 4 是小于 7 的，因此继续从 2 借 1，14 减 7 结果为 7。由于 2 借了 1，实际上这一位是 1，从 1 中减去 1，结果为 0。因此，最后结果应为 77 253 -176 ---- 77 如何才能通过一连串逻辑门来实现这个反逻辑呢？然而，我们并不打算这样做。相反，我们打算利用一个小技巧来让减法不涉及借位。 模 在日常生活当中，如果你仔细观察的话会发现:把某物体左转 90 度，和右转 270 度，在不考虑圈数的条件下，最终的效果是相同的；把分针顺时针拨 20 分钟，和逆时针拨 40 分钟，在不考虑时针的条件下，效果也是相同的；把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，效果也是相同的；………上述几组数字，有这样的关系： 90 + 270 = 360 20 + 40 = 60 25 + 75 = 100式中的 360、60 和 100，就是『模』。假如提前就知道模的值，我们可以把减法化为加法。 自定义编码 让我们来想一想。通常用来表示正数和负数的方法，其好处就在于能表示所有的正数、负数。我们将 0 想象为这个无限延伸的序列的中点。这个序列中正数沿着一个方向延伸，而负数则按照另一个方向延伸: ...-10000, -9999...-3, -2, -1, 0, 1, 2, 3...9999, 10000... 但是，如果我们并不需要无限大或无限小的数，而且在开始的时候我们就可以预知所使用的数字的范围，那情况就有所不同了。 以支票账户为例，这里人们通常会遇到负数。假设我的账户余额小于 500 美元，并且银行给了我们 500 美元的无息预支额度，意思就是账户余额数值应该是一个在 499 美元到 -500 美元之间的数。假设我们不会一次取出 500 美元，我们也不会支出多于 500 美元的金额，这里我们用到的只是美元，不涉及美分。这些假设表明账户能处理的额度是介于 -500 到 499 之间，总共 1000 个数，而我们只用三位十进制数就可以表示所有需要的数字。我们并不需要用到从500 到 999 之间的正数，因为我们所需要的数的最大值为 499。因此从 500 到 999 的三位数可以用来表示负数。具体情况如下： 用 500 表示 -500 用 501 表示 -499 用 502 表示 -498 ...... 用 998 表示 -2 用 999 表示 -1 用 000 表示 0 用 001 表示 1 用 002 表示 2 ...... 用 497 表示 497 用 498 表示 498 用 499 表示 499 也就是说，以 5, 6, 7, 8 或 9 开头的三位数实际上表示的都是负数，而不是把数字写成这样： —500, -499, -498...-4, -3, -2, —1, 0, 1, 2, 3, 4...497, 498, 499 用这种表示法，我们可以将它们写成： 500, 501 ,502...996, 997, 998, 999，000, 001, 002, 003, 004...497, 498, 499 注意，这就形成了一个循环排序。最小的负数(500)看起来像是最大正数(499)的延续。而数字 999 (实际上是 -1)是比 0 小 1 的第一个负数。如果我们在 999 上加 1,通常会得到 1000。由于我们处理的是三位数，这个结果实际上就是 000。这种标记方法称为 10 的补数(ten’s complement)为了将三位负数转化为 10 的补数，我们用 999 减去它再加 1。也就是说，对 10 求补数就是对 9 的补数再加 1。例如想要得到 -255 对 10 的补数，用 999 减去 255 得到 744, 然后再加 1, 得到 745。你可能听说过：『减一个数就等于加一个负数。』你可能会回答：『实际上还是减去了这个数。』然而，利用 10 的补数，我们将不会再用到减法。所有的步骤都用加法来进行。 那么回到我们的 8 位二进制数，如果我们这样编码: 二进制数 十进制数 1000 0000 -128 1000 0001 -127 1000 0010 -126 1000 0011 -125 … … 1111 1101 -3 1111 1110 -2 1111 1111 -1 0000 0000 0 0000 0001 1 0000 0010 2 … … 0111 1101 125 0111 1110 126 0111 1111 127 注: 在这里模为 1 0000 0000，即 256。 这个编码为我们提供了一种不用负号就能表示正负数的方法。同样也让我们自由地将正数和负数用加法法则相加。例如，将 127 和 -1 等价的两个二进制数相加。利用上面的表格，可以简单写为: 127 0111 1111 - 1 &lt;=&gt; + 1111 1111 ---- --------- 126 1 0111 1110 ，忽略最左边的进位 1，最后结果为 126。 或 127 0111 1111 -128 &lt;=&gt; + 1000 0000 ---- --------- -1 1111 1111，结果为 -1。 要注意的是，这里涉及了上溢和下溢情况，即结果大于 127 或小于 -128。例如，将 125 与它自身相加 125 0111 1101 +125 &lt;=&gt; + 0111 1101 ---- --------- 250 1111 1010 ，结果为 -6，出现上溢。 将 -125 与它本身相加也会出现相同的情况。 -125 1000 0011 -125 &lt;=&gt; + 1000 0011 ---- --------- -250 1 0000 0110 ，结果为 6，出现下溢。 现在，二进制数可以有两种不同的使用方法。二进制数可以是有符号的，也可以是无符号的。无符号的 8 位二进制数所表示的范围是 0 ~ 255。有符号的 8 位二进制数表示的范围是 -128 ~ 127。无论是有符号的还是无符号的，数字本身是无法表示的。例如，如果有一个人问:『有一个 8 位二进制数，值为 10110110。它相当于十进制的多少？』你必须先问:『它是有符号数还是无符号数？它可能为 -74 或 182。』这就是二进制的麻烦之处，它们只是一些 0 和 1，本身并没有任何含义。 乘法和除法移位 + 加法 扩展Q1这时假如有人问你：Java 中值为 -2 的 int 型变量在内存中的后 8 位是多少？ 我们仔细审一下这个题目，发现其中其实隐含了两个问题: java 中『基本数据类型』在内存中分别用几位表示 负数在计算机中如何编码 下面我们就来一一解答。 A1java 中『基本数据类型』在内存中分别用几位表示 类型名称 类型定义 取值范围 boolean 布尔值，作二元判断 true，false char 16 位 Unicode 字符 Unicode 字符列表 byte 8 位有符号整数 最小值 -128，最大值 127 short 16 位有符号整数 最小值 -32768，最大值 32767 int 32 位有符号整数 最小值 -2147483648（-2³¹），最大值 2147483647（2³¹-1） long 64 位有符号整数 -2⁶³ ~ 2⁶³-1 float 32 位浮点数 IEEE_754 double 64 位浮点数 IEEE_754 Java 中所有数值类型都有正负号，所以不要去寻找无符号的数值类型。 负数在计算机中如何编码8 位有符号数可表示数值范围：-2⁷ ~ 2⁷-1，即 10000000 ~ 0111111132 位有符号数可表示数的范围： -2³¹ ~ 2³¹-1，即 10000000 00000000 00000000 00000000 ~ 01111111 11111111 11111111 11111111。 所以 -2 在内存中表示应为: 11111111 11111111 11111111 11111110。 代码验证12345678910/** * 负数在内存中的二进制表示 * */public class NegativeNumberInMemory &#123; public static void main(String[] args) &#123; int i = -2; System.out.println(Integer.toBinaryString(i)); &#125;&#125; 引用 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 原码、反码和补码 数据类型 Unicode 字符列表 IEEE_754 Think in Java","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"四则运算","slug":"四则运算","permalink":"//huminxi.netlify.com/tags/四则运算/"}]},{"title":"tomcat + servlet + jsp 开发登录页面实例","slug":"tomcat-servlet-jsp-开发登录页面实例","date":"2018-01-13T08:46:41.000Z","updated":"2019-04-22T07:22:32.703Z","comments":true,"path":"2018/01/13/tomcat-servlet-jsp-开发登录页面实例/","link":"","permalink":"//huminxi.netlify.com/2018/01/13/tomcat-servlet-jsp-开发登录页面实例/","excerpt":"大家在浏览网站时，都遇到过需要输入用户名和密码的情况，然后网站会对你的输入信息进行校验。如果用户名密码正确，接下来你就可以正常访问受限资源了。反之，网站就会给你相应的错误提示。今天我们就用 tomcat + servlet 和一点点的 jsp 来编写简单的登录页面。","text":"大家在浏览网站时，都遇到过需要输入用户名和密码的情况，然后网站会对你的输入信息进行校验。如果用户名密码正确，接下来你就可以正常访问受限资源了。反之，网站就会给你相应的错误提示。今天我们就用 tomcat + servlet 和一点点的 jsp 来编写简单的登录页面。 概念 Tomcat 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet 容器，按照 Sun MicroSystems 提供的技术规范，实现了对 Servlet 和 JavaServer Page（JSP）的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web server；这两个 HTTP web server 不是捆绑在一起的。Apache Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。 Servlet 是一个在 Web 服务器中运行的小型 Java 程序。Servlet 的接收和响应来自Web客户端的请求，通常通过 HTTP(超文本传输协议)。 JSP（全称 Java Server Pages）是由 Sun MicroSystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的 Web 网页的技术标准。JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于 HTTP 的应用程序。JSP 使 Java 代码和特定的预定义动作可以嵌入到静态页面中。JSP 句法增加了被称为 JSP 动作的 XML 标签，它们用来调用内建功能。另外，可以创建 JSP 标签库，然后像使用标准 HTML 或 XML 标签一样使用它们。标签库提供了一种和平台无关的扩展服务器性能的方法。JSP 被 JSP 编译器编译成 Java Servlets。一个 JSP 编译器可以把 JSP 编译成 Java 代码写的 servlet 然后再由 Java 编译器来编译成机器码，也可以直接编译成二进制码。 实现登录流程图 代码项目结构 LoginInfo1234567891011121314151617181920212223242526package entity;/** * 登录信息 */public class LoginInfo &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; LoginServlet1234567891011121314151617181920212223242526272829303132333435363738394041package servlet;import entity.LoginInfo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 登录servlet */public class LoginServlet extends HttpServlet &#123; private static final String USERNAME = \"admin\"; private static final String PASSWORD = \"admin\"; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //让doGet执行与doPost相同操作 System.out.println(\"doGet方法被执行..\"); doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doPost方法被执行..\"); LoginInfo loginInfo = new LoginInfo(); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); loginInfo.setUsername(username); loginInfo.setPassword(password); //判断用户名和密码是否正确 if (USERNAME.equals(loginInfo.getUsername()) &amp;&amp; PASSWORD.equals(loginInfo.getPassword())) &#123; resp.sendRedirect(req.getContextPath() + \"/login_success.jsp\"); &#125; else &#123; resp.sendRedirect(req.getContextPath() + \"/login_fail.jsp\"); &#125; &#125;&#125; web.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; login.jsp12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/servlet/LoginServlet\"&gt; 用户名: &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 密码: &lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login_fail.jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录失败&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录失败，请检查用户名和密码!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; login_success.jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;恭喜你，登录成功!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 登录界面 运行结果 引用 JAVA遇见HTML——Servlet篇 java 学习总结 Apache Tomcat Java Servlet JSP","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"//huminxi.netlify.com/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"//huminxi.netlify.com/tags/servlet/"}]},{"title":"mac 上如何搭建个人博客","slug":"mac 上如何搭建个人博客","date":"2017-12-31T05:33:47.000Z","updated":"2019-01-04T08:44:47.512Z","comments":true,"path":"2017/12/31/mac 上如何搭建个人博客/","link":"","permalink":"//huminxi.netlify.com/2017/12/31/mac 上如何搭建个人博客/","excerpt":"最初对个人博客有印象，就是阮一峰的个人博客。当时是在搜索 互联网协议入门 这篇文章的时候，发现原来还可以这么玩。随后在和黑牛的一次谈话中，他问我:2017 年就快要过去了，今年的总结写了吗？这才反应过来，2017 年已经到末尾了。于是就有了想写点东西，留作以后回忆的索引，搭建个人博客也就顺理成章了。","text":"最初对个人博客有印象，就是阮一峰的个人博客。当时是在搜索 互联网协议入门 这篇文章的时候，发现原来还可以这么玩。随后在和黑牛的一次谈话中，他问我:2017 年就快要过去了，今年的总结写了吗？这才反应过来，2017 年已经到末尾了。于是就有了想写点东西，留作以后回忆的索引，搭建个人博客也就顺理成章了。 概要一种方式是通过 Hexo + Github Pages 来搭建个人博客 或 Hexo什么是 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 HexoHexo的安装在其 官方文档 中有很详细的说明。 校验cd &lt;hexo 的安装目录&gt;hexo ghexo s 现在我们打开 http://localhost:4000/ 已经可以看到一篇内置的blog了。 进阶自己切换 hexo 主题，本人使用的是 Next 主题。 Github Pages注册 Github 账号进入 Github 网站，按照提示进行注册并登陆。 创建 Github Pages 仓库登录完成之后，在你的主页点击图标 New repository 创建一个新的版本库，因为我们是使用 Github Pages 去搭建我们的静态博客，所以 repository 的名称格式 你的用户名 + .github.io。例如：我的用户名是：huminxicn，那么 repository 的名字应该是： huminxicn.github.io 。因为之后你将要访问的你的博客地址就是： https://huminxicn.github.io 。 至此，Github 账号创建完成，Github Pages 所需要的 repository 也创建好了。 进阶自己购买域名，然后再让 Github Pages 解析到此域名就行。Learn more 关联 Hexo 与 Github Pages配置 SSH检查是否已经存在 ssh key cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用 git。否则，可以看到如下的目录结构 生成新的 SSH Keyssh-keygen -t rsa -C &quot;&lt;你常用的邮箱地址&gt;&quot; 输入命令回车之后会提示你输入一些东西，不用管，一直回车到底就好了。然后你的 ~/.ssh 目录下就会生成两个文件 id_rsa 和 id_rsa.pub 。 配置 Github打开你的 Github -&gt; Settings -&gt; SSH and GPG Keys 。然后点击 New SSH Key 创建一个新的SSH Key。 Title 可以用你的计算机名，可以用以区分。将 id_rsa.pub 文件中的所有内容复制到 Key 里面。 然后使用下面的命令测试是否可以连接上 Github 。ssh -T git@github.com 将 Hexo 博客部署到 Github Pages先使用下面的命令对 Git 进行初始配置，用来跟踪提交信息 git config --global user.name &quot;&lt;你的名字&gt;&quot;git config --global user.email &quot;&lt;你常用的邮箱地址&gt;&quot; 然后编辑 hexo 根目录下的 _config.yml 文件，设置其中的 deploy 参数，详细请查看 Hexo 官方文档中 部署 部分。 git 地址建议使用 SSH 地址。在上面的参数设置好了之后，使用下面的命令安装 hexo-deployer-git 插件，只有安装了插件之后才可以部署到 Github Pages。 npm install hexo-deployer-git --save 校验安装完插件之后使用下面的命令进行部署： hexo g #生成静态文件hexo d #部署到github 或hexo d -g #部署前生成静态文件 好了，快去访问你的 个人博客 吧！ 引用 hexo hexo-cn 域名系统(英文:Domain Name System, 缩写:DNS) 使用Hexo搭建个人博客 如何搭建一个独立博客——简明Github Pages与Hexo教程","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"//huminxi.netlify.com/tags/个人博客/"}]},{"title":"一种基于前后端分离的单点登录实现方案","slug":"一种基于前后端分离的单点登录实现方案","date":"2017-12-10T12:43:57.000Z","updated":"2018-12-17T06:14:40.224Z","comments":true,"path":"2017/12/10/一种基于前后端分离的单点登录实现方案/","link":"","permalink":"//huminxi.netlify.com/2017/12/10/一种基于前后端分离的单点登录实现方案/","excerpt":"单点登录（英语：Single sign-on，缩写为 SSO），顾名思义，只需要登录一次就能访问多个系统。相同的，单一注销（single sign-off）就是指，只需要注销一次，就可以结束对多个系统的访问权限。下面，就一起来研究一下单点登录的适用场景以及背后的实现原理。","text":"单点登录（英语：Single sign-on，缩写为 SSO），顾名思义，只需要登录一次就能访问多个系统。相同的，单一注销（single sign-off）就是指，只需要注销一次，就可以结束对多个系统的访问权限。下面，就一起来研究一下单点登录的适用场景以及背后的实现原理。 单系统登录http 无状态协议web 应用采用 browser/server 架构，http 作为通信协议。http 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程如下图所示，三次请求/响应对之间没有任何联系。 但这也同时意味着，任何用户都能通过浏览器访问服务器上的资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求(响应合法请求，忽略非法请求)；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 会话机制当浏览器第一次请求服务器时，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器根据请求中的会话 id 就知道是不是同一个用户了(注:浏览器第一次请求时服务器还没有创建会话)，这个过程用下图说明，后续请求与第一次请求产生了关联。 服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？你可能会想到两种方式: 拼接在 url 中 cookie 将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式比较低级。那就换浏览器自己来维护这个会话 id 吧，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以 key/value 形式存储，浏览器发送 http 请求时自动附带 cookie 信息。tomcat 会话机制当然也实现了 cookie ，访问 tomcat 服务器时，浏览器中可以看到一个名为 JSESSIONID 的 cookie，这就是 tomcat 会话机制维护的会话id，使用了 cookie 的请求响应过程如下图。 登录状态有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下。HttpSession session = request.getSession;session.setAttribute(“isLogin”, true); 用户再次访问时，tomcat 在会话对象中查看登录状态。HttpSession session = request.getSession;session.getAttribute(“isLogin”); 实现了登录状态的浏览器请求服务器模型如下图所示。 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 多系统的复杂性web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样。 web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie（否则会存在 CSRF 问题）。 既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如 “*.baidu.com”，然后将它们的 cookie 域设置为 “baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。然而，可行并不代表好，共享 cookie 的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间就无法使用同一个 cookie。因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 单点登录什么是单点登录？单点登录全称 Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录。 登录相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，先由子系统产生临时令牌，然后 sso 认证中心验证用户的用户名密码没问题，最后 sso 认证中心再通知各子系统令牌生效。之后浏览器端可以利用之前就返回的令牌进行受限资源的访问。 下面对上图简要描述 用户访问 nrb 的受限资源，nrb 发现用户未登录，nrb 生成一个 tokenA，并将 tokenA 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，并关联 sessionId 和 userId sso 认证中心通知 nrb 绑定 tokenA 和 userId 并进行保存 sso 认证中心跳转回用户访问的nrb系统 用户利用之前就已经返回的 tokenA 来访问 nrb 的受限资源 用户访问 hades 的受限资源，hades 发现用户未登录，hades 生成一个 tokenB，tokenB 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户已登录 sso 认证中心通知 hades 绑定 tokenB 和 userId 并进行保存 sso 认证中心跳转回用户访问的hades系统 用户利用之前就已经返回的 tokenB 来访问 hades 的受限资源 注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明。 sso 认证中心一直监听会话的状态，一旦会话销毁，监听器将通知所有管理系统执行注销操作。 用户向 hades 系统发起注销请求 hades 系统向 sso 认证中心发起注销请求，并将用户的 tokenA 和存储在 cookie 中的 sessionId 当做参数传递 sso 认证中心取出与 sessionId 关联的系统地址和 token sso 认证中心向所有关联系统发起注销请求，并指定需要注销的 token 各关联系统接收 sso 认证中心的注销请求，销毁指定 token sso 认证中心引导用户至登录页面 部署图单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以发送令牌、保存令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述。 sso 认证中心与 sso 客户端通信方式有多种，这里以简单好用的 httpClient 为例，web service、rpc、restful api 都可以。 实现简要介绍下基于 java 的实现过程，sso 采用客户端/服务端架构，我们先看 sso-client 与 sso-server 要实现的功能（下面：sso 认证中心= sso-server）。 sso-client 拦截子系统未登录用户的请求，生成 token，并将 token、本地 cookie 值和子系统自身地址作为跳转 sso 认证中心的参数进行传递 接收 sso 认证中心通知的 token、userId 并进行保存 通过 token 与用户建立会话 拦截用户注销请求，向 sso 认证中心发送注销请求 接收 sso 认证中心发出的注销请求，注销指定 token sso-server 验证用户的账户信息 创建 session 将 sessionId 与子系统地址及相应的 token，userId 进行关联 与 sso-client 通信发送 token、userId 校验 session 有效性 接受 sso-client 注销请求，注销所有子系统中的 token 引用 单点登录原理与简单实现 HTML色彩","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.netlify.com/categories/编程实践/"}],"tags":[{"name":"单点登录","slug":"单点登录","permalink":"//huminxi.netlify.com/tags/单点登录/"}]},{"title":"Singleton","slug":"Singleton","date":"2017-11-28T14:04:34.000Z","updated":"2018-12-10T10:49:00.189Z","comments":true,"path":"2017/11/28/Singleton/","link":"","permalink":"//huminxi.netlify.com/2017/11/28/Singleton/","excerpt":"单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。","text":"单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。 单线程版本懒汉模式 &amp; 饿汉模式懒汉模式 123456789101112131415161718public class Singleton &#123; // 定义一个空的 Singleton 对象引用 SINGLETON private static Singleton SINGLETON = null; // 利用构造器私有化来限制外部使用 new 关键字，进而避免构造出多个实例 private Singleton() &#123; &#125; // 提供外部获取单例对象的方法 public static Singleton getInstance() &#123; // 如果 SINGLETON 还未指向任何一个 Singleton 对象，new 一个 Singleton 对象出来。 if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 对象引用一开始为 null，具体使用的时候才 new 一个对象出来，这种写法属于懒汉模式。 饿汉模式 123456789101112public class Singleton &#123; // 在定义时就直接 new 出单例对象 private static Singleton SINGLETON = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SINGLETON; &#125;&#125; 顾名思义，单例对象一开始就被 new Singleton() 主动构建，不再需要判空操作，这种写法属于饿汉模式。 多线程版本如果上面『懒汉模式』的代码是运行在多线程环境中，就会出现许多问题。最明显的一个，将有可能 new 出多个 Singleton 对象实例。最简单的修复方式是在 getInstance() 方法上加 synchronize 关键字。 123456789101112131415public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; // 方法上加 synchronized 关键字 public synchronized static Singleton getInstance() &#123; if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 但是这样的话，不管单例对象有没有构建出来，每次调用 getInstance() 方法的时候都会加锁。 使用 double-checked lock(双检锁) 可以避免在 new 出单例对象之后还对 getInstance() 方法进行加锁，这是对锁粒度细化的一种体现。 1234567891011121314151617181920212223public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; // 第一次检查 if (SINGLETON == null) &#123; // 只有 SINGLETON 为 null 时，才对 new Singleton() 代码块进行加锁。 synchronized (Singleton.class) &#123; // 第二次检查 if (SINGLETON == null) &#123; SINGLETON = new Singleton(); &#125; &#125; &#125; return SINGLETON; &#125;&#125; 引用 老生常谈双检锁（DCL） The “Double-Checked Locking is Broken” Declaration","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.netlify.com/categories/设计模式/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"//huminxi.netlify.com/tags/Singleton/"},{"name":"单例模式","slug":"单例模式","permalink":"//huminxi.netlify.com/tags/单例模式/"}]},{"title":"从零开始造一台自己的加法器","slug":"从零开始造一台自己的加法器","date":"2017-11-23T07:13:22.000Z","updated":"2019-04-22T07:14:05.936Z","comments":true,"path":"2017/11/23/从零开始造一台自己的加法器/","link":"","permalink":"//huminxi.netlify.com/2017/11/23/从零开始造一台自己的加法器/","excerpt":"在电子学中，加法器(adder)是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件的重要组成部分。","text":"在电子学中，加法器(adder)是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件的重要组成部分。 10 进制与 2 进制10 的替代品对我们人类而言，10 是一个非常重要的数字。10 是我们大多数人拥有的手指或脚趾的数目，因为手非常便于计数，于是我们已经适应了这个以 10 为基数的数字系统。起初也很难再构想出其它的数字系统。 当我们看到数字 10 的时候，我们不自觉地就想到这个数字代表了下面的这么多个苹果： 10 =   但是，数字 10 之所以指的是这么多个苹果，其唯一的理由就在于这些苹果的数目与我们手指的数目相同。如果人类的手指不是 10 根，我们数数的方式就会有所不同，那么 10 就会是另外一个含义。 同样，数字 10 还可以代表这么多个苹果： 10 =   或者是这么多个苹果： 10 =   甚至可以是这么多个苹果： 10 =  设想一下: 如果人类像卡通人物一样每只手有 4 根手指那会怎样呢？ 我们可能就不会想到建立一个以 10 为基数的数字系统。我们会自然而然地、不可避免地想到建立一个以 8 为基数的数字系统。我们会称它为八进制数字系统。如果我们的数字系统是以 8 为基数而建立的，我们就不需要下面这个符号： 9 将这个给卡通人物看的话，他会得到这样的反应：”这是什么？它代表什么？“ 继续思考一下，你会发现我们连这样的一个符号也不会需要： 8 在十进制中，”十”没有特定的符号，因此在八进制中，同样也没有表示”八”的特定符号。十进制中我们的计数方式是：0、1、2、3、4、5、6、7、8、9，然后是 10。八进制中我们的计数方式是：0、1、2、3、4、4、5、7，然后是什么呢？我们已经将符号用完了。在这里唯一有意义的只有 10，而在这里的正确答案恰恰就是 10。在八进制中，7 之后的一个数字就是 10。但这个 10 代表的并不是人类的手指的数量。在八进制中，10 代表的是卡通人物手指的数量。 2 进制如果我们是海豚呢，那么就必须用两个鳍来计数。这个数字系统称为以 2 为基数的数字系统。这样的话我们似乎只有两个数字了，分别为 0 和 1。在二进制中，1 的下一个数字是 10。第一次见似乎有点难以理解，但也不用意外。因为无论使用哪种计数系统，当单个的数字用完时，第一个两位数就是 10。 二进制数最大的问题是数字用完的很快! 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1110,1111,10000,10001,… 当然，二进制也有它的优点，比如做加法的时候: 11 加法表 + 0 1 0 0 1 1 1 10 乘法比加法还容易，比起小时候背的 99 乘法表 不知道简单了多少。 11 乘法表 x 0 1 0 0 0 1 0 1 99 乘法表 x 1 2 3 4 5 6 7 8 9 1 1 2 2 4 3 3 6 9 4 4 8 12 16 5 5 10 15 20 25 6 6 12 18 24 30 36 7 7 14 21 28 35 42 49 8 8 16 24 32 40 48 56 64 9 9 18 27 36 45 54 63 72 81 电磁铁与继电器电磁铁如果你手头有一根铁棒，那么在上面用细导线绕几百圈，然后接通电流，铁棒就变成了一块磁铁。现在它可以吸引其它的铁块或者钢块(电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象)。断开电流，铁棒将丧失磁性。 图1 中的电路组成元件按顺时针方向依次是 ABCDP 滑动变阻器 E 电磁铁 S 单刀单掷开关 电池 L 电灯泡 电流表 继电器继电器的作用就是通过吸引或弹开衔铁，进而控制另一个电路的通断。 继电器符号和电路图如下所示： 门非门结果与操作数相反。 真值表 NOT 0 1 1 0 符号 电路图 与门两个操作数都为 1 时结果为 1。 真值表 AND 0 1 0 0 0 1 0 1 符号 电路图 或门有一个操作数为 1 结果就为 1。 真值表 OR 0 1 0 0 1 1 1 1 符号 电路图 与非门跟与操作结果相反。 真值表 NAND 0 1 0 1 1 1 1 0 符号 或非门跟或操作相反。 真值表 NOR 0 1 0 1 0 1 0 0 符号 异或门一个操作数为 1，另一个操作数为 0 时，结果才为 1。 真值表 XOR 0 1 0 0 1 1 1 0 符号 电路图 二进制加法器 计算二进制数加法与计算十进制数加法非常相似。如果你想让 245 和 673 这两个十进制数相加，你会把这个问题分解为几个简单的步骤。每个步骤只需要将两个十进制数相加，二进制加法也同理。 半加器和全加器加法结果可以拆成两部分，一个是加和结果，另一个是进位结果。二进制加法也可以照下面这个方式进行拆分。 加和表 +加和 0 1 0 0 1 1 1 0 进位表 +进位 0 1 0 0 0 1 0 1 可以利用两个逻辑门来实现上面的结果 异或门 XOR 0 1 0 0 1 1 1 0 与门 AND 0 1 0 0 0 1 0 1 两个二进制数的加和结果是由异或门输出的，而进位结果是由与门输出的。因此我们可以将与门和异或门连接起来计算两个二进制数(即 A 和 B)的和。 真值表 输入 A 输入 B 加和输出 进位输出 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 这个被叫做半加器(Half Adder)。之所以被叫半加器是有原因的。它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于 1 位的。半加器没有做到的是将前一次的加法可能产生的进位位纳入下一次运算。例如，假设我们要将如下两个二进制数相加。 1111 +1111 ----- 11110 我们只能将半加器用于最右面一列的相加：1 加 1 等于 0，进位 1。对于右面算起的第二列，由于进位位的存在，实际上需要将三个二进制数相加，而随后的每一列的加法都是这样的。随后的每一列二进制数相加都需要将进位位算进来。为了对三个二进制数进行加法运算你，我们需要将两个半加器和一个或门做如下连接。 真值表 进位输入A 输入A 输入B 加和输出 进位输出 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 这个叫做全加器(Full Adder)。我们用如下的符号表示它: 到这里，我们已经迈出了关键的第一步。因为我们可以利用它做 2 进制的加法：1+1=10！ 多位二进制数相加当然，只能进行一位二进制数相加的加法器的用途实在是太窄了，我们更需要能支持多位二进制数做加法的加法器。答案就是将多个全加器连接起来，组成多位加法器。假设我们将 4 个全加器连接起来，那么它就能做 4 位二进制数的加法。如下图所示： 假设有两个 4 位二进制数 A₃A₂A₁A₀ 和 B₃B₂B₁B₀，只需要将它们按位相加，再逐级将低位的进位输出到高位进行计算即可。 引用 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 《穿越计算机的迷雾》","raw":null,"content":null,"categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"//huminxi.netlify.com/categories/计算机系统/"}],"tags":[{"name":"加法器","slug":"加法器","permalink":"//huminxi.netlify.com/tags/加法器/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-22T01:56:58.000Z","updated":"2017-11-23T09:42:15.000Z","comments":true,"path":"2017/11/22/hello-world/","link":"","permalink":"//huminxi.netlify.com/2017/11/22/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}