{"meta":{"title":"黄枫谷","subtitle":"外门弟子","description":"练气十层","author":"胡匪","url":"//huminxi.com"},"pages":[],"posts":[{"title":"计算机的心率","slug":"计算机的心率","date":"2018-01-27T23:10:28.000Z","updated":"2018-01-28T03:18:21.000Z","comments":true,"path":"2018/01/28/计算机的心率/","link":"","permalink":"//huminxi.com/2018/01/28/计算机的心率/","excerpt":"心率是指心脏跳动的频率，即心脏每分钟跳动的次数。人平静时平均每分钟 60 到 100 次，运动(恋爱)时心跳会加速，心肺功能越好的人心跳越慢。那么计算机有心率吗？如果有，计算机的心脏又是什么呢？","text":"心率是指心脏跳动的频率，即心脏每分钟跳动的次数。人平静时平均每分钟 60 到 100 次，运动(恋爱)时心跳会加速，心肺功能越好的人心跳越慢。那么计算机有心率吗？如果有，计算机的心脏又是什么呢？ 开始阅读前，假设你已经了解基本电路符号和电磁铁的工作原理。如果你不清楚这些的话，可以先阅读 这篇文章 中电磁铁与继电器的相关内容。 电子蜂鸣器(buzzer) 电可以让物体运动，这个道理人人都懂。只要稍微扫视一下我们的房间就会发现：很多电器中都装了电动机，比如钟表、电扇、吹风机、计算机。电同样可以使扩音器中的磁芯振动，正因如此我们的音响设备、电视机才能够产生声音，播放语音和音乐。有一类设备或许能很清晰地阐释电能驱使物体运动的最简单也最具代表性的方式，然而由于这类设备正在被能够实现同样功能的电子器件逐步取代，它们正在迅速地消失。在我看来，最令人赞叹的例子应该算是电子蜂鸣器和电铃了。将继电器、电池、开关按如下形式连接。 如果你认为这个系统看起来有点古怪，说明你还没有发挥出想象力。或许以前我们没见过采用这种连接方式的继电器，因为我们通常所见过的继电器，其输入和输出是在两个回路当中的，而这里却构成了一个回路。当开关闭合后，电路就连通了。连通的电路使得电磁铁把金属簧片拉了下来。 当金属簧片的位置变化时，电路不再连通，电磁铁不再具有磁性，金属簧片又弹回原位。 如此一来，电路又一次连通了。从整个过程来看：开关一旦闭合，金属簧片就会上下跳动——电路也会随之连通或断开——声音也就会随之发出。如果金属簧片发出了一种刺耳的声音，这套系统就成为了一个蜂鸣器。如果金属簧片前端是一把小锤子，旁边只要放上一个锣，就构成了一个电铃。大家可以自行脑补一下。 实在脑补不出来同学的可以参考下图: 振荡器(oscillator)其实上面的电路还有另一种接法，下面的示意图中包含了一个标准电压符号和一个接地符号。 看到这幅图你或许立刻想起了非门(或者称反向器)，因此电路可以简化为如下图所示。 反向器，顾名思义，当它的输入是 0 的时候，它的输出就为 1；而当其输入为 1 时，输出就为 0。电路中的开关一旦闭合，反向器中的继电器就会在连通与断开这两种状态之间反复交替。你也可以将电路中的开关省去，这样就可以使反向器连续地工作，如下所示。 这幅图似乎在表达着一种矛盾的逻辑，反向器的输出与其输入是相反的，但是在这里，输出同时又是输入！ 然而，我们要牢牢记住，反向器在本质上就是一个继电器，而继电器将状态取反以得到另一个状态是需要一点点时间的。所以，即使输入和输出是相同的，输出也会很快地改变，成为输入的相反状态（当然，输出随即也会很快改变输入，如此反复）。 这个电路的输出到底是什么呢？其实就是要么提供电压，要么不提供电压，在两者之间切换。我们也可以用这种方式来表达——输出结果要么是 0, 要么是 1。我们把这种电路称为振荡器(oscillator) , 它和我们先前学到的所有东西存在本质上的区别。在此之前我们讲过的所有的电路，其状态的改变都依靠人为的干预(拨动开关)。但是振荡器却在不需要人干涉的情况下，可以完全自发地工作。 当然，单独的一个振荡器用处并不大。但是，在与其他电路连接后所组成的自动控制系统中，振荡器有着举足轻重的作用。为了使不同组件同步工作，所有计算机都配备着某种振荡器。 频率(frequency) 当采用 0 和 1 的交替序列来表示振荡器的输出时，我们一般使用下面这样的图来形象地描述输出。 我们可以通过这幅图来充分地了解电路的输出，水平坐标代表时间，垂直坐标用来表示输出是 0 还是 1。 这幅图表示随着时间的推移，振荡器的输出在 0 和 1 之间按照固有的规律交替变化。正因为这一点，振荡器又经常被称为时钟(clock)——通过振荡进行计数也是一种计时方式。 振荡器运行速度究竟有多快呢？换句话说，金属簧片多久会振动一次？或者每秒钟振动多少次呢？这很大程度上依赖于继电器的内部构造。你容易想到，一个又大又重的继电器只能缓慢地上下摆动；而一个又小又轻的继电器却可以高速地跳动。振荡器从某个初始状态开始，经过一段时间又回到先前初始状态的这一段间隔定义为振荡器的一个循环(cycle)，或者称为一个周期，如下图所示。 一个循环所占用的时间就是该振荡器的周期(period)。假设我们使用的振荡器的周期恰好是 0.05s，任取一个时间点，将其设置为起始状态点，我们把它标注为零点，就可以在水平轴上标出相应的时间。 周期的倒数就是振荡器的频率(frequency)。在这个例子中振荡器的周期是 0.05s，那么其频率就是 1➗0.05s，即振荡器每秒钟产生 20 次循环，而相应的输出每秒钟也变化 20次。 每秒钟的循环次数与每小时穿越的公里数、每立方米水的重量、每份食物的卡路里数等概念一样都是很容易理解的，但这种描述方法已不常用。为了纪念发送和接收无线电波的第一人——亨利希·鲁道夫·赫兹(1857-1894), 后人使用『赫兹』这个词来表示这一概念。这种用法起源于 20 世纪 20 年代的德国，几十年之后逐渐被其他国家所广泛采纳。这样，上述振荡器的频率就是 20 赫兹，记做 20Hz。 计算机的心率现在你应该清楚电脑主频这个参数的作用了吧。那么问题来了，现代计算机的振荡器还是由继电器构成的吗？是不是主频越高就意味着电脑的处理速度就越快呢？ 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 心率 反向器 电子振荡器 时钟频率","raw":null,"content":null,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"//huminxi.com/categories/计算机基础/"}],"tags":[{"name":"心率","slug":"心率","permalink":"//huminxi.com/tags/心率/"},{"name":"计算机","slug":"计算机","permalink":"//huminxi.com/tags/计算机/"}]},{"title":"谈谈计算机中的四则运算","slug":"谈谈计算机中的四则运算","date":"2018-01-20T16:04:02.000Z","updated":"2018-01-28T02:57:41.000Z","comments":true,"path":"2018/01/21/谈谈计算机中的四则运算/","link":"","permalink":"//huminxi.com/2018/01/21/谈谈计算机中的四则运算/","excerpt":"经过前面 从零开始造一台自己的加法器 的学习，现在我们已经能造出一台简易的二进制加法器，可以利用它来做四位二进制的加法。那么减法、乘法和除法呢，难道我们也要一一构造减法器、乘法器和除法器吗？","text":"经过前面 从零开始造一台自己的加法器 的学习，现在我们已经能造出一台简易的二进制加法器，可以利用它来做四位二进制的加法。那么减法、乘法和除法呢，难道我们也要一一构造减法器、乘法器和除法器吗？ 加法和减法8 位二进制加法器四位二进制加法器 将两个四位二进制加法器串联起来，我们就能得到一个 8 位的二进制加法器。也就是说，我们想要相加的二进制数，其范围是从 0000-0000 到 1111-1111，即十进制的 0 到 255。两个 8 位二进制数的和最大可为 1-1111-1110，即 510。 借位 当你确信继电器连接到一起真的可以实现二进制加法的时候，你可能会问:『那么如何实现减法呢？』提出这样的问题并不是说你在没事找事，而实际上这表明你是相当有观察力的。加法和减法在某些方面相互补充，但在机制方面这两个运算则是不同的。加法是始终从两个加数的最右列向最左列进行计算的。每一列的进位加到下一列中。在减法中没有进位，而是有借位——一种与加法存在本质区别的麻烦机制。例如，我们来看一个典型的借位减法的题目： 253 -176 ---- ??? 要想计算结果，首先从最右列着手。我们看到，6 是大于 3 的，因此从 5 借 1，再用 13 减去 6，得到结果为 7。由于我们已经在 5 上借了 1，因此，现在实际上那一位是 4，而 4 是小于 7 的，因此继续从 2 借 1，14 减 7 结果为 7。由于 2 借了 1，实际上这一位是 1，从 1 中减去 1，结果为 0。因此，最后结果应为 77 253 -176 ---- 77 如何才能通过一连串逻辑门来实现这个反逻辑呢？然而，我们并不打算这样做。相反，我们打算利用一个小技巧来让减法不涉及借位。 模 在日常生活当中，如果你仔细观察的话会发现:把某物体左转 90 度，和右转 270 度，在不考虑圈数的条件下，最终的效果是相同的；把分针顺时针拨 20 分钟，和逆时针拨 40 分钟，在不考虑时针的条件下，效果也是相同的；把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，效果也是相同的；………上述几组数字，有这样的关系： 90 + 270 = 360 20 + 40 = 60 25 + 75 = 100式中的 360、60 和 100，就是『模』。 自定义编码 让我们来想一想。通常用来表示正数和负数的方法，其好处就在于能表示所有的正数、负数。我们将 0 想象为这个无限延伸的序列的中点。这个序列中正数沿着一个方向延伸，而负数则按照另一个方向延伸: ...-10000, -9999...-3, -2, -1, 0, 1, 2, 3...9999, 10000... 但是，如果我们并不需要无限大或无限小的数，而且在开始的时候我们就可以预知所使用的数字的范围，那情况就有所不同了。以支票账户为例，这里人们通常会遇到负数。假设我的账户余额小于 500 美元，并且银行给了我们 500 美元的无息预支额度，意思就是账户余额数值应该是一个在 499 美元到 -500 美元之间的数。假设我们不会一次取出 500 美元，我们也不会支出多于 500 美元的金额，这里我们用到的只是美元，不涉及美分。这些假设表明账户能处理的额度是介于 -500 到 499 之间，总共 1000 个数，而我们只用三位十进制数就可以表示所有需要的数字。我们并不需要用到从500 到 999 之间的正数，因为我们所需要的数的最大值为 499。因此从 500 到 999 的三位数可以用来表示负数。具体情况如下： 用 500 表示 -500 用 501 表示 -499 用 502 表示 -498 ...... 用 998 表示 -2 用 999 表示 -1 用 000 表示 0 用 001 表示 1 用 002 表示 2 ...... 用 497 表示 497 用 498 表示 498 用 499 表示 499 也就是说，以 5, 6, 7, 8 或 9 开头的三位数实际上表示的都是负数，而不是把数字写成这样： —500, -499, -498...-4, -3, -2, —1, 0, 1, 2, 3, 4...497, 498, 499 用这种表示法，我们可以将它们写成： 500, 501 ,502...996, 997, 998, 999，000, 001, 002, 003, 004...497, 498, 499 注意，这就形成了一个循环排序。最小的负数(500)看起来像是最大正数(499)的延续。而数字 999 (实际上是 -1)是比 0 小 1 的第一个负数。如果我们在 999 上加 1,通常会得到 1000。由于我们处理的是三位数，这个结果实际上就是 000。这种标记方法称为 10 的补数(ten’s complement)为了将三位负数转化为 10 的补数，我们用 999 减去它再加 1。也就是说，对 10 求补数就是对 9 的补数再加 1。例如想要得到 -255 对 10 的补数，用 999 减去 255 得到 744, 然后再加 1, 得到 745。你可能听说过：『减一个数就等于加一个负数。』你可能会回答：『实际上还是减去了这个数。』然而，利用 10 的补数，我们将不会再用到减法。所有的步骤都用加法来进行。 那么回到我们的 8 位二进制数，如果我们这样编码: 二进制数 十进制数 1000 0000 -128 1000 0001 -127 1000 0010 -126 1000 0011 -125 … … 1111 1101 -3 1111 1110 -2 1111 1111 -1 0000 0000 0 0000 0001 1 0000 0010 2 … … 0111 1101 125 0111 1110 126 0111 1111 127 注: 在这里模为 1-0000-0000，即 256。 这个编码为我们提供了一种不用负号就能表示正负数的方法。同样也让我们自由地将正数和负数用加法法则相加。例如，将 127 和 -1 等价的两个二进制数相加。利用上面的表格，可以简单写为: 127 0111 1111 - 1 &lt;=&gt; + 1111 1111 ---- --------- 126 1 0111 1110 ，忽略最左边的进位 1，最后结果为 126。 或 127 0111 1111 -128 &lt;=&gt; + 1000 0000 ---- --------- -1 1111 1111，结果为 -1。 要注意的是，这里涉及了上溢和下溢情况，即结果大于 127 或小于 -128。例如，将 125 与它自身相加 125 0111 1101 +125 &lt;=&gt; + 0111 1101 ---- --------- 250 1111 1010 ，结果为 -6，出现上溢。 将 -125 与它本身相加也会出现相同的情况。 -125 1000 0011 -125 &lt;=&gt; + 1000 0011 ---- --------- -250 1 0000 0110 ，结果为 6，出现下溢。 现在，二进制数可以有两种不同的使用方法。二进制数可以是有符号的，也可以是无符号的。无符号的 8 位二进制数所表示的范围是 0 ~ 255。有符号的 8 位二进制数表示的范围是 -128 ~ 127。无论是有符号的还是无符号的，数字本身是无法表示的。例如，如果有一个人问:『有一个 8 位二进制数，值为 10110110。它相当于十进制的多少？』你必须先问:『它是有符号数还是无符号数？它可能为 -74 或 182。』这就是二进制的麻烦之处，它们只是一些 0 和 1，本身并没有任何含义。 乘法和除法乘法乘法 &lt;=&gt; 连续的加法 除法除法 &lt;=&gt; 连续的减法 &lt;=&gt; 连续的加法 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 原码、反码和补码","raw":null,"content":null,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"//huminxi.com/categories/计算机基础/"}],"tags":[{"name":"四则运算","slug":"四则运算","permalink":"//huminxi.com/tags/四则运算/"},{"name":"四则","slug":"四则","permalink":"//huminxi.com/tags/四则/"},{"name":"运算","slug":"运算","permalink":"//huminxi.com/tags/运算/"}]},{"title":"tomcat + servlet + jsp 开发登录页面实例","slug":"tomcat-servlet-jsp-开发登录页面实例","date":"2018-01-13T08:46:41.000Z","updated":"2018-01-14T08:02:56.000Z","comments":true,"path":"2018/01/13/tomcat-servlet-jsp-开发登录页面实例/","link":"","permalink":"//huminxi.com/2018/01/13/tomcat-servlet-jsp-开发登录页面实例/","excerpt":"大家在浏览网站时，都遇到过需要输入用户名和密码的情况，然后网站会对你的输入信息进行校验。如果用户名密码正确，接下来你就可以正常访问受限资源了。反之，网站就会给你相应的错误提示。今天我们就用 tomcat + servlet 来编写简单的登录页面。","text":"大家在浏览网站时，都遇到过需要输入用户名和密码的情况，然后网站会对你的输入信息进行校验。如果用户名密码正确，接下来你就可以正常访问受限资源了。反之，网站就会给你相应的错误提示。今天我们就用 tomcat + servlet 来编写简单的登录页面。 概念 Tomcat 是由 Apache 软件基金会下属的 Jakarta 项目开发的一个 Servlet 容器，按照 Sun MicroSystems 提供的技术规范，实现了对 Servlet 和 JavaServer Page（JSP）的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web server；这两个 HTTP web server 不是捆绑在一起的。Apache Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。 Servlet 是一个在 Web 服务器中运行的小型 Java 程序。Servlet 的接收和响应来自Web客户端的请求，通常通过 HTTP(超文本传输协议)。 JSP（全称 Java Server Pages）是由 Sun MicroSystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的 Web 网页的技术标准。JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于 HTTP 的应用程序。JSP 使 Java 代码和特定的预定义动作可以嵌入到静态页面中。JSP 句法增加了被称为 JSP 动作的 XML 标签，它们用来调用内建功能。另外，可以创建 JSP 标签库，然后像使用标准 HTML 或 XML 标签一样使用它们。标签库提供了一种和平台无关的扩展服务器性能的方法。JSP 被 JSP 编译器编译成 Java Servlets。一个 JSP 编译器可以把 JSP 编译成 Java 代码写的 servlet 然后再由 Java 编译器来编译成机器码，也可以直接编译成二进制码。 实现登录流程图 代码项目结构 LoginInfo1234567891011121314151617181920212223242526package entity;/** * 登录信息 */public class LoginInfo &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; LoginServlet1234567891011121314151617181920212223242526272829303132333435363738394041package servlet;import entity.LoginInfo;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 登录servlet */public class LoginServlet extends HttpServlet &#123; private static final String USERNAME = \"admin\"; private static final String PASSWORD = \"admin\"; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //让doGet执行与doPost相同操作 System.out.println(\"doGet方法被执行..\"); doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"doPost方法被执行..\"); LoginInfo loginInfo = new LoginInfo(); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); loginInfo.setUsername(username); loginInfo.setPassword(password); //判断用户名和密码是否正确 if (USERNAME.equals(loginInfo.getUsername()) &amp;&amp; PASSWORD.equals(loginInfo.getPassword())) &#123; resp.sendRedirect(req.getContextPath() + \"/login_success.jsp\"); &#125; else &#123; resp.sendRedirect(req.getContextPath() + \"/login_fail.jsp\"); &#125; &#125;&#125; web.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; login.jsp12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/servlet/LoginServlet\"&gt; 用户名: &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 密码: &lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login_fail.jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录失败&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录失败，请检查用户名和密码!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; login_success.jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;恭喜你，登录成功!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 登录界面 运行结果 本文引自 JAVA遇见HTML——Servlet篇 java 学习总结 Apache Tomcat Java Servlet JSP","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.com/categories/编程实践/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"//huminxi.com/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"//huminxi.com/tags/servlet/"}]},{"title":"年会街舞纪实","slug":"年会街舞纪实","date":"2018-01-08T14:57:31.000Z","updated":"2018-01-31T15:12:24.000Z","comments":true,"path":"2018/01/08/年会街舞纪实/","link":"","permalink":"//huminxi.com/2018/01/08/年会街舞纪实/","excerpt":"不知道是上周几，公司年会节目抽签，郭大侠一下子就给我们技术部抽中了舞蹈。于上周五晚上本人就被内定成了年会街(ga)舞成员，也不知郭大侠是否知情，我在校期间也曾报过一个学期的健身街(ga)舞课。从这周一(1月8号)开始，我开始了紧张而刺激的街(ga)舞学习。","text":"不知道是上周几，公司年会节目抽签，郭大侠一下子就给我们技术部抽中了舞蹈。于上周五晚上本人就被内定成了年会街(ga)舞成员，也不知郭大侠是否知情，我在校期间也曾报过一个学期的健身街(ga)舞课。从这周一(1月8号)开始，我开始了紧张而刺激的街(ga)舞学习。 2018-01-08 23:10练舞第一天。 大家利用 12:00 至 13:00 这一个小时的午休时间开始了第一次年会街(ga)舞练习。因为是第一次练习，许多小伙伴还有点羞涩，没有解放出天性。不过随着大家一起练习次数的增加，应该会越来越棒的，加油! 2018-01-09 22:41练舞第二天。 除了继续利用中午的一个小时，晚上大家在李教练的指导下又继续加练了一个小时。感觉进度应该没问题，现在只剩下年会时跳的到底是街舞还是街(ga)舞的问题了。 2018-01-10 23:23练舞第三天。 同昨天一样的训练时间，不过大家的热情明显高涨了不少。keep going! 2018-01-11 23:25练舞第四天。 由于中午练习对下午的工作的影响有点大，所以就只在晚上练习了。好消息是大家在今天已经完成了前半段的学习，明天开始后半段的学习。 2018-01-13 00:23练舞第五天。 今晚练了后半段的第一、二节。这样只剩下最后一节动作了。 2018-01-13 16:44练舞第六天。 由于明天是周日，所以今天也休息一天，但教练说下周就要辛苦一点了。 2018-01-15 20:39练舞第七天。 今天由于刷数据的原因，上去练习的时间缩短了，导致学习效果不佳。教练教的动作都没有完全掌握，明天要把这部分补上。 2018-01-16 21:54练舞第八天。 今天终于把所有内容都学完了，跟着教练也能勉强做完一整套动作。明天开始就是不断的练习了。 2018-01-17 20:56练舞第九天。 今天男生都去参加了”农分期大牛成长营”第一期的会议(17:40 ~ 18:40)，所以练习取消。这样一来本周就只剩下明天一天的练习时间了，而下周一就要出排练视频。所以明天加油吧！ 2018-01-18 20:17练舞第十天。 今天开始跟音乐了，发现几个问题。 动作还不太熟练 整体节奏不一致 人员不齐，无法排练队形 下周开始一个一个的解决上述问题。fighting! 2018-01-22 22:01练舞第十一天。 今天发现一个新的问题：村花同时是年会主持人，从今天开始她要参加主持人的排练。这样两个练习时间就有冲突。我的建议是：给村花预留一个位置，其它的人先把队形排练好，剩下村花再找时间单独给她排练一下，完美。 2018-01-23 21:47练舞第十二天。 村花今天也参加了队形的排练，所以队形大体上已经编排完成。但由于没有视频反馈，导致不太清楚整体上是否统一和协调。明天需要拍个视频给自己看看。 2018-01-24 19:11练舞第十三天。 今天小渊(撸代码)和村花(准备述职)都没有参加排练。大家勉强能跟上音乐了，就是还有部分动作跟不上节奏。明天人应该可以到齐吧。 2018-01-25 22:04练舞第十四天。 今天杨洋和佳欣没有参加排练，于是大家跟着音乐把动作又熟悉了几遍。不过，剩余的排练时间不多了。 2018-01-26 20:51练舞第十五天。 今天大家又跟着教练和音乐熟悉了几遍动作，感觉不错。加油。 2018-01-29 36:20练舞第十六天。 总部所有的会议室被占，今天的练习取消。 2018-01-30 12:20练舞第十七天。 明天就要上台了，今天上午大家又一起排练了几遍。晚上 18:30 到 21:00 大家在总部把所有节目都彩排一遍。 2018-01-30 22:28练舞第十八天。 明天，丑媳妇终于要见公婆了。回想这 1 月 8 号就开始的练习之旅，感触颇多。 我们从开始的拘谨、茫然、闷骚，到现在的开放、自信、外骚，谁知道我们经历了什么!不怕大家笑话，其实我从小就觉得跳街舞的人特帅，一直想着什么时候自己也能在大家面前表演一段完整的街舞。为此，大学期间我也曾报过一个学期的街舞课，但结果只拿了一个 B。说来也巧，这时郭星刚好指定我为”年会街舞成员”。当时心想，那就最后再试一遍吧，不管自己能不能通过这次的筛选，这可能是我最后的圆梦机会了。这 18 天来，大家每天都坚持抽出一个半小时练舞，没有你们的坚持和陪伴，像我，今生应该就与舞台绝缘了吧。谢谢你们给我的这个机会！明天我们什么都不要管，只需要跳好自己的舞蹈，相信结果一定不会让大家失望的。明天加油！ ps: 再次感谢一直都很认真负责的李小晴教练。 明天第二排的小伙伴记得和教练站紧一点，不然最后两排的小伙伴可能会被遮挡住。 2018-01-31 22:33练舞第十九天。 『International 秧歌 show』——有你们真好！ The End?","raw":null,"content":null,"categories":[{"name":"日记","slug":"日记","permalink":"//huminxi.com/categories/日记/"}],"tags":[{"name":"年会","slug":"年会","permalink":"//huminxi.com/tags/年会/"},{"name":"街舞","slug":"街舞","permalink":"//huminxi.com/tags/街舞/"},{"name":"ga","slug":"ga","permalink":"//huminxi.com/tags/ga/"}]},{"title":"mac 上如何搭建个人博客","slug":"mac 上如何搭建个人博客","date":"2017-12-31T05:33:47.000Z","updated":"2018-01-02T10:17:25.000Z","comments":true,"path":"2017/12/31/mac 上如何搭建个人博客/","link":"","permalink":"//huminxi.com/2017/12/31/mac 上如何搭建个人博客/","excerpt":"最初对个人博客有印象，就是阮一峰的个人博客。当时是在搜索 互联网协议入门 这篇文章的时候，发现原来还可以这么玩。随后在和黑牛的一次谈话中，他问我:2017年就快要过去了，今年的总结写了吗？这才反应过来，2017年已经到末尾了。于是就有了想写点东西，留作以后回忆的索引，搭建个人博客也就顺理成章了。","text":"最初对个人博客有印象，就是阮一峰的个人博客。当时是在搜索 互联网协议入门 这篇文章的时候，发现原来还可以这么玩。随后在和黑牛的一次谈话中，他问我:2017年就快要过去了，今年的总结写了吗？这才反应过来，2017年已经到末尾了。于是就有了想写点东西，留作以后回忆的索引，搭建个人博客也就顺理成章了。 大道三千，我走直线利用 Hexo + Github Pages 来搭建个人博客 或自行 google Hexo什么是 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 HexoHexo的安装在其 官方文档 中有很详细的说明。 校验cd &lt;hexo 的安装目录&gt;hexo ghexo s 现在我们打开 http://localhost:4000/ 已经可以看到一篇内置的blog了。 进阶自己切换 hexo 主题，本人使用的是 Next 主题。 Github Pages注册 Github 账号进入 Github 网站，按照提示进行注册并登陆。 创建 Github Pages 仓库登录完成之后，在你的主页点击图标 New repository 创建一个新的版本库，因为我们是使用 Github Pages 去搭建我们的静态博客，所以 repository 的名称格式 你的用户名 + .github.io。例如：我的用户名是：huminxicn，那么 repository 的名字应该是： huminxicn.github.io 。因为之后你将要访问的你的博客地址就是： https://huminxicn.github.io 。 至此，Github 账号创建完成，Github Pages 所需要的 repository 也创建好了。 进阶自己购买域名，然后再让 Github Pages 解析到此域名就行。Learn more 关联 Hexo 与 Github Pages配置 SSH检查是否已经存在 ssh key cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用 git。否则，可以看到如下的目录结构 生成新的 SSH Keyssh-keygen -t rsa -C &quot;&lt;你常用的邮箱地址&gt;&quot; 输入命令回车之后会提示你输入一些东西，不用管，一直回车到底就好了。然后你的 ~/.ssh 目录下就会生成两个文件 id_rsa 和 id_rsa.pub 。 配置 Github打开你的 Github -&gt; Settings -&gt; SSH and GPG Keys 。然后点击 New SSH Key 创建一个新的SSH Key。 Title 可以用你的计算机名，可以用以区分。将 id_rsa.pub 文件中的所有内容复制到 Key 里面。 然后使用下面的命令测试是否可以连接上 Github 。ssh -T git@github.com 将 Hexo 博客部署到 Github Pages先使用下面的命令对 Git 进行初始配置，用来跟踪提交信息 git config --global user.name &quot;&lt;你的名字&gt;&quot;git config --global user.email &quot;&lt;你常用的邮箱地址&gt;&quot; 然后编辑 hexo 根目录下的 _config.yml 文件，设置其中的 deploy 参数，详细请查看 Hexo 官方文档中 部署 部分。 git 地址建议使用 SSH 地址。在上面的参数设置好了之后，使用下面的命令安装 hexo-deployer-git 插件，只有安装了插件之后才可以部署到 Github Pages。 npm install hexo-deployer-git --save 校验安装完插件之后使用下面的命令进行部署： hexo g #生成静态文件hexo d #部署到github 或hexo d -g #部署前生成静态文件 好了，快去访问你的 个人博客 吧！ 本文引自 hexo hexo-cn 域名系统(英文:Domain Name System, 缩写:DNS) 使用Hexo搭建个人博客 如何搭建一个独立博客——简明Github Pages与Hexo教程","raw":null,"content":null,"categories":[{"name":"日记","slug":"日记","permalink":"//huminxi.com/categories/日记/"}],"tags":[{"name":"博客","slug":"博客","permalink":"//huminxi.com/tags/博客/"},{"name":"个人博客","slug":"个人博客","permalink":"//huminxi.com/tags/个人博客/"}]},{"title":"2017 年终总结","slug":"2017 年终总结","date":"2017-12-24T09:08:11.000Z","updated":"2018-01-20T16:23:11.000Z","comments":true,"path":"2017/12/24/2017 年终总结/","link":"","permalink":"//huminxi.com/2017/12/24/2017 年终总结/","excerpt":"时间过得跟狗一样的快!  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; –鲁迅","text":"时间过得跟狗一样的快! &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; –鲁迅 年度事件转正述职原先预定的是1月13号的转正述职，后因为开”月需求讨论会”而推迟到了14号。我记得来到农分期的第一天就是23点钟下班的，黑牛、建国、孟铀、忠泽、嘟嘟5️位位后端小伙伴用实际行动告诉了我什么才叫做自愿加班。当时农人帮系统在重构，整个系统重构了大概7、8个月的时间。一直到2016-10-10才上线。开始的3个月基本上都是自己在看张龙老师的 java 教学视频，收益颇丰。后面的3个月才开始慢慢的接触需求开发，在建国的指导下也完成了几个功能的上线。当然，后面用了 N 多版本来修复 bug，N &gt;=10 。在实习期间，老韩的以身作则、黑牛的精益求精、孟铀的诲人不倦、建国的勇往直前、忠泽的积极乐观、嘟嘟的善解人意让我感触良多。因为和你们一比较，发现我一无是处。而且整个技术部的氛围是自由和温暖，这是最打动我的地方。后面也勉强达到了公司的及格线，幸运的留在了公司。 与孟铀合租房子1月18号的时候与孟铀合租了位于南京市栖霞区尧林仙居碧水苑的一套两居室。月租1900，水电不免，燃气自包。孟铀为了照顾我，他出1000+每月网费，我900。当时签的是一年的合同，现在也快要到期续租了。 年中考核具体的考核内容已经记不清了，现在只记得老韩对我说过的一句话:你可以多尝试，做更多的事情。 一周年2017-7-4 号，来农分期一周年了。公司送给我一张写满了同事祝福语的生日祝福卡、一个实用的枕头、一张价值100元的苏果购物卡。感谢我期。 青岛之行2017-11-18 至 2017-11-20 号去青岛玩了三天。顺带参加了一下青岛马拉松的12.3公里的体验跑。许多人一起跑步，旁边有志愿者帮你准备补给，还帮你喊加油的感觉真不错。明年也要参加至少一次的马拉松。 个人博客2017-11-22 利用 Hexo 框架和 Git Pages 搭建了个人博客。 明年目标 参加一次马拉松(最好是半程或以上) 看完《深入理解计算机系统》和《算法》这两本书 去一趟深圳","raw":null,"content":null,"categories":[{"name":"年终总结","slug":"年终总结","permalink":"//huminxi.com/categories/年终总结/"}],"tags":[{"name":"2017","slug":"2017","permalink":"//huminxi.com/tags/2017/"},{"name":"年终总结","slug":"年终总结","permalink":"//huminxi.com/tags/年终总结/"}]},{"title":"观《你的名字》有感","slug":"观《你的名字》有感","date":"2017-12-17T13:28:58.000Z","updated":"2018-01-14T08:00:58.000Z","comments":true,"path":"2017/12/17/观《你的名字》有感/","link":"","permalink":"//huminxi.com/2017/12/17/观《你的名字》有感/","excerpt":"今天下午第一次看 2016-12-2 号就已经上映的新海诚导演的影片《你的名字》，因为看完电影之后觉得故事还有不清晰的点，所以又去看了一下与电影相关的点评。这才理清楚了其中的故事脉络。","text":"今天下午第一次看 2016-12-2 号就已经上映的新海诚导演的影片《你的名字》，因为看完电影之后觉得故事还有不清晰的点，所以又去看了一下与电影相关的点评。这才理清楚了其中的故事脉络。 《你的名字》中的几个点，你 get 到了吗三叶其实比立花泷大三岁首先，我们知道随着剧情的推展，男女主角逐渐发现自己在睡梦中发生的事情，实际上并不作是梦，而是现实中确实与对方交换了灵魂。导演新海诚在这边添加了许多轻松幽默的元素，以此来说明两人不断摸索对方到底是谁的过程。最好笑的莫过于灵魂交换到三叶身体里的泷，每天早上醒来双手都放在胸部上面。在两人发现灵魂会互换后也彼此约法三章：要求不管做了什么都要记录下来让对方知道、喜欢体验东京生活的三叶不能乱花泷的钱、三叶要求泷坐姿要坐好、以及不能乱摸她的身体。 在两人渐渐的了解对方后，三叶发现在泷的心中暗恋着一起工作的奥寺前辈，决定帮他一把。知道女人心中喜好的三叶很快的就帮泷促成两人首次的约会，甚至担心约会当天如果灵魂没有交换过来，不擅长跟女人交谈的泷会不知所措，还帮泷制作了约会必胜笔记，笔记的最后写道「约会结束的时候正好可以看到彗星吧」。然而泷看到这句话时抬头看了下傍晚的天空，发现天空中并没有彗星，所以不明白三叶最后说的「约会结束的时候正好可以看到彗星吧」这句话是什么意思。这里正是导演新海诚埋下的第一个伏笔，透露出两人身处的时空其实是不相同的！ 为什么过去的历史可以被改变 三叶、四叶你们听过「结」（日文音译产灵）吗？是一个土地神，古语叫做「结」，这个名称有深远的含义。连接绳线是「结」，连接人与人是「结」，时间的流动也是「结」，全都是神的力量，我们做的结绳也是神的作品。这正是时间流动的体现，聚在一起、成型、扭曲、缠绕，有时又还原、断裂，再次连接，这就是「结」，这就是时间。 这段话正是贯穿整部电影的重点，电影核心剧情就建构在三叶奶奶这里口中所提到的「结」，就字面上表示的意思，时间的流动如同动画中三叶编的结绳拥有类似的性质，是可以还原、断裂甚至再次接上的，这也解释了为什么泷回到彗星坠落前日，可以改变原本要发生的事情，提醒敕使与耶香即将有灾难降临到系守镇。而这样的举动，让原先因为彗星坠落导致时间轴断裂（死亡）的三叶，能再次接续了她的生命。 为什么两人在黄昏之时可以相见站在科学的角度来理解，两人灵魂交换的理论依据其实是「莫比乌斯」环。莫比乌斯循环其实就是将一条长条纸带，其中一头旋转一百八十度后相黏，如果你事先在纸带的正反两面涂上不同颜色，相黏后你会发现不管你拿着笔沿着纸带上哪一个地方开始走，你可以不断的循环反覆经过两个不同的颜色区段。 而这边正反两面的颜色可以想像成：一种颜色是泷的身体，另一种颜色是三叶的身体，在正反两面行走的则是两人的灵魂。每当经过纸带黏接的交接处，原先位于纸带正面的灵魂会跑到背面，背面的会跑到正面，两人灵魂反覆交换的现象正是如同被扭曲连结的「莫比乌斯」循环。 故事前半段老师在黑板前上课时提到的「黄昏之时」，即傍晚非日非夜的这个时段，世界的轮廓会变得模糊，是可能看到非人之物的时段。世界的轮廓可以比喻成纸带相黏的交界处，也是两者唯一有机会短暂交会的时刻。 为什么泷和三叶会忘记对方的名字 前面就是黄泉世界，想要从黄泉世界回到这个世界，必须用你最重要的东西来交换。 很多人觉得泷始终想不起三叶的名字是因为他们的遭遇就像作梦一样，而经由潜意识产生的梦醒来后忘记是理所当然的。不过本片中不仅能看穿泷的灵魂在三叶体内、而且每句话还通通都是重点的”最强角色”三叶奶奶曾说过：要从黄泉世界回归原本的世界需要拿最珍贵的东西交换，而对三叶与泷来说最重要的东西就是两人之间一同经历的那段珍贵回忆，最后虽然泷成功把三叶从另一个世界带回来，但两人也因此都忘了记忆中最重要的彼此与对方的名字。 只有三叶才互换过灵魂吗其实不是的，影片中奶奶和回到三年前三叶身体的泷提到了自己还是少女时也曾做过不可思议的梦，但是有关这个梦的记忆现在却已经消失了，还提到无论是她自己还是三叶的母亲都曾有过类似的经历。且电影的最后也给了四叶成高中生后，抬头望向窗外的一个镜头，暗示了四叶开始了灵魂互换。 本文引自 《你的名字》中隐藏的五个秘密！ 你的名字中的一些暗线故事 有关命中注定和世界的自动修正 附加 点击下载《你的名字》小说 后续同人小说链接","raw":null,"content":null,"categories":[{"name":"日记","slug":"日记","permalink":"//huminxi.com/categories/日记/"}],"tags":[{"name":"你的名字","slug":"你的名字","permalink":"//huminxi.com/tags/你的名字/"}]},{"title":"一种基于前后端分离的单点登录实现方案","slug":"一种基于前后端分离的单点登录实现方案","date":"2017-12-10T12:43:57.000Z","updated":"2018-01-14T08:00:58.000Z","comments":true,"path":"2017/12/10/一种基于前后端分离的单点登录实现方案/","link":"","permalink":"//huminxi.com/2017/12/10/一种基于前后端分离的单点登录实现方案/","excerpt":"单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。相同的，单一注销（single sign-off）就是指，只需要单一的注销动作，就可以结束对于多个系统的访问权限。","text":"单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。相同的，单一注销（single sign-off）就是指，只需要单一的注销动作，就可以结束对于多个系统的访问权限。 单点登录机制一、单系统登录1、http 无状态协议web 应用采用 browser/server 架构，http 作为通信协议。http 是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程如下图所示，三次请求/响应对之间没有任何联系。 但这也同时意味着，任何用户都能通过浏览器访问服务器上的资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求(响应合法请求，忽略非法请求)；要鉴别浏览器请求，必须清楚浏览器请求状态。既然 http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 2、会话机制当浏览器第一次请求服务器时，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器根据请求中的会话 id 就知道是不是同一个用户了(注:浏览器第一次请求时服务器还没有创建会话)，这个过程用下图说明，后续请求与第一次请求产生了关联。 服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？你可能会想到两种方式: 拼接在 url 中 cookie 将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式比较低级。那就换浏览器自己来维护这个会话 id 吧，每次发送 http 请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以 key/value 形式存储，浏览器发送 http 请求时自动附带 cookie 信息。tomcat 会话机制当然也实现了 cookie ，访问 tomcat 服务器时，浏览器中可以看到一个名为 JSESSIONID 的 cookie，这就是 tomcat 会话机制维护的会话id，使用了 cookie 的请求响应过程如下图。 3、登录状态有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态如下。HttpSession session = request.getSession;session.setAttribute(“isLogin”, true); 用户再次访问时，tomcat 在会话对象中查看登录状态。HttpSession session = request.getSession;session.getAttribute(“isLogin”); 实现了登录状态的浏览器请求服务器模型如下图所示。 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 二、多系统的复杂性web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样。 web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie 的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie。 既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如 “*.baidu.com”，然后将它们的 cookie 域设置为 “baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。然而，可行并不代表好，共享 cookie 的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间；第三，cookie 本身不安全。因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 三、单点登录什么是单点登录？单点登录全称 Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录。 1、登录相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，先由子系统产生临时令牌，然后 sso 认证中心验证用户的用户名密码没问题，最后 sso 认证中心再通知各子系统令牌生效。之后浏览器端可以利用之前就返回的令牌进行受限资源的访问。 下面对上图简要描述 用户访问 nrb 的受限资源，nrb 发现用户未登录，nrb 生成一个 tokenA，并将 tokenA 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，并关联 sessionId 和 userId sso 认证中心通知 nrb 绑定 tokenA 和 userId 并进行保存 sso 认证中心跳转回用户访问的nrb系统 用户利用之前就已经返回的 tokenA 来访问 nrb 的受限资源 用户访问 hades 的受限资源，hades 发现用户未登录，hades 生成一个 tokenB，tokenB 返回给用户，然后跳转至 sso 认证中心 sso 认证中心发现用户已登录 sso 认证中心通知 hades 绑定 tokenB 和 userId 并进行保存 sso 认证中心跳转回用户访问的hades系统 用户利用之前就已经返回的 tokenB 来访问 hades 的受限资源 2、注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明。 sso 认证中心一直监听会话的状态，一旦会话销毁，监听器将通知所有管理系统执行注销操作。 用户向 hades 系统发起注销请求 hades 系统向 sso 认证中心发起注销请求，并将用户的 tokenA 和存储在 cookie 中的 sessionId 当做参数传递 sso 认证中心取出与 sessionId 关联的系统地址和 token sso 认证中心向所有关联系统发起注销请求，并指定需要注销的 token 各关联系统接收 sso 认证中心的注销请求，销毁指定 token sso 认证中心引导用户至登录页面 四、部署图单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以发送令牌、保存令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述。 sso 认证中心与 sso 客户端通信方式有多种，这里以简单好用的 httpClient 为例，web service、rpc、restful api 都可以。 五、实现简要介绍下基于 java 的实现过程，sso 采用客户端/服务端架构，我们先看 sso-client 与 sso-server 要实现的功能（下面：sso 认证中心= sso-server）。 sso-client 拦截子系统未登录用户的请求，生成 token，并将 token、本地 cookie 值和子系统自身地址作为跳转 sso 认证中心的参数进行传递 接收 sso 认证中心通知的 token、userId 并进行保存 通过 token 与用户建立会话 拦截用户注销请求，向 sso 认证中心发送注销请求 接收 sso 认证中心发出的注销请求，注销指定 token sso-server 验证用户的账户信息 创建 session 将 sessionId 与子系统地址及相应的 token，userId 进行关联 与 sso-client 通信发送 token、userId 校验 session 有效性 接受 sso-client 注销请求，注销所有子系统中的 token 引用 单点登录原理与简单实现 HTML色彩","raw":null,"content":null,"categories":[{"name":"编程实践","slug":"编程实践","permalink":"//huminxi.com/categories/编程实践/"}],"tags":[{"name":"单点登录","slug":"单点登录","permalink":"//huminxi.com/tags/单点登录/"}]},{"title":"单例模式","slug":"单例模式","date":"2017-11-28T14:04:34.000Z","updated":"2018-01-14T08:00:58.000Z","comments":true,"path":"2017/11/28/单例模式/","link":"","permalink":"//huminxi.com/2017/11/28/单例模式/","excerpt":"单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。","text":"单例模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单线程版本“懒汉模式” &amp; “饿汉模式”懒汉模式 123456789101112131415161718public class Singleton &#123; // 定义一个空的 Singleton 对象引用 SINGLETON private static Singleton SINGLETON = null; // 利用构造器私有化来限制外部使用 new 关键字，进而避免构造出多个实例 private Singleton() &#123; &#125; // 提供外部获取单例对象的方法 public static Singleton getInstance() &#123; // 如果 SINGLETON 还未指向任何一个 Singleton 对象，new 一个 Singleton 对象出来。 if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 对象引用一开始为 null，具体使用的时候才 new 一个对象出来，这种写法属于懒汉模式。 饿汉模式 123456789101112public class Singleton &#123; // 在定义时就直接 new 出单例对象 private static Singleton SINGLETON = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SINGLETON; &#125;&#125; 顾名思义，单例对象一开始就被 new Singleton() 主动构建，不再需要判空操作，这种写法属于饿汉模式。 多线程版本如果上面”懒汉模式”的代码是运行在多线程环境中，就会出现许多问题。最明显的一个，将有可能 new 出多个 Singleton 对象实例。最简单的修复方式是在 getInstance() 方法上加 synchronize 关键字。 123456789101112131415public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; // 方法上加 synchronized 关键字 public synchronized static Singleton getInstance() &#123; if (SINGLETON == null ) &#123; SINGLETON = new Singleton(); &#125; return SINGLETON; &#125;&#125; 但是这样的话，在每次调用 getInstance() 方法的时候都会加锁。 使用 double-checked lock(双检锁) 可以避免在 new 出单例对象之后还对 getInstance() 方法进行加锁。 1234567891011121314151617181920212223public class Singleton &#123; private static Singleton SINGLETON = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; // 第一次检查 if (SINGLETON == null) &#123; // new Singleton() 代码块才进行加锁 synchronized (Singleton.class) &#123; // 第二次检查 if (SINGLETON == null) &#123; SINGLETON = new Singleton(); &#125; &#125; &#125; return SINGLETON; &#125;&#125; 本文引自 老生常谈双检锁（DCL） The “Double-Checked Locking is Broken” Declaration","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"//huminxi.com/categories/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"//huminxi.com/tags/单例模式/"}]},{"title":"从零开始造一台自己的加法器","slug":"从零开始造一台自己的加法器","date":"2017-11-23T07:13:22.000Z","updated":"2018-01-28T02:57:41.000Z","comments":true,"path":"2017/11/23/从零开始造一台自己的加法器/","link":"","permalink":"//huminxi.com/2017/11/23/从零开始造一台自己的加法器/","excerpt":"在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如:二进制数乘法器的重要组成部分。","text":"在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如:二进制数乘法器的重要组成部分。 10进制与2进制10的替代品对我们人类而言，10是一个非常重要的数字。10是我们大多数人拥有的手指或脚趾的数目，因为手非常便于计数，于是我们已经适应了这个以10为基数的数字系统(也称为十进制数字系统)。起初也很难再构想出其它的数字系统。 当我们看到数字10的时候，我们不自觉地就想到这个数字代表了下面的这么多个苹果： 10 =   但是，数字10之所以指的是这么多个苹果，其唯一的理由就在于这些苹果的数目与我们手指的数目相同。如果人类的手指不是10根，我们数数的方式就会有所不同，那么10就会是另外一个含义。 同样，数字10还可以代表这么多个苹果： 10 =   或者是这么多个苹果： 10 =   甚至可以是这么多个苹果： 10 =  设想一下: 如果人类像卡通人物一样每只手有4根手指那会怎样呢？ 我们可能就不会想到建立一个以10为基数的数字系统。我们会自然而然地、不可避免地想到建立一个以8为基数的数字系统。我们会称它为八进制数字系统。如果我们的数字系统是以8为基数而建立的，我们就不需要下面这个符号： 9 将这个给卡通人物看的话，他会得到这样的反应：”这是什么？它代表什么？“ 继续思考一下，你会发现我们连这样的一个符号也不会需要： 8 在十进制中，”十”没有特定的符号，因此在八进制中，同样也没有表示”八”的特定符号。十进制中我们的计数方式是：0、1、2、3、4、5、6、7、8、9，然后是10。八进制中我们的计数方式是：0、1、2、3、4、4、5、7，然后是什么呢？我们已经将符号用完了。在这里唯一有意义的只有10，而在这里的正确答案恰恰就是10。在八进制中，7之后的一个数字就是10。但这个“10”代表的并不是人类的手指的数量。在八进制中，“10”代表的是卡通人物手指的数量。 2进制如果我们是海豚呢，那么就必须用两个鳍来计数。这个数字系统称为以2为基数的数字系统(或二进制)。这样的话我们似乎只有两个数字了，分别为0和1。在二进制中，1的下一个数字是10。第一次见似乎有点难以理解，但也不用意外。因为无论使用哪种计数系统，当单个的数字用完时，第一个两位数就是10。 二进制数最大的问题是数字用完的很快! 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1110,1111,10000,10001,… 当然，二进制也有它的优点，比如做加法的时候: 11加法表 + 0 1 0 0 1 1 1 10 乘法比加法还容易，比起小时候背的”99乘法表”不知道简单了多少。 11乘法表 x 0 1 0 0 0 1 0 1 99乘法表 x 1 2 3 4 5 6 7 8 9 1 1 2 2 4 3 3 6 9 4 4 8 12 16 5 5 10 15 20 25 6 6 12 18 24 30 36 7 7 14 21 28 35 42 49 8 8 16 24 32 40 48 56 64 9 9 18 27 36 45 54 63 72 81 电磁铁与继电器电磁铁如果你手头有一根铁棒，那么在上面用细导线绕几百圈，然后接通电流，铁棒就变成了一块磁铁。现在它可以吸引其它的铁块或者钢块(电磁铁上缠绕足够多的细导线，会产生足够强的电阻，能防止电磁铁产生短路现象)。断开电流，铁棒将丧失磁性。 图1 中的电路组成元件按顺时针方向依次是 ABCDP 滑动变阻器 E 电磁铁 S 单刀单掷开关 电池 L 电灯泡 电流表 继电器继电器的作用就是通过吸引或弹开衔铁，进而控制另一个电路的通断。 继电器符号和电路图如下所示： 门非门结果与操作数相反。 真值表 NOT 0 1 1 0 符号 电路图 与门两个操作数都为1时结果为1。 真值表 AND 0 1 0 0 0 1 0 1 符号 电路图 或门有一个操作数为1结果就为1。 真值表 OR 0 1 0 0 1 1 1 1 符号 电路图 与非门跟与操作结果相反。 真值表 NAND 0 1 0 1 1 1 1 0 符号 或非门跟或操作相反。 真值表 NOR 0 1 0 1 0 1 0 0 符号 异或门一个操作数为1，另一个操作数为0时，结果才为1。 真值表 XOR 0 1 0 0 1 1 1 0 符号 电路图 二进制加法器 计算二进制数加法与计算十进制数加法非常相似。如果你想让 245 和 673 这两个十进制数相加，你会把这个问题分解为几个简单的步骤。每个步骤只需要将两个十进制数相加，二进制加法也同理。 半加器和全加器加法结果可以拆成两部分，一个是加和结果，另一个是进位结果。二进制加法也可以照下面这个方式进行拆分。 加和表 +加和 0 1 0 0 1 1 1 0 进位表 +进位 0 1 0 0 0 1 0 1 可以利用下面的两个逻辑门来实现上面的结果 异或门 XOR 0 1 0 0 1 1 1 0 与门 AND 0 1 0 0 0 1 0 1 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。因此我们可以将与门和异或门连接在一起来计算两个二进制数(即A和B)的和。 真值表 输入A 输入B 加和输出 进位输出 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 这个被叫做半加器(Half Adder)。之所以被叫半加器是有原因的。它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于1位的。半加器没有做到的是将前一次的加法可能产生的进位位纳入下一次运算。例如，假设我们要将如下两个二进制数相加。 1111 +1111 ----- 11110 我们只能将半加器用于最右面一列的相加：1加1等于0，进位1。对于右面算起的第二列，由于进位位的存在，实际上需要将三个二进制数相加，而随后的每一列的加法都是这样的。随后的每一列二进制数相加都需要将进位位算进来。为了对三个二进制数进行加法运算你，我们需要将两个半加器和一个或门做如下连接。 真值表 进位输入A 输入A 输入B 加和输出 进位输出 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 这个叫做全加器(Full Adder)。我们用如下的符号表示它: 到这里，我们已经迈出了关键的第一步。因为我们可以利用它做2进制的加法：1+1=10！ 多位二进制数相加当然，只能进行一位二进制数相加的加法器的用途实在是太窄了，我们更需要能支持多位二进制数做加法的加法器。答案就是将多个全加器连接起来，组成多位加法器。假设我们将4个全加器连接起来，那么它就能做4位二进制数的加法。如下图所示： 假设有两个4位二进制数A₃A₂A₁A₀和B₃B₂B₁B₀，只需要将它们按位相加，再逐级将低位的进位输出到高位进行计算即可。 本文引自 《Code:The Hidden Language of Computer Hardware and Software》 或 《编码》 《穿越计算机的迷雾》 –李忠","raw":null,"content":null,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"//huminxi.com/categories/计算机基础/"}],"tags":[{"name":"加法器","slug":"加法器","permalink":"//huminxi.com/tags/加法器/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-22T01:56:58.000Z","updated":"2017-11-23T09:42:15.000Z","comments":true,"path":"2017/11/22/hello-world/","link":"","permalink":"//huminxi.com/2017/11/22/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}